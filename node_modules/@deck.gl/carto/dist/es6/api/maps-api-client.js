import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { getDefaultCredentials, getMapsVersion } from '../config';
const DEFAULT_USER_COMPONENT_IN_URL = '{user}';
const DEFAULT_REGION_COMPONENT_IN_URL = '{region}';
export async function getTileJSON(mapConfig, credentials) {
  const creds = _objectSpread(_objectSpread({}, getDefaultCredentials()), credentials);

  switch (getMapsVersion(creds)) {
    case 'v1':
      const layergroup = await instantiateMap({
        mapConfig,
        credentials: creds
      });
      return layergroup.metadata.tilejson.vector;

    case 'v2':
      return await instantiateMap({
        mapConfig,
        credentials: creds
      });

    default:
      throw new Error('Invalid maps API version. It shoud be v1 or v2');
  }
}

async function instantiateMap({
  mapConfig,
  credentials
}) {
  const url = buildURL({
    mapConfig,
    credentials
  });
  let response;

  try {
    response = await fetch(url, {
      headers: {
        Accept: 'application/json'
      }
    });
  } catch (error) {
    throw new Error("Failed to connect to Maps API: ".concat(error));
  }

  const json = await response.json();

  if (!response.ok) {
    dealWithError({
      response,
      json,
      credentials
    });
  }

  return json;
}

function dealWithError({
  response,
  json,
  credentials
}) {
  switch (response.status) {
    case 401:
      throw new Error("Unauthorized access to Maps API: invalid combination of user ('".concat(credentials.username, "') and apiKey ('").concat(credentials.apiKey, "')"));

    case 403:
      throw new Error("Unauthorized access to dataset: the provided apiKey('".concat(credentials.apiKey, "') doesn't provide access to the requested data"));

    default:
      const e = getMapsVersion() === 'v1' ? JSON.stringify(json.errors) : json.error;
      throw new Error(e);
  }
}

function buildURL({
  mapConfig,
  credentials
}) {
  const cfg = JSON.stringify(mapConfig);
  const encodedApiKey = encodeParameter('api_key', credentials.apiKey);
  const encodedClient = encodeParameter('client', "deck-gl-carto");
  const parameters = [encodedApiKey, encodedClient];
  return "".concat(mapsUrl(credentials), "/tilejson?").concat(parameters.join('&'), "&").concat(encodeParameter('config', cfg));
}

function mapsUrl(credentials) {
  return credentials.mapsUrl.replace(DEFAULT_USER_COMPONENT_IN_URL, credentials.username).replace(DEFAULT_REGION_COMPONENT_IN_URL, credentials.region);
}

function encodeParameter(name, value) {
  return "".concat(name, "=").concat(encodeURIComponent(value));
}
//# sourceMappingURL=maps-api-client.js.map