var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { IS_NODE, joinUrlParts } from '../util';
import { KeyError, HTTPError } from '../errors';
var HTTPMethod;
(function (HTTPMethod) {
    HTTPMethod["HEAD"] = "HEAD";
    HTTPMethod["GET"] = "GET";
    HTTPMethod["PUT"] = "PUT";
})(HTTPMethod || (HTTPMethod = {}));
const DEFAULT_METHODS = [HTTPMethod.HEAD, HTTPMethod.GET, HTTPMethod.PUT];
export class HTTPStore {
    constructor(url, options = {}) {
        this.url = url;
        const { fetchOptions = {}, supportedMethods = DEFAULT_METHODS } = options;
        this.fetchOptions = fetchOptions;
        this.supportedMethods = new Set(supportedMethods);
    }
    keys() {
        throw new Error('Method not implemented.');
    }
    getItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = joinUrlParts(this.url, item);
            const value = yield fetch(url, this.fetchOptions);
            if (value.status === 404) {
                // Item is not found
                throw new KeyError(item);
            }
            else if (value.status !== 200) {
                throw new HTTPError(String(value.status));
            }
            // only decode if 200
            if (IS_NODE) {
                return Buffer.from(yield value.arrayBuffer());
            }
            else {
                return value.arrayBuffer(); // Browser
            }
        });
    }
    setItem(item, value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.supportedMethods.has(HTTPMethod.PUT)) {
                throw new Error('HTTP PUT no a supported method for store.');
            }
            const url = joinUrlParts(this.url, item);
            if (typeof value === 'string') {
                value = new TextEncoder().encode(value).buffer;
            }
            const set = yield fetch(url, Object.assign(Object.assign({}, this.fetchOptions), { method: HTTPMethod.PUT, body: value }));
            return set.status.toString()[0] === '2';
        });
    }
    deleteItem(_item) {
        throw new Error('Method not implemented.');
    }
    containsItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = joinUrlParts(this.url, item);
            // Just check headers if HEAD method supported
            const method = this.supportedMethods.has(HTTPMethod.HEAD) ? HTTPMethod.HEAD : HTTPMethod.GET;
            const value = yield fetch(url, Object.assign(Object.assign({}, this.fetchOptions), { method }));
            return value.status === 200;
        });
    }
}
//# sourceMappingURL=httpStore.js.map