var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { normalizeStoragePath, normalizeChunks, normalizeDtype, normalizeShape, normalizeOrder, normalizeFillValue } from '../util';
import { ARRAY_META_KEY, GROUP_META_KEY } from '../names';
import { ContainsArrayError, ContainsGroupError } from '../errors';
/**
 * Return true if the store contains an array at the given logical path.
 */
export function containsArray(store, path = null) {
    return __awaiter(this, void 0, void 0, function* () {
        path = normalizeStoragePath(path);
        const prefix = pathToPrefix(path);
        const key = prefix + ARRAY_META_KEY;
        return store.containsItem(key);
    });
}
/**
 * Return true if the store contains a group at the given logical path.
 */
export function containsGroup(store, path = null) {
    return __awaiter(this, void 0, void 0, function* () {
        path = normalizeStoragePath(path);
        const prefix = pathToPrefix(path);
        const key = prefix + GROUP_META_KEY;
        return store.containsItem(key);
    });
}
export function pathToPrefix(path) {
    // assume path already normalized
    if (path.length > 0) {
        return path + '/';
    }
    return '';
}
function listDirFromKeys(store, path) {
    return __awaiter(this, void 0, void 0, function* () {
        // assume path already normalized
        const prefix = pathToPrefix(path);
        const children = new Set();
        for (const key in yield store.keys()) {
            if (key.startsWith(prefix) && key.length > prefix.length) {
                const suffix = key.slice(prefix.length);
                const child = suffix.split('/')[0];
                children.add(child);
            }
        }
        return Array.from(children).sort();
    });
}
function requireParentGroup(store, path, chunkStore, overwrite) {
    return __awaiter(this, void 0, void 0, function* () {
        // Assume path is normalized
        if (path.length === 0) {
            return;
        }
        const segments = path.split("/");
        let p = "";
        for (const s of segments.slice(0, segments.length - 1)) {
            p += s;
            if (yield containsArray(store, p)) {
                yield initGroupMetadata(store, p, overwrite);
            }
            else if (!(yield containsGroup(store, p))) {
                yield initGroupMetadata(store, p);
            }
            p += "/";
        }
    });
}
/**
 * Obtain a directory listing for the given path. If `store` provides a `listDir`
 *  method, this will be called, otherwise will fall back to implementation via the
 *  `MutableMapping` interface.
 * @param store
 */
export function listDir(store, path = null) {
    return __awaiter(this, void 0, void 0, function* () {
        path = normalizeStoragePath(path);
        if (store.listDir) {
            return store.listDir(path);
        }
        else {
            return listDirFromKeys(store, path);
        }
    });
}
function initGroupMetadata(store, path = null, overwrite = false) {
    return __awaiter(this, void 0, void 0, function* () {
        path = normalizeStoragePath(path);
        // Guard conditions
        if (overwrite) {
            throw Error("Group overwriting not implemented yet :(");
        }
        else if (yield containsArray(store, path)) {
            throw new ContainsArrayError(path);
        }
        else if (yield containsGroup(store, path)) {
            throw new ContainsGroupError(path);
        }
        const metadata = { zarr_format: 2 };
        const key = pathToPrefix(path) + GROUP_META_KEY;
        yield store.setItem(key, JSON.stringify(metadata));
    });
}
/**
 *  Initialize a group store. Note that this is a low-level function and there should be no
 *  need to call this directly from user code.
 */
export function initGroup(store, path = null, chunkStore = null, overwrite = false) {
    return __awaiter(this, void 0, void 0, function* () {
        path = normalizeStoragePath(path);
        yield requireParentGroup(store, path, chunkStore, overwrite);
        yield initGroupMetadata(store, path, overwrite);
    });
}
function initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters) {
    return __awaiter(this, void 0, void 0, function* () {
        // Guard conditions
        if (overwrite) {
            throw Error("Array overwriting not implemented yet :(");
        }
        else if (yield containsArray(store, path)) {
            throw new ContainsArrayError(path);
        }
        else if (yield containsGroup(store, path)) {
            throw new ContainsGroupError(path);
        }
        // Normalize metadata,  does type checking too.
        dtype = normalizeDtype(dtype);
        shape = normalizeShape(shape);
        chunks = normalizeChunks(chunks, shape);
        order = normalizeOrder(order);
        fillValue = normalizeFillValue(fillValue);
        if (filters !== null && filters.length > 0) {
            throw Error("Filters are not supported yet");
        }
        let serializedFillValue = fillValue;
        if (typeof fillValue === "number") {
            if (Number.isNaN(fillValue))
                serializedFillValue = "NaN";
            if (Number.POSITIVE_INFINITY === fillValue)
                serializedFillValue = "Infinity";
            if (Number.NEGATIVE_INFINITY === fillValue)
                serializedFillValue = "-Infinity";
        }
        filters = null;
        const metadata = {
            zarr_format: 2,
            shape: shape,
            chunks: chunks,
            dtype: dtype,
            fill_value: serializedFillValue,
            order: order,
            compressor: compressor,
            filters: filters,
        };
        const metaKey = pathToPrefix(path) + ARRAY_META_KEY;
        yield store.setItem(metaKey, JSON.stringify(metadata));
    });
}
/**
 *
 * Initialize an array store with the given configuration. Note that this is a low-level
 * function and there should be no need to call this directly from user code
 */
export function initArray(store, shape, chunks, dtype, path = null, compressor = null, fillValue = null, order = "C", overwrite = false, chunkStore = null, filters = null) {
    return __awaiter(this, void 0, void 0, function* () {
        path = normalizeStoragePath(path);
        yield requireParentGroup(store, path, chunkStore, overwrite);
        yield initArrayMetadata(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);
    });
}
//# sourceMappingURL=index.js.map