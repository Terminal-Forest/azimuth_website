var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createProxy } from './mutableMapping';
import { parseMetadata } from './metadata';
import { PermissionError } from './errors';
/**
 * Class providing access to user attributes on an array or group. Should not be
 * instantiated directly, will be available via the `.attrs` property of an array or
 * group.
 */
export class Attributes {
    constructor(store, key, readOnly, cache = true) {
        this.store = store;
        this.key = key;
        this.readOnly = readOnly;
        this.cache = cache;
        this.cachedValue = null;
    }
    /**
     * Retrieve all attributes as a JSON object.
     */
    asObject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cache && this.cachedValue !== null) {
                return this.cachedValue;
            }
            const o = yield this.getNoSync();
            if (this.cache) {
                this.cachedValue = o;
            }
            return o;
        });
    }
    getNoSync() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.store.getItem(this.key);
                // TODO fix typing?
                return parseMetadata(data);
            }
            catch (error) {
                return {};
            }
        });
    }
    setNoSync(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const d = yield this.getNoSync();
            d[key] = value;
            yield this.putNoSync(d);
            return true;
        });
    }
    putNoSync(m) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.store.setItem(this.key, JSON.stringify(m));
            if (this.cache) {
                this.cachedValue = m;
            }
        });
    }
    delNoSync(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const d = yield this.getNoSync();
            delete d[key];
            yield this.putNoSync(d);
            return true;
        });
    }
    /**
     * Overwrite all attributes with the provided object in a single operation
     */
    put(d) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.readOnly) {
                throw new PermissionError("attributes are read-only");
            }
            return this.putNoSync(d);
        });
    }
    setItem(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.readOnly) {
                throw new PermissionError("attributes are read-only");
            }
            return this.setNoSync(key, value);
        });
    }
    getItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.asObject())[key];
        });
    }
    deleteItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.readOnly) {
                throw new PermissionError("attributes are read-only");
            }
            return this.delNoSync(key);
        });
    }
    containsItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.asObject())[key] !== undefined;
        });
    }
    proxy() {
        return createProxy(this);
    }
}
//# sourceMappingURL=attributes.js.map