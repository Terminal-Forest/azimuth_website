var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ZarrArray } from './core/index';
import { MemoryStore } from './storage/memoryStore';
import { initArray, containsArray, containsGroup } from './storage/index';
import { NestedArray } from './nestedArray/index';
import { normalizeStoragePath } from './util';
import { ContainsArrayError, ValueError, ArrayNotFoundError, ContainsGroupError } from './errors';
import { HTTPStore } from './storage/httpStore';
/**
 *
 * @param shape Array shape.
 * @param chunks  Chunk shape. If `true`, will be guessed from `shape` and `dtype`. If
 *      `false`, will be set to `shape`, i.e., single chunk for the whole array.
 *      If an int, the chunk size in each dimension will be given by the value
 *      of `chunks`. Default is `true`.
 * @param dtype NumPy dtype.
 * @param compressor Primary compressor.
 * @param fillValue Default value to use for uninitialized portions of the array.
 * @param order Memory layout to be used within each chunk.
 * @param store Store or path to directory in file system or name of zip file.
 * @param overwrite  If True, delete all pre-existing data in `store` at `path` before creating the array.
 * @param path Path under which array is stored.
 * @param chunkStore Separate storage for chunks. If not provided, `store` will be used for storage of both chunks and metadata.
 * @param filters Sequence of filters to use to encode chunk data prior to compression.
 * @param cacheMetadata If `true` (default), array configuration metadata will be cached for the
 *      lifetime of the object. If `false`, array metadata will be reloaded
 *      prior to all data access and modification operations (may incur
 *      overhead depending on storage and data access pattern).
 * @param cacheAttrs If `true` (default), user attributes will be cached for attribute read
 *      operations. If `false`, user attributes are reloaded from the store prior
 *      to all attribute read operations.
 * @param readOnly `true` if array should be protected against modification, defaults to `false`.
 */
export function create({ shape, chunks = true, dtype = "<i4", compressor = null, fillValue = null, order = "C", store, overwrite = false, path, chunkStore, filters, cacheMetadata = true, cacheAttrs = true, readOnly = false }) {
    return __awaiter(this, void 0, void 0, function* () {
        store = normalizeStoreArgument(store);
        yield initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);
        const z = yield ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);
        return z;
    });
}
/**
 * Create an empty array.
 */
export function empty(shape, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        opts.fillValue = null;
        return create(Object.assign({ shape }, opts));
    });
}
/**
 * Create an array, with zero being used as the default value for
 * uninitialized portions of the array.
 */
export function zeros(shape, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        opts.fillValue = 0;
        return create(Object.assign({ shape }, opts));
    });
}
/**
 * Create an array, with one being used as the default value for
 * uninitialized portions of the array.
 */
export function ones(shape, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        opts.fillValue = 1;
        return create(Object.assign({ shape }, opts));
    });
}
/**
 * Create an array, with `fill_value` being used as the default value for
 * uninitialized portions of the array
 */
export function full(shape, fillValue, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        opts.fillValue = fillValue;
        return create(Object.assign({ shape }, opts));
    });
}
export function array(data, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        // TODO: infer chunks?
        let shape = null;
        if (data instanceof NestedArray) {
            shape = data.shape;
            opts.dtype = opts.dtype === undefined ? data.dtype : opts.dtype;
        }
        else {
            shape = data.byteLength;
            // TODO: infer datatype
        }
        // TODO: support TypedArray
        const wasReadOnly = opts.readOnly === undefined ? false : opts.readOnly;
        opts.readOnly = false;
        const z = yield create(Object.assign({ shape }, opts));
        yield z.set(null, data);
        z.readOnly = wasReadOnly;
        return z;
    });
}
export function openArray({ shape, mode = "a", chunks = true, dtype = "<i4", compressor = null, fillValue = null, order = "C", store, overwrite = false, path = null, chunkStore, filters, cacheMetadata = true, cacheAttrs = true } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        store = normalizeStoreArgument(store);
        if (chunkStore === undefined) {
            chunkStore = normalizeStoreArgument(store);
        }
        path = normalizeStoragePath(path);
        if (mode === "r" || mode === "r+") {
            if (yield containsGroup(store, path)) {
                throw new ContainsGroupError(path);
            }
            else if (!(yield containsArray(store, path))) {
                throw new ArrayNotFoundError(path);
            }
        }
        else if (mode === "w") {
            if (shape === undefined) {
                throw new ValueError("Shape can not be undefined when creating a new array");
            }
            yield initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);
        }
        else if (mode === "a") {
            if (yield containsGroup(store, path)) {
                throw new ContainsGroupError(path);
            }
            else if (!(yield containsArray(store, path))) {
                if (shape === undefined) {
                    throw new ValueError("Shape can not be undefined when creating a new array");
                }
                yield initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);
            }
        }
        else if (mode === "w-" || mode === "x") {
            if (yield containsArray(store, path)) {
                throw new ContainsArrayError(path);
            }
            else if (yield containsGroup(store, path)) {
                throw new ContainsGroupError(path);
            }
            else {
                if (shape === undefined) {
                    throw new ValueError("Shape can not be undefined when creating a new array");
                }
                yield initArray(store, shape, chunks, dtype, path, compressor, fillValue, order, overwrite, chunkStore, filters);
            }
        }
        else {
            throw new ValueError(`Invalid mode argument: ${mode}`);
        }
        const readOnly = mode === "r";
        return ZarrArray.create(store, path, readOnly, chunkStore, cacheMetadata, cacheAttrs);
    });
}
export function normalizeStoreArgument(store) {
    if (store === undefined) {
        return new MemoryStore();
    }
    else if (typeof store === "string") {
        return new HTTPStore(store);
    }
    return store;
}
//# sourceMappingURL=creation.js.map