import { Layer, project32, picking, COORDINATE_SYSTEM, CompositeLayer, OrthographicView, Controller } from '@deck.gl/core';
import { Model, Geometry, isWebGL2, Texture2D } from '@luma.gl/core';
import { Matrix4 } from 'math.gl';
import GL from '@luma.gl/constants';
import { TileLayer } from '@deck.gl/geo-layers';
import { BitmapLayer as BitmapLayer$1, PolygonLayer, LineLayer, TextLayer } from '@deck.gl/layers';
import React, { PureComponent, useState, useMemo } from 'react';
import DeckGL from '@deck.gl/react';
import equal from 'fast-deep-equal';
import { KeyError, HTTPError, BoundsCheckError, openArray } from 'zarr';
import { fromBlob, fromUrl } from 'geotiff';
import quickselect from 'quickselect';
import parser from 'fast-xml-parser';

var fsColormap1 = "#define SHADER_NAME xr-layer-fragment-shader-colormap\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D channel0;uniform sampler2D channel1;uniform sampler2D channel2;uniform sampler2D channel3;uniform sampler2D channel4;uniform sampler2D channel5;uniform vec2 sliderValues[6];uniform float opacity;uniform float divisor;uniform bool useTransparentColor;varying vec2 vTexCoord;void main(){float intensityValue0=sample_and_apply_sliders(channel0,vTexCoord,sliderValues[0]);float intensityValue1=sample_and_apply_sliders(channel1,vTexCoord,sliderValues[1]);float intensityValue2=sample_and_apply_sliders(channel2,vTexCoord,sliderValues[2]);float intensityValue3=sample_and_apply_sliders(channel3,vTexCoord,sliderValues[3]);float intensityValue4=sample_and_apply_sliders(channel4,vTexCoord,sliderValues[4]);float intensityValue5=sample_and_apply_sliders(channel5,vTexCoord,sliderValues[5]);float intensityCombo=0.0;intensityCombo+=max(0.0,intensityValue0);intensityCombo+=max(0.0,intensityValue1);intensityCombo+=max(0.0,intensityValue2);intensityCombo+=max(0.0,intensityValue3);intensityCombo+=max(0.0,intensityValue4);intensityCombo+=max(0.0,intensityValue5);gl_FragColor=colormap(intensityCombo,opacity,useTransparentColor);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(gl_FragColor,geometry);}"; // eslint-disable-line

var fsColormap2 = "#version 300 es\n#define SHADER_NAME xr-layer-fragment-shader\nprecision highp float;precision highp int;precision highp SAMPLER_TYPE;\n#define GLSLIFY 1\nuniform SAMPLER_TYPE channel0;uniform SAMPLER_TYPE channel1;uniform SAMPLER_TYPE channel2;uniform SAMPLER_TYPE channel3;uniform SAMPLER_TYPE channel4;uniform SAMPLER_TYPE channel5;uniform vec2 sliderValues[6];uniform float opacity;uniform bool useTransparentColor;in vec2 vTexCoord;out vec4 color;void main(){float intensityValue0=sample_and_apply_sliders(channel0,vTexCoord,sliderValues[0]);float intensityValue1=sample_and_apply_sliders(channel1,vTexCoord,sliderValues[1]);float intensityValue2=sample_and_apply_sliders(channel2,vTexCoord,sliderValues[2]);float intensityValue3=sample_and_apply_sliders(channel3,vTexCoord,sliderValues[3]);float intensityValue4=sample_and_apply_sliders(channel4,vTexCoord,sliderValues[4]);float intensityValue5=sample_and_apply_sliders(channel5,vTexCoord,sliderValues[5]);float intensityArray[6]=float[6](intensityValue0,intensityValue1,intensityValue2,intensityValue3,intensityValue4,intensityValue5);float intensityCombo=0.0;for(int i=0;i<6;i++){intensityCombo+=max(0.0,intensityArray[i]);}color=colormap(intensityCombo,opacity,useTransparentColor);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(color,geometry);}"; // eslint-disable-line

var fs1 = "#define SHADER_NAME xr-layer-fragment-shader\nprecision highp float;\n#define GLSLIFY 1\nuniform sampler2D channel0;uniform sampler2D channel1;uniform sampler2D channel2;uniform sampler2D channel3;uniform sampler2D channel4;uniform sampler2D channel5;uniform vec2 sliderValues[6];uniform vec3 colorValues[6];uniform float intensityArray[6];uniform float opacity;uniform float majorLensAxis;uniform float minorLensAxis;uniform vec2 lensCenter;uniform bool isLensOn;uniform int lensSelection;uniform vec3 lensBorderColor;uniform float lensBorderRadius;uniform vec3 transparentColor;uniform bool useTransparentColor;varying vec2 vTexCoord;void main(){float intensityValue0=sample_and_apply_sliders(channel0,vTexCoord,sliderValues[0]);float intensityValue1=sample_and_apply_sliders(channel1,vTexCoord,sliderValues[1]);float intensityValue2=sample_and_apply_sliders(channel2,vTexCoord,sliderValues[2]);float intensityValue3=sample_and_apply_sliders(channel3,vTexCoord,sliderValues[3]);float intensityValue4=sample_and_apply_sliders(channel4,vTexCoord,sliderValues[4]);float intensityValue5=sample_and_apply_sliders(channel5,vTexCoord,sliderValues[5]);bool isFragInLensBounds=frag_in_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool isFragOnLensBounds=frag_on_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool inLensAndUseLens=isLensOn&&isFragInLensBounds;vec3 rgbCombo=process_channel_intensity(intensityValue0,colorValues[0],0,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue1,colorValues[1],1,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue2,colorValues[2],2,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue3,colorValues[3],3,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue4,colorValues[4],4,inLensAndUseLens,lensSelection);rgbCombo+=process_channel_intensity(intensityValue5,colorValues[5],5,inLensAndUseLens,lensSelection);rgbCombo=(isLensOn&&isFragOnLensBounds)? lensBorderColor : rgbCombo;gl_FragColor=apply_opacity(rgbCombo,useTransparentColor,transparentColor,opacity);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(gl_FragColor,geometry);}"; // eslint-disable-line

var fs2 = "#version 300 es\n#define SHADER_NAME xr-layer-fragment-shader\nprecision highp float;precision highp int;precision highp SAMPLER_TYPE;\n#define GLSLIFY 1\nuniform SAMPLER_TYPE channel0;uniform SAMPLER_TYPE channel1;uniform SAMPLER_TYPE channel2;uniform SAMPLER_TYPE channel3;uniform SAMPLER_TYPE channel4;uniform SAMPLER_TYPE channel5;uniform vec2 sliderValues[6];uniform vec3 colorValues[6];uniform float opacity;uniform float majorLensAxis;uniform float minorLensAxis;uniform vec2 lensCenter;uniform bool isLensOn;uniform int lensSelection;uniform vec3 lensBorderColor;uniform float lensBorderRadius;uniform vec3 transparentColor;uniform bool useTransparentColor;in vec2 vTexCoord;out vec4 color;void main(){float intensityValue0=sample_and_apply_sliders(channel0,vTexCoord,sliderValues[0]);float intensityValue1=sample_and_apply_sliders(channel1,vTexCoord,sliderValues[1]);float intensityValue2=sample_and_apply_sliders(channel2,vTexCoord,sliderValues[2]);float intensityValue3=sample_and_apply_sliders(channel3,vTexCoord,sliderValues[3]);float intensityValue4=sample_and_apply_sliders(channel4,vTexCoord,sliderValues[4]);float intensityValue5=sample_and_apply_sliders(channel5,vTexCoord,sliderValues[5]);float intensityArray[6]=float[6](intensityValue0,intensityValue1,intensityValue2,intensityValue3,intensityValue4,intensityValue5);bool isFragInLensBounds=frag_in_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool isFragOnLensBounds=frag_on_lens_bounds(lensCenter,vTexCoord,majorLensAxis,minorLensAxis,lensBorderRadius);bool inLensAndUseLens=isLensOn&&isFragInLensBounds;vec3 rgbCombo=vec3(0.0);for(int i=0;i<6;i++){rgbCombo+=process_channel_intensity(intensityArray[i],colorValues[i],i,inLensAndUseLens,lensSelection);}rgbCombo=(isLensOn&&isFragOnLensBounds)? lensBorderColor : rgbCombo;color=apply_opacity(rgbCombo,useTransparentColor,transparentColor,opacity);geometry.uv=vTexCoord;DECKGL_FILTER_COLOR(color,geometry);}"; // eslint-disable-line

var vs1 = "#define GLSLIFY 1\n#define SHADER_NAME xr-layer-vertex-shader\nattribute vec2 texCoords;attribute vec3 positions;attribute vec3 positions64Low;attribute vec3 instancePickingColors;varying vec2 vTexCoord;void main(void){geometry.worldPosition=positions;geometry.uv=texCoords;geometry.pickingColor=instancePickingColors;gl_Position=project_position_to_clipspace(positions,positions64Low,vec3(0.0),geometry.position);DECKGL_FILTER_GL_POSITION(gl_Position,geometry);vTexCoord=texCoords;vec4 color=vec4(0.0);DECKGL_FILTER_COLOR(color,geometry);}"; // eslint-disable-line

var vs2 = "#version 300 es\n#define GLSLIFY 1\n#define SHADER_NAME xr-layer-vertex-shader\nin vec2 texCoords;in vec3 positions;in vec3 positions64Low;in vec3 instancePickingColors;out vec2 vTexCoord;void main(void){geometry.worldPosition=positions;geometry.uv=texCoords;geometry.pickingColor=instancePickingColors;gl_Position=project_position_to_clipspace(positions,positions64Low,vec3(0.0),geometry.position);DECKGL_FILTER_GL_POSITION(gl_Position,geometry);vTexCoord=texCoords;vec4 color=vec4(0.0);DECKGL_FILTER_COLOR(color,geometry);}"; // eslint-disable-line

var fs = "#define GLSLIFY 1\nvec4 jet(float x_17){const float e0=0.0;const vec4 v0=vec4(0,0,0.5137254901960784,1);const float e1=0.125;const vec4 v1=vec4(0,0.23529411764705882,0.6666666666666666,1);const float e2=0.375;const vec4 v2=vec4(0.0196078431372549,1,1,1);const float e3=0.625;const vec4 v3=vec4(1,1,0,1);const float e4=0.875;const vec4 v4=vec4(0.9803921568627451,0,0,1);const float e5=1.0;const vec4 v5=vec4(0.5019607843137255,0,0,1);float a0=smoothstep(e0,e1,x_17);float a1=smoothstep(e1,e2,x_17);float a2=smoothstep(e2,e3,x_17);float a3=smoothstep(e3,e4,x_17);float a4=smoothstep(e4,e5,x_17);return max(mix(v0,v1,a0)*step(e0,x_17)*step(x_17,e1),max(mix(v1,v2,a1)*step(e1,x_17)*step(x_17,e2),max(mix(v2,v3,a2)*step(e2,x_17)*step(x_17,e3),max(mix(v3,v4,a3)*step(e3,x_17)*step(x_17,e4),mix(v4,v5,a4)*step(e4,x_17)*step(x_17,e5)))));}vec4 hsv_0(float x_18){const float e0=0.0;const vec4 v0=vec4(1,0,0,1);const float e1=0.169;const vec4 v1=vec4(0.9921568627450981,1,0.00784313725490196,1);const float e2=0.173;const vec4 v2=vec4(0.9686274509803922,1,0.00784313725490196,1);const float e3=0.337;const vec4 v3=vec4(0,0.9882352941176471,0.01568627450980392,1);const float e4=0.341;const vec4 v4=vec4(0,0.9882352941176471,0.0392156862745098,1);const float e5=0.506;const vec4 v5=vec4(0.00392156862745098,0.9764705882352941,1,1);const float e6=0.671;const vec4 v6=vec4(0.00784313725490196,0,0.9921568627450981,1);const float e7=0.675;const vec4 v7=vec4(0.03137254901960784,0,0.9921568627450981,1);const float e8=0.839;const vec4 v8=vec4(1,0,0.984313725490196,1);const float e9=0.843;const vec4 v9=vec4(1,0,0.9607843137254902,1);const float e10=1.0;const vec4 v10=vec4(1,0,0.023529411764705882,1);float a0=smoothstep(e0,e1,x_18);float a1=smoothstep(e1,e2,x_18);float a2=smoothstep(e2,e3,x_18);float a3=smoothstep(e3,e4,x_18);float a4=smoothstep(e4,e5,x_18);float a5=smoothstep(e5,e6,x_18);float a6=smoothstep(e6,e7,x_18);float a7=smoothstep(e7,e8,x_18);float a8=smoothstep(e8,e9,x_18);float a9=smoothstep(e9,e10,x_18);return max(mix(v0,v1,a0)*step(e0,x_18)*step(x_18,e1),max(mix(v1,v2,a1)*step(e1,x_18)*step(x_18,e2),max(mix(v2,v3,a2)*step(e2,x_18)*step(x_18,e3),max(mix(v3,v4,a3)*step(e3,x_18)*step(x_18,e4),max(mix(v4,v5,a4)*step(e4,x_18)*step(x_18,e5),max(mix(v5,v6,a5)*step(e5,x_18)*step(x_18,e6),max(mix(v6,v7,a6)*step(e6,x_18)*step(x_18,e7),max(mix(v7,v8,a7)*step(e7,x_18)*step(x_18,e8),max(mix(v8,v9,a8)*step(e8,x_18)*step(x_18,e9),mix(v9,v10,a9)*step(e9,x_18)*step(x_18,e10))))))))));}vec4 hot(float x_13){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.3;const vec4 v1=vec4(0.9019607843137255,0,0,1);const float e2=0.6;const vec4 v2=vec4(1,0.8235294117647058,0,1);const float e3=1.0;const vec4 v3=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_13);float a1=smoothstep(e1,e2,x_13);float a2=smoothstep(e2,e3,x_13);return max(mix(v0,v1,a0)*step(e0,x_13)*step(x_13,e1),max(mix(v1,v2,a1)*step(e1,x_13)*step(x_13,e2),mix(v2,v3,a2)*step(e2,x_13)*step(x_13,e3)));}vec4 cool(float x_24){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.13;const vec4 v1=vec4(0.4549019607843137,0,0.8549019607843137,1);const float e2=0.25;const vec4 v2=vec4(0.3843137254901961,0.2901960784313726,0.9294117647058824,1);const float e3=0.38;const vec4 v3=vec4(0.26666666666666666,0.5725490196078431,0.9058823529411765,1);const float e4=0.5;const vec4 v4=vec4(0,0.8,0.7725490196078432,1);const float e5=0.63;const vec4 v5=vec4(0,0.9686274509803922,0.5725490196078431,1);const float e6=0.75;const vec4 v6=vec4(0,1,0.34509803921568627,1);const float e7=0.88;const vec4 v7=vec4(0.1568627450980392,1,0.03137254901960784,1);const float e8=1.0;const vec4 v8=vec4(0.5764705882352941,1,0,1);float a0=smoothstep(e0,e1,x_24);float a1=smoothstep(e1,e2,x_24);float a2=smoothstep(e2,e3,x_24);float a3=smoothstep(e3,e4,x_24);float a4=smoothstep(e4,e5,x_24);float a5=smoothstep(e5,e6,x_24);float a6=smoothstep(e6,e7,x_24);float a7=smoothstep(e7,e8,x_24);return max(mix(v0,v1,a0)*step(e0,x_24)*step(x_24,e1),max(mix(v1,v2,a1)*step(e1,x_24)*step(x_24,e2),max(mix(v2,v3,a2)*step(e2,x_24)*step(x_24,e3),max(mix(v3,v4,a3)*step(e3,x_24)*step(x_24,e4),max(mix(v4,v5,a4)*step(e4,x_24)*step(x_24,e5),max(mix(v5,v6,a5)*step(e5,x_24)*step(x_24,e6),max(mix(v6,v7,a6)*step(e6,x_24)*step(x_24,e7),mix(v7,v8,a7)*step(e7,x_24)*step(x_24,e8))))))));}vec4 spring(float x_5){const float e0=0.0;const vec4 v0=vec4(1,0,1,1);const float e1=1.0;const vec4 v1=vec4(1,1,0,1);float a0=smoothstep(e0,e1,x_5);return mix(v0,v1,a0)*step(e0,x_5)*step(x_5,e1);}vec4 summer(float x_12){const float e0=0.0;const vec4 v0=vec4(0,0.5019607843137255,0.4,1);const float e1=1.0;const vec4 v1=vec4(1,1,0.4,1);float a0=smoothstep(e0,e1,x_12);return mix(v0,v1,a0)*step(e0,x_12)*step(x_12,e1);}vec4 autumn(float x_25){const float e0=0.0;const vec4 v0=vec4(1,0,0,1);const float e1=1.0;const vec4 v1=vec4(1,1,0,1);float a0=smoothstep(e0,e1,x_25);return mix(v0,v1,a0)*step(e0,x_25)*step(x_25,e1);}vec4 winter(float x_16){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=1.0;const vec4 v1=vec4(0,1,0.5019607843137255,1);float a0=smoothstep(e0,e1,x_16);return mix(v0,v1,a0)*step(e0,x_16)*step(x_16,e1);}vec4 bone(float x_15){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.376;const vec4 v1=vec4(0.32941176470588235,0.32941176470588235,0.4549019607843137,1);const float e2=0.753;const vec4 v2=vec4(0.6627450980392157,0.7843137254901961,0.7843137254901961,1);const float e3=1.0;const vec4 v3=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_15);float a1=smoothstep(e1,e2,x_15);float a2=smoothstep(e2,e3,x_15);return max(mix(v0,v1,a0)*step(e0,x_15)*step(x_15,e1),max(mix(v1,v2,a1)*step(e1,x_15)*step(x_15,e2),mix(v2,v3,a2)*step(e2,x_15)*step(x_15,e3)));}vec4 copper(float x_10){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.804;const vec4 v1=vec4(1,0.6274509803921569,0.4,1);const float e2=1.0;const vec4 v2=vec4(1,0.7803921568627451,0.4980392156862745,1);float a0=smoothstep(e0,e1,x_10);float a1=smoothstep(e1,e2,x_10);return max(mix(v0,v1,a0)*step(e0,x_10)*step(x_10,e1),mix(v1,v2,a1)*step(e1,x_10)*step(x_10,e2));}vec4 greys(float x_4){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=1.0;const vec4 v1=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_4);return mix(v0,v1,a0)*step(e0,x_4)*step(x_4,e1);}vec4 yignbu(float x_32){const float e0=0.0;const vec4 v0=vec4(0.03137254901960784,0.11372549019607843,0.34509803921568627,1);const float e1=0.125;const vec4 v1=vec4(0.1450980392156863,0.20392156862745098,0.5803921568627451,1);const float e2=0.25;const vec4 v2=vec4(0.13333333333333333,0.3686274509803922,0.6588235294117647,1);const float e3=0.375;const vec4 v3=vec4(0.11372549019607843,0.5686274509803921,0.7529411764705882,1);const float e4=0.5;const vec4 v4=vec4(0.2549019607843137,0.7137254901960784,0.7686274509803922,1);const float e5=0.625;const vec4 v5=vec4(0.4980392156862745,0.803921568627451,0.7333333333333333,1);const float e6=0.75;const vec4 v6=vec4(0.7803921568627451,0.9137254901960784,0.7058823529411765,1);const float e7=0.875;const vec4 v7=vec4(0.9294117647058824,0.9725490196078431,0.8509803921568627,1);const float e8=1.0;const vec4 v8=vec4(1,1,0.8509803921568627,1);float a0=smoothstep(e0,e1,x_32);float a1=smoothstep(e1,e2,x_32);float a2=smoothstep(e2,e3,x_32);float a3=smoothstep(e3,e4,x_32);float a4=smoothstep(e4,e5,x_32);float a5=smoothstep(e5,e6,x_32);float a6=smoothstep(e6,e7,x_32);float a7=smoothstep(e7,e8,x_32);return max(mix(v0,v1,a0)*step(e0,x_32)*step(x_32,e1),max(mix(v1,v2,a1)*step(e1,x_32)*step(x_32,e2),max(mix(v2,v3,a2)*step(e2,x_32)*step(x_32,e3),max(mix(v3,v4,a3)*step(e3,x_32)*step(x_32,e4),max(mix(v4,v5,a4)*step(e4,x_32)*step(x_32,e5),max(mix(v5,v6,a5)*step(e5,x_32)*step(x_32,e6),max(mix(v6,v7,a6)*step(e6,x_32)*step(x_32,e7),mix(v7,v8,a7)*step(e7,x_32)*step(x_32,e8))))))));}vec4 greens(float x_34){const float e0=0.0;const vec4 v0=vec4(0,0.26666666666666666,0.10588235294117647,1);const float e1=0.125;const vec4 v1=vec4(0,0.42745098039215684,0.17254901960784313,1);const float e2=0.25;const vec4 v2=vec4(0.13725490196078433,0.5450980392156862,0.27058823529411763,1);const float e3=0.375;const vec4 v3=vec4(0.2549019607843137,0.6705882352941176,0.36470588235294116,1);const float e4=0.5;const vec4 v4=vec4(0.4549019607843137,0.7686274509803922,0.4627450980392157,1);const float e5=0.625;const vec4 v5=vec4(0.6313725490196078,0.8509803921568627,0.6078431372549019,1);const float e6=0.75;const vec4 v6=vec4(0.7803921568627451,0.9137254901960784,0.7529411764705882,1);const float e7=0.875;const vec4 v7=vec4(0.8980392156862745,0.9607843137254902,0.8784313725490196,1);const float e8=1.0;const vec4 v8=vec4(0.9686274509803922,0.9882352941176471,0.9607843137254902,1);float a0=smoothstep(e0,e1,x_34);float a1=smoothstep(e1,e2,x_34);float a2=smoothstep(e2,e3,x_34);float a3=smoothstep(e3,e4,x_34);float a4=smoothstep(e4,e5,x_34);float a5=smoothstep(e5,e6,x_34);float a6=smoothstep(e6,e7,x_34);float a7=smoothstep(e7,e8,x_34);return max(mix(v0,v1,a0)*step(e0,x_34)*step(x_34,e1),max(mix(v1,v2,a1)*step(e1,x_34)*step(x_34,e2),max(mix(v2,v3,a2)*step(e2,x_34)*step(x_34,e3),max(mix(v3,v4,a3)*step(e3,x_34)*step(x_34,e4),max(mix(v4,v5,a4)*step(e4,x_34)*step(x_34,e5),max(mix(v5,v6,a5)*step(e5,x_34)*step(x_34,e6),max(mix(v6,v7,a6)*step(e6,x_34)*step(x_34,e7),mix(v7,v8,a7)*step(e7,x_34)*step(x_34,e8))))))));}vec4 yiorrd(float x_41){const float e0=0.0;const vec4 v0=vec4(0.5019607843137255,0,0.14901960784313725,1);const float e1=0.125;const vec4 v1=vec4(0.7411764705882353,0,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.8901960784313725,0.10196078431372549,0.10980392156862745,1);const float e3=0.375;const vec4 v3=vec4(0.9882352941176471,0.3058823529411765,0.16470588235294117,1);const float e4=0.5;const vec4 v4=vec4(0.9921568627450981,0.5529411764705883,0.23529411764705882,1);const float e5=0.625;const vec4 v5=vec4(0.996078431372549,0.6980392156862745,0.2980392156862745,1);const float e6=0.75;const vec4 v6=vec4(0.996078431372549,0.8509803921568627,0.4627450980392157,1);const float e7=0.875;const vec4 v7=vec4(1,0.9294117647058824,0.6274509803921569,1);const float e8=1.0;const vec4 v8=vec4(1,1,0.8,1);float a0=smoothstep(e0,e1,x_41);float a1=smoothstep(e1,e2,x_41);float a2=smoothstep(e2,e3,x_41);float a3=smoothstep(e3,e4,x_41);float a4=smoothstep(e4,e5,x_41);float a5=smoothstep(e5,e6,x_41);float a6=smoothstep(e6,e7,x_41);float a7=smoothstep(e7,e8,x_41);return max(mix(v0,v1,a0)*step(e0,x_41)*step(x_41,e1),max(mix(v1,v2,a1)*step(e1,x_41)*step(x_41,e2),max(mix(v2,v3,a2)*step(e2,x_41)*step(x_41,e3),max(mix(v3,v4,a3)*step(e3,x_41)*step(x_41,e4),max(mix(v4,v5,a4)*step(e4,x_41)*step(x_41,e5),max(mix(v5,v6,a5)*step(e5,x_41)*step(x_41,e6),max(mix(v6,v7,a6)*step(e6,x_41)*step(x_41,e7),mix(v7,v8,a7)*step(e7,x_41)*step(x_41,e8))))))));}vec4 bluered(float x_23){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=1.0;const vec4 v1=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_23);return mix(v0,v1,a0)*step(e0,x_23)*step(x_23,e1);}vec4 rdbu(float x_1){const float e0=0.0;const vec4 v0=vec4(0.0196078431372549,0.0392156862745098,0.6745098039215687,1);const float e1=0.35;const vec4 v1=vec4(0.41568627450980394,0.5372549019607843,0.9686274509803922,1);const float e2=0.5;const vec4 v2=vec4(0.7450980392156863,0.7450980392156863,0.7450980392156863,1);const float e3=0.6;const vec4 v3=vec4(0.8627450980392157,0.6666666666666666,0.5176470588235295,1);const float e4=0.7;const vec4 v4=vec4(0.9019607843137255,0.5686274509803921,0.35294117647058826,1);const float e5=1.0;const vec4 v5=vec4(0.6980392156862745,0.0392156862745098,0.10980392156862745,1);float a0=smoothstep(e0,e1,x_1);float a1=smoothstep(e1,e2,x_1);float a2=smoothstep(e2,e3,x_1);float a3=smoothstep(e3,e4,x_1);float a4=smoothstep(e4,e5,x_1);return max(mix(v0,v1,a0)*step(e0,x_1)*step(x_1,e1),max(mix(v1,v2,a1)*step(e1,x_1)*step(x_1,e2),max(mix(v2,v3,a2)*step(e2,x_1)*step(x_1,e3),max(mix(v3,v4,a3)*step(e3,x_1)*step(x_1,e4),mix(v4,v5,a4)*step(e4,x_1)*step(x_1,e5)))));}vec4 picnic(float x_42){const float e0=0.0;const vec4 v0=vec4(0,0,1,1);const float e1=0.1;const vec4 v1=vec4(0.2,0.6,1,1);const float e2=0.2;const vec4 v2=vec4(0.4,0.8,1,1);const float e3=0.3;const vec4 v3=vec4(0.6,0.8,1,1);const float e4=0.4;const vec4 v4=vec4(0.8,0.8,1,1);const float e5=0.5;const vec4 v5=vec4(1,1,1,1);const float e6=0.6;const vec4 v6=vec4(1,0.8,1,1);const float e7=0.7;const vec4 v7=vec4(1,0.6,1,1);const float e8=0.8;const vec4 v8=vec4(1,0.4,0.8,1);const float e9=0.9;const vec4 v9=vec4(1,0.4,0.4,1);const float e10=1.0;const vec4 v10=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_42);float a1=smoothstep(e1,e2,x_42);float a2=smoothstep(e2,e3,x_42);float a3=smoothstep(e3,e4,x_42);float a4=smoothstep(e4,e5,x_42);float a5=smoothstep(e5,e6,x_42);float a6=smoothstep(e6,e7,x_42);float a7=smoothstep(e7,e8,x_42);float a8=smoothstep(e8,e9,x_42);float a9=smoothstep(e9,e10,x_42);return max(mix(v0,v1,a0)*step(e0,x_42)*step(x_42,e1),max(mix(v1,v2,a1)*step(e1,x_42)*step(x_42,e2),max(mix(v2,v3,a2)*step(e2,x_42)*step(x_42,e3),max(mix(v3,v4,a3)*step(e3,x_42)*step(x_42,e4),max(mix(v4,v5,a4)*step(e4,x_42)*step(x_42,e5),max(mix(v5,v6,a5)*step(e5,x_42)*step(x_42,e6),max(mix(v6,v7,a6)*step(e6,x_42)*step(x_42,e7),max(mix(v7,v8,a7)*step(e7,x_42)*step(x_42,e8),max(mix(v8,v9,a8)*step(e8,x_42)*step(x_42,e9),mix(v9,v10,a9)*step(e9,x_42)*step(x_42,e10))))))))));}vec4 rainbow(float x_31){const float e0=0.0;const vec4 v0=vec4(0.5882352941176471,0,0.35294117647058826,1);const float e1=0.125;const vec4 v1=vec4(0,0,0.7843137254901961,1);const float e2=0.25;const vec4 v2=vec4(0,0.09803921568627451,1,1);const float e3=0.375;const vec4 v3=vec4(0,0.596078431372549,1,1);const float e4=0.5;const vec4 v4=vec4(0.17254901960784313,1,0.5882352941176471,1);const float e5=0.625;const vec4 v5=vec4(0.592156862745098,1,0,1);const float e6=0.75;const vec4 v6=vec4(1,0.9176470588235294,0,1);const float e7=0.875;const vec4 v7=vec4(1,0.43529411764705883,0,1);const float e8=1.0;const vec4 v8=vec4(1,0,0,1);float a0=smoothstep(e0,e1,x_31);float a1=smoothstep(e1,e2,x_31);float a2=smoothstep(e2,e3,x_31);float a3=smoothstep(e3,e4,x_31);float a4=smoothstep(e4,e5,x_31);float a5=smoothstep(e5,e6,x_31);float a6=smoothstep(e6,e7,x_31);float a7=smoothstep(e7,e8,x_31);return max(mix(v0,v1,a0)*step(e0,x_31)*step(x_31,e1),max(mix(v1,v2,a1)*step(e1,x_31)*step(x_31,e2),max(mix(v2,v3,a2)*step(e2,x_31)*step(x_31,e3),max(mix(v3,v4,a3)*step(e3,x_31)*step(x_31,e4),max(mix(v4,v5,a4)*step(e4,x_31)*step(x_31,e5),max(mix(v5,v6,a5)*step(e5,x_31)*step(x_31,e6),max(mix(v6,v7,a6)*step(e6,x_31)*step(x_31,e7),mix(v7,v8,a7)*step(e7,x_31)*step(x_31,e8))))))));}vec4 portland(float x_21){const float e0=0.0;const vec4 v0=vec4(0.047058823529411764,0.2,0.5137254901960784,1);const float e1=0.25;const vec4 v1=vec4(0.0392156862745098,0.5333333333333333,0.7294117647058823,1);const float e2=0.5;const vec4 v2=vec4(0.9490196078431372,0.8274509803921568,0.2196078431372549,1);const float e3=0.75;const vec4 v3=vec4(0.9490196078431372,0.5607843137254902,0.2196078431372549,1);const float e4=1.0;const vec4 v4=vec4(0.8509803921568627,0.11764705882352941,0.11764705882352941,1);float a0=smoothstep(e0,e1,x_21);float a1=smoothstep(e1,e2,x_21);float a2=smoothstep(e2,e3,x_21);float a3=smoothstep(e3,e4,x_21);return max(mix(v0,v1,a0)*step(e0,x_21)*step(x_21,e1),max(mix(v1,v2,a1)*step(e1,x_21)*step(x_21,e2),max(mix(v2,v3,a2)*step(e2,x_21)*step(x_21,e3),mix(v3,v4,a3)*step(e3,x_21)*step(x_21,e4))));}vec4 blackbody(float x_38){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.2;const vec4 v1=vec4(0.9019607843137255,0,0,1);const float e2=0.4;const vec4 v2=vec4(0.9019607843137255,0.8235294117647058,0,1);const float e3=0.7;const vec4 v3=vec4(1,1,1,1);const float e4=1.0;const vec4 v4=vec4(0.6274509803921569,0.7843137254901961,1,1);float a0=smoothstep(e0,e1,x_38);float a1=smoothstep(e1,e2,x_38);float a2=smoothstep(e2,e3,x_38);float a3=smoothstep(e3,e4,x_38);return max(mix(v0,v1,a0)*step(e0,x_38)*step(x_38,e1),max(mix(v1,v2,a1)*step(e1,x_38)*step(x_38,e2),max(mix(v2,v3,a2)*step(e2,x_38)*step(x_38,e3),mix(v3,v4,a3)*step(e3,x_38)*step(x_38,e4))));}vec4 earth(float x_29){const float e0=0.0;const vec4 v0=vec4(0,0,0.5098039215686274,1);const float e1=0.1;const vec4 v1=vec4(0,0.7058823529411765,0.7058823529411765,1);const float e2=0.2;const vec4 v2=vec4(0.1568627450980392,0.8235294117647058,0.1568627450980392,1);const float e3=0.4;const vec4 v3=vec4(0.9019607843137255,0.9019607843137255,0.19607843137254902,1);const float e4=0.6;const vec4 v4=vec4(0.47058823529411764,0.27450980392156865,0.0784313725490196,1);const float e5=1.0;const vec4 v5=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_29);float a1=smoothstep(e1,e2,x_29);float a2=smoothstep(e2,e3,x_29);float a3=smoothstep(e3,e4,x_29);float a4=smoothstep(e4,e5,x_29);return max(mix(v0,v1,a0)*step(e0,x_29)*step(x_29,e1),max(mix(v1,v2,a1)*step(e1,x_29)*step(x_29,e2),max(mix(v2,v3,a2)*step(e2,x_29)*step(x_29,e3),max(mix(v3,v4,a3)*step(e3,x_29)*step(x_29,e4),mix(v4,v5,a4)*step(e4,x_29)*step(x_29,e5)))));}vec4 electric(float x_9){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.15;const vec4 v1=vec4(0.11764705882352941,0,0.39215686274509803,1);const float e2=0.4;const vec4 v2=vec4(0.47058823529411764,0,0.39215686274509803,1);const float e3=0.6;const vec4 v3=vec4(0.6274509803921569,0.35294117647058826,0,1);const float e4=0.8;const vec4 v4=vec4(0.9019607843137255,0.7843137254901961,0,1);const float e5=1.0;const vec4 v5=vec4(1,0.9803921568627451,0.8627450980392157,1);float a0=smoothstep(e0,e1,x_9);float a1=smoothstep(e1,e2,x_9);float a2=smoothstep(e2,e3,x_9);float a3=smoothstep(e3,e4,x_9);float a4=smoothstep(e4,e5,x_9);return max(mix(v0,v1,a0)*step(e0,x_9)*step(x_9,e1),max(mix(v1,v2,a1)*step(e1,x_9)*step(x_9,e2),max(mix(v2,v3,a2)*step(e2,x_9)*step(x_9,e3),max(mix(v3,v4,a3)*step(e3,x_9)*step(x_9,e4),mix(v4,v5,a4)*step(e4,x_9)*step(x_9,e5)))));}vec4 alpha(float x_0){const float e0=0.0;const vec4 v0=vec4(1,1,1,0);const float e1=1.0;const vec4 v1=vec4(1,1,1,1);float a0=smoothstep(e0,e1,x_0);return mix(v0,v1,a0)*step(e0,x_0)*step(x_0,e1);}vec4 viridis(float x_22){const float e0=0.0;const vec4 v0=vec4(0.26666666666666666,0.00392156862745098,0.32941176470588235,1);const float e1=0.13;const vec4 v1=vec4(0.2784313725490196,0.17254901960784313,0.47843137254901963,1);const float e2=0.25;const vec4 v2=vec4(0.23137254901960785,0.3176470588235294,0.5450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.17254901960784313,0.44313725490196076,0.5568627450980392,1);const float e4=0.5;const vec4 v4=vec4(0.12941176470588237,0.5647058823529412,0.5529411764705883,1);const float e5=0.63;const vec4 v5=vec4(0.15294117647058825,0.6784313725490196,0.5058823529411764,1);const float e6=0.75;const vec4 v6=vec4(0.3607843137254902,0.7843137254901961,0.38823529411764707,1);const float e7=0.88;const vec4 v7=vec4(0.6666666666666666,0.8627450980392157,0.19607843137254902,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.9058823529411765,0.1450980392156863,1);float a0=smoothstep(e0,e1,x_22);float a1=smoothstep(e1,e2,x_22);float a2=smoothstep(e2,e3,x_22);float a3=smoothstep(e3,e4,x_22);float a4=smoothstep(e4,e5,x_22);float a5=smoothstep(e5,e6,x_22);float a6=smoothstep(e6,e7,x_22);float a7=smoothstep(e7,e8,x_22);return max(mix(v0,v1,a0)*step(e0,x_22)*step(x_22,e1),max(mix(v1,v2,a1)*step(e1,x_22)*step(x_22,e2),max(mix(v2,v3,a2)*step(e2,x_22)*step(x_22,e3),max(mix(v3,v4,a3)*step(e3,x_22)*step(x_22,e4),max(mix(v4,v5,a4)*step(e4,x_22)*step(x_22,e5),max(mix(v5,v6,a5)*step(e5,x_22)*step(x_22,e6),max(mix(v6,v7,a6)*step(e6,x_22)*step(x_22,e7),mix(v7,v8,a7)*step(e7,x_22)*step(x_22,e8))))))));}vec4 inferno(float x_30){const float e0=0.0;const vec4 v0=vec4(0,0,0.01568627450980392,1);const float e1=0.13;const vec4 v1=vec4(0.12156862745098039,0.047058823529411764,0.2823529411764706,1);const float e2=0.25;const vec4 v2=vec4(0.3333333333333333,0.058823529411764705,0.42745098039215684,1);const float e3=0.38;const vec4 v3=vec4(0.5333333333333333,0.13333333333333333,0.41568627450980394,1);const float e4=0.5;const vec4 v4=vec4(0.7294117647058823,0.21176470588235294,0.3333333333333333,1);const float e5=0.63;const vec4 v5=vec4(0.8901960784313725,0.34901960784313724,0.2,1);const float e6=0.75;const vec4 v6=vec4(0.9764705882352941,0.5490196078431373,0.0392156862745098,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.788235294117647,0.19607843137254902,1);const float e8=1.0;const vec4 v8=vec4(0.9882352941176471,1,0.6431372549019608,1);float a0=smoothstep(e0,e1,x_30);float a1=smoothstep(e1,e2,x_30);float a2=smoothstep(e2,e3,x_30);float a3=smoothstep(e3,e4,x_30);float a4=smoothstep(e4,e5,x_30);float a5=smoothstep(e5,e6,x_30);float a6=smoothstep(e6,e7,x_30);float a7=smoothstep(e7,e8,x_30);return max(mix(v0,v1,a0)*step(e0,x_30)*step(x_30,e1),max(mix(v1,v2,a1)*step(e1,x_30)*step(x_30,e2),max(mix(v2,v3,a2)*step(e2,x_30)*step(x_30,e3),max(mix(v3,v4,a3)*step(e3,x_30)*step(x_30,e4),max(mix(v4,v5,a4)*step(e4,x_30)*step(x_30,e5),max(mix(v5,v6,a5)*step(e5,x_30)*step(x_30,e6),max(mix(v6,v7,a6)*step(e6,x_30)*step(x_30,e7),mix(v7,v8,a7)*step(e7,x_30)*step(x_30,e8))))))));}vec4 magma(float x_33){const float e0=0.0;const vec4 v0=vec4(0,0,0.01568627450980392,1);const float e1=0.13;const vec4 v1=vec4(0.10980392156862745,0.06274509803921569,0.26666666666666666,1);const float e2=0.25;const vec4 v2=vec4(0.30980392156862746,0.07058823529411765,0.4823529411764706,1);const float e3=0.38;const vec4 v3=vec4(0.5058823529411764,0.1450980392156863,0.5058823529411764,1);const float e4=0.5;const vec4 v4=vec4(0.7098039215686275,0.21176470588235294,0.47843137254901963,1);const float e5=0.63;const vec4 v5=vec4(0.8980392156862745,0.3137254901960784,0.39215686274509803,1);const float e6=0.75;const vec4 v6=vec4(0.984313725490196,0.5294117647058824,0.3803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.996078431372549,0.7607843137254902,0.5294117647058824,1);const float e8=1.0;const vec4 v8=vec4(0.9882352941176471,0.9921568627450981,0.7490196078431373,1);float a0=smoothstep(e0,e1,x_33);float a1=smoothstep(e1,e2,x_33);float a2=smoothstep(e2,e3,x_33);float a3=smoothstep(e3,e4,x_33);float a4=smoothstep(e4,e5,x_33);float a5=smoothstep(e5,e6,x_33);float a6=smoothstep(e6,e7,x_33);float a7=smoothstep(e7,e8,x_33);return max(mix(v0,v1,a0)*step(e0,x_33)*step(x_33,e1),max(mix(v1,v2,a1)*step(e1,x_33)*step(x_33,e2),max(mix(v2,v3,a2)*step(e2,x_33)*step(x_33,e3),max(mix(v3,v4,a3)*step(e3,x_33)*step(x_33,e4),max(mix(v4,v5,a4)*step(e4,x_33)*step(x_33,e5),max(mix(v5,v6,a5)*step(e5,x_33)*step(x_33,e6),max(mix(v6,v7,a6)*step(e6,x_33)*step(x_33,e7),mix(v7,v8,a7)*step(e7,x_33)*step(x_33,e8))))))));}vec4 plasma(float x_3){const float e0=0.0;const vec4 v0=vec4(0.050980392156862744,0.03137254901960784,0.5294117647058824,1);const float e1=0.13;const vec4 v1=vec4(0.29411764705882354,0.011764705882352941,0.6313725490196078,1);const float e2=0.25;const vec4 v2=vec4(0.49019607843137253,0.011764705882352941,0.6588235294117647,1);const float e3=0.38;const vec4 v3=vec4(0.6588235294117647,0.13333333333333333,0.5882352941176471,1);const float e4=0.5;const vec4 v4=vec4(0.796078431372549,0.27450980392156865,0.4745098039215686,1);const float e5=0.63;const vec4 v5=vec4(0.8980392156862745,0.4196078431372549,0.36470588235294116,1);const float e6=0.75;const vec4 v6=vec4(0.9725490196078431,0.5803921568627451,0.2549019607843137,1);const float e7=0.88;const vec4 v7=vec4(0.9921568627450981,0.7647058823529411,0.1568627450980392,1);const float e8=1.0;const vec4 v8=vec4(0.9411764705882353,0.9764705882352941,0.12941176470588237,1);float a0=smoothstep(e0,e1,x_3);float a1=smoothstep(e1,e2,x_3);float a2=smoothstep(e2,e3,x_3);float a3=smoothstep(e3,e4,x_3);float a4=smoothstep(e4,e5,x_3);float a5=smoothstep(e5,e6,x_3);float a6=smoothstep(e6,e7,x_3);float a7=smoothstep(e7,e8,x_3);return max(mix(v0,v1,a0)*step(e0,x_3)*step(x_3,e1),max(mix(v1,v2,a1)*step(e1,x_3)*step(x_3,e2),max(mix(v2,v3,a2)*step(e2,x_3)*step(x_3,e3),max(mix(v3,v4,a3)*step(e3,x_3)*step(x_3,e4),max(mix(v4,v5,a4)*step(e4,x_3)*step(x_3,e5),max(mix(v5,v6,a5)*step(e5,x_3)*step(x_3,e6),max(mix(v6,v7,a6)*step(e6,x_3)*step(x_3,e7),mix(v7,v8,a7)*step(e7,x_3)*step(x_3,e8))))))));}vec4 warm(float x_43){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.13;const vec4 v1=vec4(0.6745098039215687,0,0.7333333333333333,1);const float e2=0.25;const vec4 v2=vec4(0.8588235294117647,0,0.6666666666666666,1);const float e3=0.38;const vec4 v3=vec4(1,0,0.5098039215686274,1);const float e4=0.5;const vec4 v4=vec4(1,0.24705882352941178,0.2901960784313726,1);const float e5=0.63;const vec4 v5=vec4(1,0.4823529411764706,0,1);const float e6=0.75;const vec4 v6=vec4(0.9176470588235294,0.6901960784313725,0,1);const float e7=0.88;const vec4 v7=vec4(0.7450980392156863,0.8941176470588236,0,1);const float e8=1.0;const vec4 v8=vec4(0.5764705882352941,1,0,1);float a0=smoothstep(e0,e1,x_43);float a1=smoothstep(e1,e2,x_43);float a2=smoothstep(e2,e3,x_43);float a3=smoothstep(e3,e4,x_43);float a4=smoothstep(e4,e5,x_43);float a5=smoothstep(e5,e6,x_43);float a6=smoothstep(e6,e7,x_43);float a7=smoothstep(e7,e8,x_43);return max(mix(v0,v1,a0)*step(e0,x_43)*step(x_43,e1),max(mix(v1,v2,a1)*step(e1,x_43)*step(x_43,e2),max(mix(v2,v3,a2)*step(e2,x_43)*step(x_43,e3),max(mix(v3,v4,a3)*step(e3,x_43)*step(x_43,e4),max(mix(v4,v5,a4)*step(e4,x_43)*step(x_43,e5),max(mix(v5,v6,a5)*step(e5,x_43)*step(x_43,e6),max(mix(v6,v7,a6)*step(e6,x_43)*step(x_43,e7),mix(v7,v8,a7)*step(e7,x_43)*step(x_43,e8))))))));}vec4 rainbow_soft_1310269270(float x_14){const float e0=0.0;const vec4 v0=vec4(0.49019607843137253,0,0.7019607843137254,1);const float e1=0.1;const vec4 v1=vec4(0.7803921568627451,0,0.7058823529411765,1);const float e2=0.2;const vec4 v2=vec4(1,0,0.4745098039215686,1);const float e3=0.3;const vec4 v3=vec4(1,0.4235294117647059,0,1);const float e4=0.4;const vec4 v4=vec4(0.8705882352941177,0.7607843137254902,0,1);const float e5=0.5;const vec4 v5=vec4(0.5882352941176471,1,0,1);const float e6=0.6;const vec4 v6=vec4(0,1,0.21568627450980393,1);const float e7=0.7;const vec4 v7=vec4(0,0.9647058823529412,0.5882352941176471,1);const float e8=0.8;const vec4 v8=vec4(0.19607843137254902,0.6549019607843137,0.8705882352941177,1);const float e9=0.9;const vec4 v9=vec4(0.403921568627451,0.2,0.9215686274509803,1);const float e10=1.0;const vec4 v10=vec4(0.48627450980392156,0,0.7294117647058823,1);float a0=smoothstep(e0,e1,x_14);float a1=smoothstep(e1,e2,x_14);float a2=smoothstep(e2,e3,x_14);float a3=smoothstep(e3,e4,x_14);float a4=smoothstep(e4,e5,x_14);float a5=smoothstep(e5,e6,x_14);float a6=smoothstep(e6,e7,x_14);float a7=smoothstep(e7,e8,x_14);float a8=smoothstep(e8,e9,x_14);float a9=smoothstep(e9,e10,x_14);return max(mix(v0,v1,a0)*step(e0,x_14)*step(x_14,e1),max(mix(v1,v2,a1)*step(e1,x_14)*step(x_14,e2),max(mix(v2,v3,a2)*step(e2,x_14)*step(x_14,e3),max(mix(v3,v4,a3)*step(e3,x_14)*step(x_14,e4),max(mix(v4,v5,a4)*step(e4,x_14)*step(x_14,e5),max(mix(v5,v6,a5)*step(e5,x_14)*step(x_14,e6),max(mix(v6,v7,a6)*step(e6,x_14)*step(x_14,e7),max(mix(v7,v8,a7)*step(e7,x_14)*step(x_14,e8),max(mix(v8,v9,a8)*step(e8,x_14)*step(x_14,e9),mix(v9,v10,a9)*step(e9,x_14)*step(x_14,e10))))))))));}vec4 bathymetry(float x_36){const float e0=0.0;const vec4 v0=vec4(0.1568627450980392,0.10196078431372549,0.17254901960784313,1);const float e1=0.13;const vec4 v1=vec4(0.23137254901960785,0.19215686274509805,0.35294117647058826,1);const float e2=0.25;const vec4 v2=vec4(0.25098039215686274,0.2980392156862745,0.5450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.24705882352941178,0.43137254901960786,0.592156862745098,1);const float e4=0.5;const vec4 v4=vec4(0.2823529411764706,0.5568627450980392,0.6196078431372549,1);const float e5=0.63;const vec4 v5=vec4(0.3333333333333333,0.6823529411764706,0.6392156862745098,1);const float e6=0.75;const vec4 v6=vec4(0.47058823529411764,0.807843137254902,0.6392156862745098,1);const float e7=0.88;const vec4 v7=vec4(0.7333333333333333,0.9019607843137255,0.6745098039215687,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.996078431372549,0.8,1);float a0=smoothstep(e0,e1,x_36);float a1=smoothstep(e1,e2,x_36);float a2=smoothstep(e2,e3,x_36);float a3=smoothstep(e3,e4,x_36);float a4=smoothstep(e4,e5,x_36);float a5=smoothstep(e5,e6,x_36);float a6=smoothstep(e6,e7,x_36);float a7=smoothstep(e7,e8,x_36);return max(mix(v0,v1,a0)*step(e0,x_36)*step(x_36,e1),max(mix(v1,v2,a1)*step(e1,x_36)*step(x_36,e2),max(mix(v2,v3,a2)*step(e2,x_36)*step(x_36,e3),max(mix(v3,v4,a3)*step(e3,x_36)*step(x_36,e4),max(mix(v4,v5,a4)*step(e4,x_36)*step(x_36,e5),max(mix(v5,v6,a5)*step(e5,x_36)*step(x_36,e6),max(mix(v6,v7,a6)*step(e6,x_36)*step(x_36,e7),mix(v7,v8,a7)*step(e7,x_36)*step(x_36,e8))))))));}vec4 cdom(float x_7){const float e0=0.0;const vec4 v0=vec4(0.1843137254901961,0.058823529411764705,0.24313725490196078,1);const float e1=0.13;const vec4 v1=vec4(0.3411764705882353,0.09019607843137255,0.33725490196078434,1);const float e2=0.25;const vec4 v2=vec4(0.5098039215686274,0.10980392156862745,0.38823529411764707,1);const float e3=0.38;const vec4 v3=vec4(0.6705882352941176,0.1607843137254902,0.3764705882352941,1);const float e4=0.5;const vec4 v4=vec4(0.807843137254902,0.2627450980392157,0.33725490196078434,1);const float e5=0.63;const vec4 v5=vec4(0.9019607843137255,0.41568627450980394,0.32941176470588235,1);const float e6=0.75;const vec4 v6=vec4(0.9490196078431372,0.5843137254901961,0.403921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.7568627450980392,0.5294117647058824,1);const float e8=1.0;const vec4 v8=vec4(0.996078431372549,0.9294117647058824,0.6901960784313725,1);float a0=smoothstep(e0,e1,x_7);float a1=smoothstep(e1,e2,x_7);float a2=smoothstep(e2,e3,x_7);float a3=smoothstep(e3,e4,x_7);float a4=smoothstep(e4,e5,x_7);float a5=smoothstep(e5,e6,x_7);float a6=smoothstep(e6,e7,x_7);float a7=smoothstep(e7,e8,x_7);return max(mix(v0,v1,a0)*step(e0,x_7)*step(x_7,e1),max(mix(v1,v2,a1)*step(e1,x_7)*step(x_7,e2),max(mix(v2,v3,a2)*step(e2,x_7)*step(x_7,e3),max(mix(v3,v4,a3)*step(e3,x_7)*step(x_7,e4),max(mix(v4,v5,a4)*step(e4,x_7)*step(x_7,e5),max(mix(v5,v6,a5)*step(e5,x_7)*step(x_7,e6),max(mix(v6,v7,a6)*step(e6,x_7)*step(x_7,e7),mix(v7,v8,a7)*step(e7,x_7)*step(x_7,e8))))))));}vec4 chlorophyll(float x_6){const float e0=0.0;const vec4 v0=vec4(0.07058823529411765,0.1411764705882353,0.0784313725490196,1);const float e1=0.13;const vec4 v1=vec4(0.09803921568627451,0.24705882352941178,0.1607843137254902,1);const float e2=0.25;const vec4 v2=vec4(0.09411764705882353,0.3568627450980392,0.23137254901960785,1);const float e3=0.38;const vec4 v3=vec4(0.050980392156862744,0.4666666666666667,0.2823529411764706,1);const float e4=0.5;const vec4 v4=vec4(0.07058823529411765,0.5803921568627451,0.3137254901960784,1);const float e5=0.63;const vec4 v5=vec4(0.3137254901960784,0.6784313725490196,0.34901960784313724,1);const float e6=0.75;const vec4 v6=vec4(0.5176470588235295,0.7686274509803922,0.47843137254901963,1);const float e7=0.88;const vec4 v7=vec4(0.6862745098039216,0.8666666666666667,0.6352941176470588,1);const float e8=1.0;const vec4 v8=vec4(0.8431372549019608,0.9764705882352941,0.8156862745098039,1);float a0=smoothstep(e0,e1,x_6);float a1=smoothstep(e1,e2,x_6);float a2=smoothstep(e2,e3,x_6);float a3=smoothstep(e3,e4,x_6);float a4=smoothstep(e4,e5,x_6);float a5=smoothstep(e5,e6,x_6);float a6=smoothstep(e6,e7,x_6);float a7=smoothstep(e7,e8,x_6);return max(mix(v0,v1,a0)*step(e0,x_6)*step(x_6,e1),max(mix(v1,v2,a1)*step(e1,x_6)*step(x_6,e2),max(mix(v2,v3,a2)*step(e2,x_6)*step(x_6,e3),max(mix(v3,v4,a3)*step(e3,x_6)*step(x_6,e4),max(mix(v4,v5,a4)*step(e4,x_6)*step(x_6,e5),max(mix(v5,v6,a5)*step(e5,x_6)*step(x_6,e6),max(mix(v6,v7,a6)*step(e6,x_6)*step(x_6,e7),mix(v7,v8,a7)*step(e7,x_6)*step(x_6,e8))))))));}vec4 density(float x_19){const float e0=0.0;const vec4 v0=vec4(0.21176470588235294,0.054901960784313725,0.1411764705882353,1);const float e1=0.13;const vec4 v1=vec4(0.34901960784313724,0.09019607843137255,0.3137254901960784,1);const float e2=0.25;const vec4 v2=vec4(0.43137254901960786,0.17647058823529413,0.5176470588235295,1);const float e3=0.38;const vec4 v3=vec4(0.47058823529411764,0.30196078431372547,0.6980392156862745,1);const float e4=0.5;const vec4 v4=vec4(0.47058823529411764,0.44313725490196076,0.8352941176470589,1);const float e5=0.63;const vec4 v5=vec4(0.45098039215686275,0.592156862745098,0.8941176470588236,1);const float e6=0.75;const vec4 v6=vec4(0.5254901960784314,0.7254901960784313,0.8901960784313725,1);const float e7=0.88;const vec4 v7=vec4(0.6941176470588235,0.8392156862745098,0.8901960784313725,1);const float e8=1.0;const vec4 v8=vec4(0.9019607843137255,0.9450980392156862,0.9450980392156862,1);float a0=smoothstep(e0,e1,x_19);float a1=smoothstep(e1,e2,x_19);float a2=smoothstep(e2,e3,x_19);float a3=smoothstep(e3,e4,x_19);float a4=smoothstep(e4,e5,x_19);float a5=smoothstep(e5,e6,x_19);float a6=smoothstep(e6,e7,x_19);float a7=smoothstep(e7,e8,x_19);return max(mix(v0,v1,a0)*step(e0,x_19)*step(x_19,e1),max(mix(v1,v2,a1)*step(e1,x_19)*step(x_19,e2),max(mix(v2,v3,a2)*step(e2,x_19)*step(x_19,e3),max(mix(v3,v4,a3)*step(e3,x_19)*step(x_19,e4),max(mix(v4,v5,a4)*step(e4,x_19)*step(x_19,e5),max(mix(v5,v6,a5)*step(e5,x_19)*step(x_19,e6),max(mix(v6,v7,a6)*step(e6,x_19)*step(x_19,e7),mix(v7,v8,a7)*step(e7,x_19)*step(x_19,e8))))))));}vec4 freesurface_blue_3154355989(float x_35){const float e0=0.0;const vec4 v0=vec4(0.11764705882352941,0.01568627450980392,0.43137254901960786,1);const float e1=0.13;const vec4 v1=vec4(0.1843137254901961,0.054901960784313725,0.6901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.1607843137254902,0.17647058823529413,0.9254901960784314,1);const float e3=0.38;const vec4 v3=vec4(0.09803921568627451,0.38823529411764707,0.8313725490196079,1);const float e4=0.5;const vec4 v4=vec4(0.26666666666666666,0.5137254901960784,0.7843137254901961,1);const float e5=0.63;const vec4 v5=vec4(0.4470588235294118,0.611764705882353,0.7725490196078432,1);const float e6=0.75;const vec4 v6=vec4(0.615686274509804,0.7098039215686275,0.796078431372549,1);const float e7=0.88;const vec4 v7=vec4(0.7843137254901961,0.8156862745098039,0.8470588235294118,1);const float e8=1.0;const vec4 v8=vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);float a0=smoothstep(e0,e1,x_35);float a1=smoothstep(e1,e2,x_35);float a2=smoothstep(e2,e3,x_35);float a3=smoothstep(e3,e4,x_35);float a4=smoothstep(e4,e5,x_35);float a5=smoothstep(e5,e6,x_35);float a6=smoothstep(e6,e7,x_35);float a7=smoothstep(e7,e8,x_35);return max(mix(v0,v1,a0)*step(e0,x_35)*step(x_35,e1),max(mix(v1,v2,a1)*step(e1,x_35)*step(x_35,e2),max(mix(v2,v3,a2)*step(e2,x_35)*step(x_35,e3),max(mix(v3,v4,a3)*step(e3,x_35)*step(x_35,e4),max(mix(v4,v5,a4)*step(e4,x_35)*step(x_35,e5),max(mix(v5,v6,a5)*step(e5,x_35)*step(x_35,e6),max(mix(v6,v7,a6)*step(e6,x_35)*step(x_35,e7),mix(v7,v8,a7)*step(e7,x_35)*step(x_35,e8))))))));}vec4 freesurface_red_1679163293(float x_20){const float e0=0.0;const vec4 v0=vec4(0.23529411764705882,0.03529411764705882,0.07058823529411765,1);const float e1=0.13;const vec4 v1=vec4(0.39215686274509803,0.06666666666666667,0.10588235294117647,1);const float e2=0.25;const vec4 v2=vec4(0.5568627450980392,0.0784313725490196,0.11372549019607843,1);const float e3=0.38;const vec4 v3=vec4(0.6941176470588235,0.16862745098039217,0.10588235294117647,1);const float e4=0.5;const vec4 v4=vec4(0.7529411764705882,0.3411764705882353,0.24705882352941178,1);const float e5=0.63;const vec4 v5=vec4(0.803921568627451,0.49019607843137253,0.4117647058823529,1);const float e6=0.75;const vec4 v6=vec4(0.8470588235294118,0.6352941176470588,0.5803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.8901960784313725,0.7803921568627451,0.7568627450980392,1);const float e8=1.0;const vec4 v8=vec4(0.9450980392156862,0.9294117647058824,0.9254901960784314,1);float a0=smoothstep(e0,e1,x_20);float a1=smoothstep(e1,e2,x_20);float a2=smoothstep(e2,e3,x_20);float a3=smoothstep(e3,e4,x_20);float a4=smoothstep(e4,e5,x_20);float a5=smoothstep(e5,e6,x_20);float a6=smoothstep(e6,e7,x_20);float a7=smoothstep(e7,e8,x_20);return max(mix(v0,v1,a0)*step(e0,x_20)*step(x_20,e1),max(mix(v1,v2,a1)*step(e1,x_20)*step(x_20,e2),max(mix(v2,v3,a2)*step(e2,x_20)*step(x_20,e3),max(mix(v3,v4,a3)*step(e3,x_20)*step(x_20,e4),max(mix(v4,v5,a4)*step(e4,x_20)*step(x_20,e5),max(mix(v5,v6,a5)*step(e5,x_20)*step(x_20,e6),max(mix(v6,v7,a6)*step(e6,x_20)*step(x_20,e7),mix(v7,v8,a7)*step(e7,x_20)*step(x_20,e8))))))));}vec4 oxygen(float x_11){const float e0=0.0;const vec4 v0=vec4(0.25098039215686274,0.0196078431372549,0.0196078431372549,1);const float e1=0.13;const vec4 v1=vec4(0.41568627450980394,0.023529411764705882,0.058823529411764705,1);const float e2=0.25;const vec4 v2=vec4(0.5647058823529412,0.10196078431372549,0.027450980392156862,1);const float e3=0.38;const vec4 v3=vec4(0.6588235294117647,0.25098039215686274,0.011764705882352941,1);const float e4=0.5;const vec4 v4=vec4(0.7372549019607844,0.39215686274509803,0.01568627450980392,1);const float e5=0.63;const vec4 v5=vec4(0.807843137254902,0.5333333333333333,0.043137254901960784,1);const float e6=0.75;const vec4 v6=vec4(0.8627450980392157,0.6823529411764706,0.09803921568627451,1);const float e7=0.88;const vec4 v7=vec4(0.9058823529411765,0.8431372549019608,0.17254901960784313,1);const float e8=1.0;const vec4 v8=vec4(0.9725490196078431,0.996078431372549,0.4117647058823529,1);float a0=smoothstep(e0,e1,x_11);float a1=smoothstep(e1,e2,x_11);float a2=smoothstep(e2,e3,x_11);float a3=smoothstep(e3,e4,x_11);float a4=smoothstep(e4,e5,x_11);float a5=smoothstep(e5,e6,x_11);float a6=smoothstep(e6,e7,x_11);float a7=smoothstep(e7,e8,x_11);return max(mix(v0,v1,a0)*step(e0,x_11)*step(x_11,e1),max(mix(v1,v2,a1)*step(e1,x_11)*step(x_11,e2),max(mix(v2,v3,a2)*step(e2,x_11)*step(x_11,e3),max(mix(v3,v4,a3)*step(e3,x_11)*step(x_11,e4),max(mix(v4,v5,a4)*step(e4,x_11)*step(x_11,e5),max(mix(v5,v6,a5)*step(e5,x_11)*step(x_11,e6),max(mix(v6,v7,a6)*step(e6,x_11)*step(x_11,e7),mix(v7,v8,a7)*step(e7,x_11)*step(x_11,e8))))))));}vec4 par(float x_28){const float e0=0.0;const vec4 v0=vec4(0.2,0.0784313725490196,0.09411764705882353,1);const float e1=0.13;const vec4 v1=vec4(0.35294117647058826,0.12549019607843137,0.13725490196078433,1);const float e2=0.25;const vec4 v2=vec4(0.5058823529411764,0.17254901960784313,0.13333333333333333,1);const float e3=0.38;const vec4 v3=vec4(0.6235294117647059,0.26666666666666666,0.09803921568627451,1);const float e4=0.5;const vec4 v4=vec4(0.7137254901960784,0.38823529411764707,0.07450980392156863,1);const float e5=0.63;const vec4 v5=vec4(0.7803921568627451,0.5254901960784314,0.08627450980392157,1);const float e6=0.75;const vec4 v6=vec4(0.8313725490196079,0.6705882352941176,0.13725490196078433,1);const float e7=0.88;const vec4 v7=vec4(0.8666666666666667,0.8235294117647058,0.21176470588235294,1);const float e8=1.0;const vec4 v8=vec4(0.8823529411764706,0.9921568627450981,0.29411764705882354,1);float a0=smoothstep(e0,e1,x_28);float a1=smoothstep(e1,e2,x_28);float a2=smoothstep(e2,e3,x_28);float a3=smoothstep(e3,e4,x_28);float a4=smoothstep(e4,e5,x_28);float a5=smoothstep(e5,e6,x_28);float a6=smoothstep(e6,e7,x_28);float a7=smoothstep(e7,e8,x_28);return max(mix(v0,v1,a0)*step(e0,x_28)*step(x_28,e1),max(mix(v1,v2,a1)*step(e1,x_28)*step(x_28,e2),max(mix(v2,v3,a2)*step(e2,x_28)*step(x_28,e3),max(mix(v3,v4,a3)*step(e3,x_28)*step(x_28,e4),max(mix(v4,v5,a4)*step(e4,x_28)*step(x_28,e5),max(mix(v5,v6,a5)*step(e5,x_28)*step(x_28,e6),max(mix(v6,v7,a6)*step(e6,x_28)*step(x_28,e7),mix(v7,v8,a7)*step(e7,x_28)*step(x_28,e8))))))));}vec4 phase(float x_39){const float e0=0.0;const vec4 v0=vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);const float e1=0.13;const vec4 v1=vec4(0.7215686274509804,0.2784313725490196,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.7294117647058823,0.22745098039215686,0.45098039215686275,1);const float e3=0.38;const vec4 v3=vec4(0.6274509803921569,0.2784313725490196,0.7254901960784313,1);const float e4=0.5;const vec4 v4=vec4(0.43137254901960786,0.3803921568627451,0.8549019607843137,1);const float e5=0.63;const vec4 v5=vec4(0.19607843137254902,0.4823529411764706,0.6431372549019608,1);const float e6=0.75;const vec4 v6=vec4(0.12156862745098039,0.5137254901960784,0.43137254901960786,1);const float e7=0.88;const vec4 v7=vec4(0.30196078431372547,0.5058823529411764,0.13333333333333333,1);const float e8=1.0;const vec4 v8=vec4(0.5686274509803921,0.4117647058823529,0.07058823529411765,1);float a0=smoothstep(e0,e1,x_39);float a1=smoothstep(e1,e2,x_39);float a2=smoothstep(e2,e3,x_39);float a3=smoothstep(e3,e4,x_39);float a4=smoothstep(e4,e5,x_39);float a5=smoothstep(e5,e6,x_39);float a6=smoothstep(e6,e7,x_39);float a7=smoothstep(e7,e8,x_39);return max(mix(v0,v1,a0)*step(e0,x_39)*step(x_39,e1),max(mix(v1,v2,a1)*step(e1,x_39)*step(x_39,e2),max(mix(v2,v3,a2)*step(e2,x_39)*step(x_39,e3),max(mix(v3,v4,a3)*step(e3,x_39)*step(x_39,e4),max(mix(v4,v5,a4)*step(e4,x_39)*step(x_39,e5),max(mix(v5,v6,a5)*step(e5,x_39)*step(x_39,e6),max(mix(v6,v7,a6)*step(e6,x_39)*step(x_39,e7),mix(v7,v8,a7)*step(e7,x_39)*step(x_39,e8))))))));}vec4 salinity(float x_26){const float e0=0.0;const vec4 v0=vec4(0.16470588235294117,0.09411764705882353,0.4235294117647059,1);const float e1=0.13;const vec4 v1=vec4(0.12941176470588237,0.19607843137254902,0.6352941176470588,1);const float e2=0.25;const vec4 v2=vec4(0.058823529411764705,0.35294117647058826,0.5686274509803921,1);const float e3=0.38;const vec4 v3=vec4(0.1568627450980392,0.4627450980392157,0.5372549019607843,1);const float e4=0.5;const vec4 v4=vec4(0.23137254901960785,0.5725490196078431,0.5294117647058824,1);const float e5=0.63;const vec4 v5=vec4(0.30980392156862746,0.6862745098039216,0.49411764705882355,1);const float e6=0.75;const vec4 v6=vec4(0.47058823529411764,0.796078431372549,0.40784313725490196,1);const float e7=0.88;const vec4 v7=vec4(0.7568627450980392,0.8666666666666667,0.39215686274509803,1);const float e8=1.0;const vec4 v8=vec4(0.9921568627450981,0.9372549019607843,0.6039215686274509,1);float a0=smoothstep(e0,e1,x_26);float a1=smoothstep(e1,e2,x_26);float a2=smoothstep(e2,e3,x_26);float a3=smoothstep(e3,e4,x_26);float a4=smoothstep(e4,e5,x_26);float a5=smoothstep(e5,e6,x_26);float a6=smoothstep(e6,e7,x_26);float a7=smoothstep(e7,e8,x_26);return max(mix(v0,v1,a0)*step(e0,x_26)*step(x_26,e1),max(mix(v1,v2,a1)*step(e1,x_26)*step(x_26,e2),max(mix(v2,v3,a2)*step(e2,x_26)*step(x_26,e3),max(mix(v3,v4,a3)*step(e3,x_26)*step(x_26,e4),max(mix(v4,v5,a4)*step(e4,x_26)*step(x_26,e5),max(mix(v5,v6,a5)*step(e5,x_26)*step(x_26,e6),max(mix(v6,v7,a6)*step(e6,x_26)*step(x_26,e7),mix(v7,v8,a7)*step(e7,x_26)*step(x_26,e8))))))));}vec4 temperature(float x_8){const float e0=0.0;const vec4 v0=vec4(0.01568627450980392,0.13725490196078433,0.2,1);const float e1=0.13;const vec4 v1=vec4(0.09019607843137255,0.2,0.47843137254901963,1);const float e2=0.25;const vec4 v2=vec4(0.3333333333333333,0.23137254901960785,0.615686274509804,1);const float e3=0.38;const vec4 v3=vec4(0.5058823529411764,0.30980392156862746,0.5607843137254902,1);const float e4=0.5;const vec4 v4=vec4(0.6862745098039216,0.37254901960784315,0.5098039215686274,1);const float e5=0.63;const vec4 v5=vec4(0.8705882352941177,0.4392156862745098,0.396078431372549,1);const float e6=0.75;const vec4 v6=vec4(0.9764705882352941,0.5725490196078431,0.25882352941176473,1);const float e7=0.88;const vec4 v7=vec4(0.9764705882352941,0.7686274509803922,0.2549019607843137,1);const float e8=1.0;const vec4 v8=vec4(0.9098039215686274,0.9803921568627451,0.3568627450980392,1);float a0=smoothstep(e0,e1,x_8);float a1=smoothstep(e1,e2,x_8);float a2=smoothstep(e2,e3,x_8);float a3=smoothstep(e3,e4,x_8);float a4=smoothstep(e4,e5,x_8);float a5=smoothstep(e5,e6,x_8);float a6=smoothstep(e6,e7,x_8);float a7=smoothstep(e7,e8,x_8);return max(mix(v0,v1,a0)*step(e0,x_8)*step(x_8,e1),max(mix(v1,v2,a1)*step(e1,x_8)*step(x_8,e2),max(mix(v2,v3,a2)*step(e2,x_8)*step(x_8,e3),max(mix(v3,v4,a3)*step(e3,x_8)*step(x_8,e4),max(mix(v4,v5,a4)*step(e4,x_8)*step(x_8,e5),max(mix(v5,v6,a5)*step(e5,x_8)*step(x_8,e6),max(mix(v6,v7,a6)*step(e6,x_8)*step(x_8,e7),mix(v7,v8,a7)*step(e7,x_8)*step(x_8,e8))))))));}vec4 turbidity(float x_40){const float e0=0.0;const vec4 v0=vec4(0.13333333333333333,0.12156862745098039,0.10588235294117647,1);const float e1=0.13;const vec4 v1=vec4(0.2549019607843137,0.19607843137254902,0.1607843137254902,1);const float e2=0.25;const vec4 v2=vec4(0.3843137254901961,0.27058823529411763,0.20392156862745098,1);const float e3=0.38;const vec4 v3=vec4(0.5137254901960784,0.34901960784313724,0.2235294117647059,1);const float e4=0.5;const vec4 v4=vec4(0.6313725490196078,0.4392156862745098,0.23137254901960785,1);const float e5=0.63;const vec4 v5=vec4(0.7254901960784313,0.5490196078431373,0.25882352941176473,1);const float e6=0.75;const vec4 v6=vec4(0.792156862745098,0.6823529411764706,0.34509803921568627,1);const float e7=0.88;const vec4 v7=vec4(0.8470588235294118,0.8196078431372549,0.49411764705882355,1);const float e8=1.0;const vec4 v8=vec4(0.9137254901960784,0.9647058823529412,0.6705882352941176,1);float a0=smoothstep(e0,e1,x_40);float a1=smoothstep(e1,e2,x_40);float a2=smoothstep(e2,e3,x_40);float a3=smoothstep(e3,e4,x_40);float a4=smoothstep(e4,e5,x_40);float a5=smoothstep(e5,e6,x_40);float a6=smoothstep(e6,e7,x_40);float a7=smoothstep(e7,e8,x_40);return max(mix(v0,v1,a0)*step(e0,x_40)*step(x_40,e1),max(mix(v1,v2,a1)*step(e1,x_40)*step(x_40,e2),max(mix(v2,v3,a2)*step(e2,x_40)*step(x_40,e3),max(mix(v3,v4,a3)*step(e3,x_40)*step(x_40,e4),max(mix(v4,v5,a4)*step(e4,x_40)*step(x_40,e5),max(mix(v5,v6,a5)*step(e5,x_40)*step(x_40,e6),max(mix(v6,v7,a6)*step(e6,x_40)*step(x_40,e7),mix(v7,v8,a7)*step(e7,x_40)*step(x_40,e8))))))));}vec4 velocity_blue_297387650(float x_2){const float e0=0.0;const vec4 v0=vec4(0.06666666666666667,0.12549019607843137,0.25098039215686274,1);const float e1=0.13;const vec4 v1=vec4(0.13725490196078433,0.20392156862745098,0.4549019607843137,1);const float e2=0.25;const vec4 v2=vec4(0.11372549019607843,0.3176470588235294,0.611764705882353,1);const float e3=0.38;const vec4 v3=vec4(0.12156862745098039,0.44313725490196076,0.6352941176470588,1);const float e4=0.5;const vec4 v4=vec4(0.19607843137254902,0.5647058823529412,0.6627450980392157,1);const float e5=0.63;const vec4 v5=vec4(0.3411764705882353,0.6784313725490196,0.6901960784313725,1);const float e6=0.75;const vec4 v6=vec4(0.5843137254901961,0.7686274509803922,0.7411764705882353,1);const float e7=0.88;const vec4 v7=vec4(0.796078431372549,0.8666666666666667,0.8274509803921568,1);const float e8=1.0;const vec4 v8=vec4(0.996078431372549,0.984313725490196,0.9019607843137255,1);float a0=smoothstep(e0,e1,x_2);float a1=smoothstep(e1,e2,x_2);float a2=smoothstep(e2,e3,x_2);float a3=smoothstep(e3,e4,x_2);float a4=smoothstep(e4,e5,x_2);float a5=smoothstep(e5,e6,x_2);float a6=smoothstep(e6,e7,x_2);float a7=smoothstep(e7,e8,x_2);return max(mix(v0,v1,a0)*step(e0,x_2)*step(x_2,e1),max(mix(v1,v2,a1)*step(e1,x_2)*step(x_2,e2),max(mix(v2,v3,a2)*step(e2,x_2)*step(x_2,e3),max(mix(v3,v4,a3)*step(e3,x_2)*step(x_2,e4),max(mix(v4,v5,a4)*step(e4,x_2)*step(x_2,e5),max(mix(v5,v6,a5)*step(e5,x_2)*step(x_2,e6),max(mix(v6,v7,a6)*step(e6,x_2)*step(x_2,e7),mix(v7,v8,a7)*step(e7,x_2)*step(x_2,e8))))))));}vec4 velocity_green_2558432129(float x_27){const float e0=0.0;const vec4 v0=vec4(0.09019607843137255,0.13725490196078433,0.07450980392156863,1);const float e1=0.13;const vec4 v1=vec4(0.09411764705882353,0.25098039215686274,0.14901960784313725,1);const float e2=0.25;const vec4 v2=vec4(0.043137254901960784,0.37254901960784315,0.17647058823529413,1);const float e3=0.38;const vec4 v3=vec4(0.15294117647058825,0.4823529411764706,0.13725490196078433,1);const float e4=0.5;const vec4 v4=vec4(0.37254901960784315,0.5725490196078431,0.047058823529411764,1);const float e5=0.63;const vec4 v5=vec4(0.596078431372549,0.6470588235294118,0.07058823529411765,1);const float e6=0.75;const vec4 v6=vec4(0.788235294117647,0.7294117647058823,0.27058823529411763,1);const float e7=0.88;const vec4 v7=vec4(0.9137254901960784,0.8470588235294118,0.5372549019607843,1);const float e8=1.0;const vec4 v8=vec4(1,0.9921568627450981,0.803921568627451,1);float a0=smoothstep(e0,e1,x_27);float a1=smoothstep(e1,e2,x_27);float a2=smoothstep(e2,e3,x_27);float a3=smoothstep(e3,e4,x_27);float a4=smoothstep(e4,e5,x_27);float a5=smoothstep(e5,e6,x_27);float a6=smoothstep(e6,e7,x_27);float a7=smoothstep(e7,e8,x_27);return max(mix(v0,v1,a0)*step(e0,x_27)*step(x_27,e1),max(mix(v1,v2,a1)*step(e1,x_27)*step(x_27,e2),max(mix(v2,v3,a2)*step(e2,x_27)*step(x_27,e3),max(mix(v3,v4,a3)*step(e3,x_27)*step(x_27,e4),max(mix(v4,v5,a4)*step(e4,x_27)*step(x_27,e5),max(mix(v5,v6,a5)*step(e5,x_27)*step(x_27,e6),max(mix(v6,v7,a6)*step(e6,x_27)*step(x_27,e7),mix(v7,v8,a7)*step(e7,x_27)*step(x_27,e8))))))));}vec4 cubehelix(float x_37){const float e0=0.0;const vec4 v0=vec4(0,0,0,1);const float e1=0.07;const vec4 v1=vec4(0.08627450980392157,0.0196078431372549,0.23137254901960785,1);const float e2=0.13;const vec4 v2=vec4(0.23529411764705882,0.01568627450980392,0.4117647058823529,1);const float e3=0.2;const vec4 v3=vec4(0.42745098039215684,0.00392156862745098,0.5294117647058824,1);const float e4=0.27;const vec4 v4=vec4(0.6313725490196078,0,0.5764705882352941,1);const float e5=0.33;const vec4 v5=vec4(0.8235294117647058,0.00784313725490196,0.5568627450980392,1);const float e6=0.4;const vec4 v6=vec4(0.984313725490196,0.043137254901960784,0.4823529411764706,1);const float e7=0.47;const vec4 v7=vec4(1,0.11372549019607843,0.3803921568627451,1);const float e8=0.53;const vec4 v8=vec4(1,0.21176470588235294,0.27058823529411763,1);const float e9=0.6;const vec4 v9=vec4(1,0.3333333333333333,0.1803921568627451,1);const float e10=0.67;const vec4 v10=vec4(1,0.47058823529411764,0.13333333333333333,1);const float e11=0.73;const vec4 v11=vec4(1,0.615686274509804,0.1450980392156863,1);const float e12=0.8;const vec4 v12=vec4(0.9450980392156862,0.7490196078431373,0.2235294117647059,1);const float e13=0.87;const vec4 v13=vec4(0.8784313725490196,0.8627450980392157,0.36470588235294116,1);const float e14=0.93;const vec4 v14=vec4(0.8549019607843137,0.9450980392156862,0.5568627450980392,1);const float e15=1.0;const vec4 v15=vec4(0.8901960784313725,0.9921568627450981,0.7764705882352941,1);float a0=smoothstep(e0,e1,x_37);float a1=smoothstep(e1,e2,x_37);float a2=smoothstep(e2,e3,x_37);float a3=smoothstep(e3,e4,x_37);float a4=smoothstep(e4,e5,x_37);float a5=smoothstep(e5,e6,x_37);float a6=smoothstep(e6,e7,x_37);float a7=smoothstep(e7,e8,x_37);float a8=smoothstep(e8,e9,x_37);float a9=smoothstep(e9,e10,x_37);float a10=smoothstep(e10,e11,x_37);float a11=smoothstep(e11,e12,x_37);float a12=smoothstep(e12,e13,x_37);float a13=smoothstep(e13,e14,x_37);float a14=smoothstep(e14,e15,x_37);return max(mix(v0,v1,a0)*step(e0,x_37)*step(x_37,e1),max(mix(v1,v2,a1)*step(e1,x_37)*step(x_37,e2),max(mix(v2,v3,a2)*step(e2,x_37)*step(x_37,e3),max(mix(v3,v4,a3)*step(e3,x_37)*step(x_37,e4),max(mix(v4,v5,a4)*step(e4,x_37)*step(x_37,e5),max(mix(v5,v6,a5)*step(e5,x_37)*step(x_37,e6),max(mix(v6,v7,a6)*step(e6,x_37)*step(x_37,e7),max(mix(v7,v8,a7)*step(e7,x_37)*step(x_37,e8),max(mix(v8,v9,a8)*step(e8,x_37)*step(x_37,e9),max(mix(v9,v10,a9)*step(e9,x_37)*step(x_37,e10),max(mix(v10,v11,a10)*step(e10,x_37)*step(x_37,e11),max(mix(v11,v12,a11)*step(e11,x_37)*step(x_37,e12),max(mix(v12,v13,a12)*step(e12,x_37)*step(x_37,e13),max(mix(v13,v14,a13)*step(e13,x_37)*step(x_37,e14),mix(v14,v15,a14)*step(e14,x_37)*step(x_37,e15)))))))))))))));}vec3 hsv_to_rgb(vec3 c){vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);}vec3 rgb_to_hsv(vec3 rgb){float Cmax=max(rgb.r,max(rgb.g,rgb.b));float Cmin=min(rgb.r,min(rgb.g,rgb.b));float delta=Cmax-Cmin;vec3 hsv=vec3(0.,0.,Cmax);if(Cmax>Cmin){hsv.y=delta/Cmax;if(rgb.r==Cmax){hsv.x=(rgb.g-rgb.b)/delta;}else{if(rgb.g==Cmax){hsv.x=2.+(rgb.b-rgb.r)/delta;}else{hsv.x=4.+(rgb.r-rgb.g)/delta;}}hsv.x=fract(hsv.x/6.);}return hsv;}float sample_and_apply_sliders(SAMPLER_TYPE channel,vec2 vTexCoord,vec2 sliderValues){float fragIntensity=float(texture(channel,vTexCoord).r);float slidersAppliedToIntensity=(fragIntensity-sliderValues[0])/max(0.0005,(sliderValues[1]-sliderValues[0]));return max(0.0,slidersAppliedToIntensity);}vec3 process_channel_intensity(float intensity,vec3 colorValues,int channelIndex,bool inLensAndUseLens,int lensSelection){float useColorValue=float(int((inLensAndUseLens&&channelIndex==lensSelection)||(!inLensAndUseLens)));vec3 hsvCombo=rgb_to_hsv(max(vec3(colorValues),(1.0-useColorValue)*vec3(255,255,255)));hsvCombo=vec3(hsvCombo.xy,max(0.0,intensity));return hsv_to_rgb(hsvCombo);}vec4 apply_opacity(vec3 color,bool useTransparentColor,vec3 transparentColor,float opacity){return vec4(color,(color==transparentColor&&useTransparentColor)? 0.0 : opacity);}vec4 colormap(float intensity,float opacity,bool useTransparentColor){return apply_opacity(COLORMAP_FUNCTION(min(1.0,intensity)).xyz,useTransparentColor,COLORMAP_FUNCTION(0.0).xyz,opacity);}"; // eslint-disable-line

var channels = {
  name: 'channel-intensity-module',
  defines: {
    SAMPLER_TYPE: 'usampler2D',
    COLORMAP_FUNCTION: ''
  },
  fs
};

var fs$1 = "#define GLSLIFY 1\nbool frag_in_lens_bounds(vec2 lensCenter,vec2 vTexCoord,float majorLensAxis,float minorLensAxis,float lensBorderRadius){return pow((lensCenter.x-vTexCoord.x)/majorLensAxis,2.0)+pow((lensCenter.y-vTexCoord.y)/minorLensAxis,2.0)<(1.0-lensBorderRadius);}bool frag_on_lens_bounds(vec2 lensCenter,vec2 vTexCoord,float majorLensAxis,float minorLensAxis,float lensBorderRadius){float ellipseDistance=pow((lensCenter.x-vTexCoord.x)/majorLensAxis,2.0)+pow((lensCenter.y-vTexCoord.y)/minorLensAxis,2.0);return ellipseDistance<=1.0&&ellipseDistance>=(1.0-lensBorderRadius);}"; // eslint-disable-line

var lens = {
  name: 'lens-module',
  defines: {
    SAMPLER_TYPE: 'usampler2D'
  },
  fs: fs$1
};

const MAX_COLOR_INTENSITY = 255;

const DEFAULT_COLOR_OFF = [0, 0, 0];

const MAX_SLIDERS_AND_CHANNELS = 6;

const DEFAULT_FONT_FAMILY =
  "-apple-system, 'Helvetica Neue', Arial, sans-serif";

const DTYPE_VALUES = {
  '<u1': {
    format: GL.R8UI,
    dataFormat: GL.RED_INTEGER,
    type: GL.UNSIGNED_BYTE,
    max: 2 ** 8 - 1,
    TypedArray: Uint8Array
  },
  '<u2': {
    format: GL.R16UI,
    dataFormat: GL.RED_INTEGER,
    type: GL.UNSIGNED_SHORT,
    max: 2 ** 16 - 1,
    TypedArray: Uint16Array
  },
  '<u4': {
    format: GL.R32UI,
    dataFormat: GL.RED_INTEGER,
    type: GL.UNSIGNED_INT,
    max: 2 ** 32 - 1,
    TypedArray: Uint32Array
  },
  '<f4': {
    format: GL.R32F,
    dataFormat: GL.RED,
    type: GL.FLOAT,
    // Not sure what to do about this one - a good use case for channel stats, I suppose:
    // https://en.wikipedia.org/wiki/Single-precision_floating-point_format.
    max: 3.4 * 10 ** 38,
    TypedArray: Float32Array
  }
};

const GLOBAL_SLIDER_DIMENSION_FIELDS = ['z', 'time'];

function range(len) {
  return [...Array(len).keys()];
}

function padWithDefault(arr, defaultValue, padWidth) {
  for (let i = 0; i < padWidth; i += 1) {
    arr.push(defaultValue);
  }
  return arr;
}

function padColorsAndSliders({
  sliderValues,
  colorValues,
  channelIsOn,
  domain,
  dtype
}) {
  const lengths = [sliderValues.length, colorValues.length];
  if (lengths.every(l => l !== lengths[0])) {
    throw Error('Inconsistent number of slider values and colors provided');
  }

  const colors = colorValues.map((color, i) =>
    channelIsOn[i] ? color.map(c => c / MAX_COLOR_INTENSITY) : DEFAULT_COLOR_OFF
  );
  const maxSliderValue = (domain && domain[1]) || DTYPE_VALUES[dtype].max;
  const sliders = sliderValues.map((slider, i) =>
    channelIsOn[i] ? slider : [maxSliderValue, maxSliderValue]
  );
  // Need to pad sliders and colors with default values (required by shader)
  const padSize = MAX_SLIDERS_AND_CHANNELS - colors.length;
  if (padSize < 0) {
    throw Error(`${lengths} channels passed in, but only 6 are allowed.`);
  }

  const paddedColorValues = padWithDefault(colors, DEFAULT_COLOR_OFF, padSize);
  const paddedSliderValues = padWithDefault(
    sliders,
    [maxSliderValue, maxSliderValue],
    padSize
  );
  const paddedColorsAndSliders = {
    paddedSliderValues: paddedSliderValues.reduce(
      (acc, val) => acc.concat(val),
      []
    ), // flatten for use on shaders
    paddedColorValues: paddedColorValues.reduce(
      (acc, val) => acc.concat(val),
      []
    )
  };

  return paddedColorsAndSliders;
}

function to32BitFloat(data) {
  const data32bit = data.map(arr => {
    return new Float32Array(arr);
  });
  return data32bit;
}

function onPointer(layer) {
  const { viewportId, lensRadius } = layer.props;
  // If there is no viewportId, don't try to do anything.
  if (!viewportId) {
    layer.setState({ unprojectLensBounds: [0, 0, 0, 0] });
    return;
  }
  const { mousePosition } = layer.context;
  const layerView = layer.context.deck.viewManager.views.filter(
    view => view.id === viewportId
  )[0];
  const viewState = layer.context.deck.viewManager.viewState[viewportId];
  const viewport = layerView.makeViewport({
    ...viewState,
    viewState
  });
  // If the mouse is in the viewport and the mousePosition exists, set
  // the state with the bounding box of the circle that will render as a lens.
  if (mousePosition && viewport.containsPixel(mousePosition)) {
    const offsetMousePosition = {
      x: mousePosition.x - viewport.x,
      y: mousePosition.y - viewport.y
    };
    const mousePositionBounds = [
      // left
      [offsetMousePosition.x - lensRadius, offsetMousePosition.y],
      // bottom
      [offsetMousePosition.x, offsetMousePosition.y + lensRadius],
      // right
      [offsetMousePosition.x + lensRadius, offsetMousePosition.y],
      // top
      [offsetMousePosition.x, offsetMousePosition.y - lensRadius]
    ];
    // Unproject from screen to world coordinates.
    const unprojectLensBounds = mousePositionBounds.map(
      (bounds, i) => viewport.unproject(bounds)[i % 2]
    );
    layer.setState({ unprojectLensBounds });
  } else {
    layer.setState({ unprojectLensBounds: [0, 0, 0, 0] });
  }
}

function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }/* eslint-disable prefer-destructuring */

const SHADER_MODULES = [
  { fs: fs1, fscmap: fsColormap1, vs: vs1 },
  { fs: fs2, fscmap: fsColormap2, vs: vs2 }
];

function getShaderProps({ colormap, dtype }, gl) {
  const isWebGL1 = !isWebGL2(gl);
  const mod = isWebGL1 ? SHADER_MODULES[0] : SHADER_MODULES[1];
  return {
    fs: colormap ? mod.fscmap : mod.fs,
    vs: mod.vs,
    defines: {
      SAMPLER_TYPE: dtype === '<f4' || isWebGL1 ? 'sampler2D' : 'usampler2D',
      COLORMAP_FUNCTION: colormap || 'viridis'
    },
    modules: [project32, picking, channels, lens]
  };
}

const defaultProps = {
  pickable: true,
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  channelData: { type: 'object', value: {}, compare: true },
  bounds: { type: 'array', value: [0, 0, 1, 1], compare: true },
  colorValues: { type: 'array', value: [], compare: true },
  sliderValues: { type: 'array', value: [], compare: true },
  channelIsOn: { type: 'array', value: [], compare: true },
  opacity: { type: 'number', value: 1, compare: true },
  dtype: { type: 'string', value: '<u2', compare: true },
  colormap: { type: 'string', value: '', compare: true },
  isLensOn: { type: 'boolean', value: false, compare: true },
  lensSelection: { type: 'number', value: 0, compare: true },
  lensBorderColor: { type: 'array', value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: 'number', value: 0.02, compare: true },
  unprojectLensBounds: { type: 'array', value: [0, 0, 0, 0], compare: true },
  transparentColor: { type: 'array', value: null, compare: true }
};

/**
 * This layer serves as the workhorse of the project, handling all the rendering.  Much of it is
 * adapted from BitmapLayer in DeckGL.
 * XR = eXtended Range i.e more than the standard 8-bit RGBA data format
 * (16/32 bit floats/ints/uints with more than 3/4 channels).
 */
class XRLayer extends Layer {
  /**
   * This function chooses a shader (colormapping or not) and
   * replaces `usampler` with `sampler` if the data is not an unsigned integer
   */
  getShaders() {
    const shaderProps = getShaderProps(this.props, this.context.gl);
    return super.getShaders(shaderProps);
  }

  /**
   * This function initializes the internal state.
   */
  initializeState() {
    const { gl } = this.context;
    // This tells WebGL how to read row data from the texture.  For example, the default here is 4 (i.e for RGBA, one byte per channel) so
    // each row of data is expected to be a multiple of 4.  This setting (i.e 1) allows us to have non-multiple-of-4 row sizes.  For example, for 2 byte (16 bit data),
    // we could use 2 as the value and it would still work, but 1 also works fine (and is more flexible for 8 bit - 1 byte - textures as well).
    // https://stackoverflow.com/questions/42789896/webgl-error-arraybuffer-not-big-enough-for-request-in-case-of-gl-luminance
    gl.pixelStorei(GL.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(GL.PACK_ALIGNMENT, 1);
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: {
        size: 3,
        type: GL.DOUBLE,
        fp64: this.use64bitPositions(),
        update: this.calculatePositions,
        noAlloc: true
      }
    });
    this.setState({
      numInstances: 1,
      positions: new Float64Array(12)
    });
  }

  /**
   * This function finalizes state by clearing all textures from the WebGL context
   */
  finalizeState() {
    super.finalizeState();

    if (this.state.textures) {
      Object.values(this.state.textures).forEach(tex => tex && tex.delete());
    }
  }

  /**
   * This function updates state by retriggering model creation (shader compilation and attribute binding)
   * and loading any textures that need be loading.
   */
  updateState({ props, oldProps, changeFlags }) {
    // setup model first
    if (changeFlags.extensionsChanged || props.colormap !== oldProps.colormap) {
      const { gl } = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({ model: this._getModel(gl) });

      this.getAttributeManager().invalidateAll();
    }
    if (
      props.channelData !== oldProps.channelData &&
      _optionalChain([props, 'access', _ => _.channelData, 'optionalAccess', _2 => _2.data]) !== _optionalChain([oldProps, 'access', _3 => _3.channelData, 'optionalAccess', _4 => _4.data])
    ) {
      this.loadChannelTextures(props.channelData);
    }
    const attributeManager = this.getAttributeManager();
    if (props.bounds !== oldProps.bounds) {
      attributeManager.invalidate('positions');
    }
  }

  /**
   * This function creates the luma.gl model.
   */
  _getModel(gl) {
    if (!gl) {
      return null;
    }

    /*
       0,0 --- 1,0
        |       |
       0,1 --- 1,1
     */
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        drawMode: GL.TRIANGLE_FAN,
        vertexCount: 4,
        attributes: {
          texCoords: new Float32Array([0, 1, 0, 0, 1, 0, 1, 1])
        }
      }),
      isInstanced: false
    });
  }

  /**
   * This function generates view positions for use as a vec3 in the shader
   */
  calculatePositions(attributes) {
    const { positions } = this.state;
    const { bounds } = this.props;
    // bounds as [minX, minY, maxX, maxY]
    /*
      (minX0, maxY3) ---- (maxX2, maxY3)
             |                  |
             |                  |
             |                  |
      (minX0, minY1) ---- (maxX2, minY1)
   */
    positions[0] = bounds[0];
    positions[1] = bounds[1];
    positions[2] = 0;

    positions[3] = bounds[0];
    positions[4] = bounds[3];
    positions[5] = 0;

    positions[6] = bounds[2];
    positions[7] = bounds[3];
    positions[8] = 0;

    positions[9] = bounds[2];
    positions[10] = bounds[1];
    positions[11] = 0;

    // eslint-disable-next-line  no-param-reassign
    attributes.value = positions;
  }

  /**
   * This function runs the shaders and draws to the canvas
   */
  draw({ uniforms }) {
    const { textures, model } = this.state;
    if (textures && model) {
      const {
        sliderValues,
        colorValues,
        opacity,
        domain,
        dtype,
        channelIsOn,
        unprojectLensBounds,
        bounds,
        isLensOn,
        lensSelection,
        lensBorderColor,
        lensBorderRadius,
        transparentColor
      } = this.props;
      // Check number of textures not null.
      const numTextures = Object.values(textures).filter(t => t).length;
      // Slider values and color values can come in before textures since their data is async.
      // Thus we pad based on the number of textures bound.
      const { paddedSliderValues, paddedColorValues } = padColorsAndSliders({
        sliderValues: sliderValues.slice(0, numTextures),
        colorValues: colorValues.slice(0, numTextures),
        channelIsOn: channelIsOn.slice(0, numTextures),
        domain,
        dtype
      });
      // Creating a unit-square scaled intersection box for rendering the lens.
      // It is ok if these coordinates are outside the unit square since
      // we check membership in or out of the lens on the fragment shader.
      const [
        leftMouseBound,
        bottomMouseBound,
        rightMouseBound,
        topMouseBound
      ] = unprojectLensBounds;
      const [left, bottom, right, top] = bounds;
      const leftMouseBoundScaled = (leftMouseBound - left) / (right - left);
      const bottomMouseBoundScaled = (bottomMouseBound - top) / (bottom - top);
      const rightMouseBoundScaled = (rightMouseBound - left) / (right - left);
      const topMouseBoundScaled = (topMouseBound - top) / (bottom - top);
      model
        .setUniforms({
          ...uniforms,
          colorValues: paddedColorValues,
          sliderValues: paddedSliderValues,
          opacity,
          majorLensAxis: (rightMouseBoundScaled - leftMouseBoundScaled) / 2,
          minorLensAxis: (bottomMouseBoundScaled - topMouseBoundScaled) / 2,
          lensCenter: [
            (rightMouseBoundScaled + leftMouseBoundScaled) / 2,
            (bottomMouseBoundScaled + topMouseBoundScaled) / 2
          ],
          isLensOn,
          lensSelection,
          lensBorderColor,
          lensBorderRadius,
          transparentColor: (transparentColor || [0, 0, 0]).map(i => i / 255),
          useTransparentColor: Boolean(transparentColor),
          ...textures
        })
        .draw();
    }
  }

  /**
   * This function loads all channel textures from incoming resolved promises/data from the loaders by calling `dataToTexture`
   */
  loadChannelTextures(channelData) {
    const textures = {
      channel0: null,
      channel1: null,
      channel2: null,
      channel3: null,
      channel4: null,
      channel5: null
    };
    if (this.state.textures) {
      Object.values(this.state.textures).forEach(tex => tex && tex.delete());
    }
    if (
      channelData &&
      Object.keys(channelData).length > 0 &&
      channelData.data
    ) {
      channelData.data.forEach((d, i) => {
        textures[`channel${i}`] = this.dataToTexture(
          d,
          channelData.width,
          channelData.height
        );
      }, this);
      this.setState({ textures });
    }
  }

  /**
   * This function creates textures from the data
   */
  dataToTexture(data, width, height) {
    const { gl } = this.context;
    const noWebGL2 = !isWebGL2(gl);
    const { dtype } = this.props;
    const { format, dataFormat, type } = DTYPE_VALUES[dtype];
    const texture = new Texture2D(this.context.gl, {
      width,
      height,
      data,
      // we don't want or need mimaps
      mipmaps: false,
      parameters: {
        // NEAREST for integer data
        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,
        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,
        // CLAMP_TO_EDGE to remove tile artifacts
        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,
        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE
      },
      format: noWebGL2 ? GL.LUMINANCE : format,
      dataFormat: noWebGL2 ? GL.LUMINANCE : dataFormat,
      type: noWebGL2 ? GL.FLOAT : type
    });
    return texture;
  }
}

XRLayer.layerName = 'XRLayer';
XRLayer.defaultProps = defaultProps;

// eslint-disable-next-line max-classes-per-file

const PHOTOMETRIC_INTERPRETATIONS = {
  WhiteIsZero: 0,
  BlackIsZero: 1,
  RGB: 2,
  Palette: 3,
  TransparencyMask: 4,
  CMYK: 5,
  YCbCr: 6,
  CIELab: 8,
  ICCLab: 9
};

const defaultProps$1 = {
  ...BitmapLayer$1.defaultProps,
  pickable: true,
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  bounds: { type: 'array', value: [0, 0, 1, 1], compare: true },
  opacity: { type: 'number', value: 1, compare: true }
};

const getPhotometricInterpretationShader = (
  photometricInterpretation,
  tansparentColorInHook
) => {
  const useTransparentColor = tansparentColorInHook ? 'true' : 'false';
  const transparentColorVector = `vec3(${(tansparentColorInHook || [0, 0, 0])
    .map(i => String(i / 255))
    .join(',')})`;
  switch (photometricInterpretation) {
    case PHOTOMETRIC_INTERPRETATIONS.RGB:
      return `color[3] = (${useTransparentColor} && (color.rgb == ${transparentColorVector})) ? 0.0 : color.a;`;
    case PHOTOMETRIC_INTERPRETATIONS.WhiteIsZero:
      return `\
          float value = 1.0 - (color.r / 256.0);
          color = vec4(value, value, value, (${useTransparentColor} && vec3(value, value, value) == ${transparentColorVector}) ? 0.0 : color.a);
        `;
    case PHOTOMETRIC_INTERPRETATIONS.BlackIsZero:
      return `\
          float value = (color.r / 256.0);
          color = vec4(value, value, value, (${useTransparentColor} && vec3(value, value, value) == ${transparentColorVector}) ? 0.0 : color.a);
        `;
    case PHOTOMETRIC_INTERPRETATIONS.YCbCr:
      // We need to use an epsilon because the conversion to RGB is not perfect.
      return `\
          float y = color[0];
          float cb = color[1];
          float cr = color[2];
          color[0] = (y + (1.40200 * (cr - .5)));
          color[1] = (y - (0.34414 * (cb - .5)) - (0.71414 * (cr - .5)));
          color[2] = (y + (1.77200 * (cb - .5)));
          color[3] = (${useTransparentColor} && distance(color.rgb, ${transparentColorVector}) < 0.01) ? 0.0 : color.a;
        `;
    default:
      console.error(
        'Unsupported photometric interpretation or none provided.  No transformation will be done to image data'
      );
      return '';
  }
};

const getTransparentColor = photometricInterpretation => {
  switch (photometricInterpretation) {
    case PHOTOMETRIC_INTERPRETATIONS.RGB:
      return [0, 0, 0, 0];
    case PHOTOMETRIC_INTERPRETATIONS.WhiteIsZero:
      return [255, 255, 255, 0];
    case PHOTOMETRIC_INTERPRETATIONS.BlackIsZero:
      return [0, 0, 0, 0];
    case PHOTOMETRIC_INTERPRETATIONS.YCbCr:
      return [16, 128, 128, 0];
    default:
      console.error(
        'Unsupported photometric interpretation or none provided.  No transformation will be done to image data'
      );
      return [0, 0, 0, 0];
  }
};

class BitmapLayerWrapper extends BitmapLayer$1 {
  _getModel(gl) {
    const { photometricInterpretation, tansparentColorInHook } = this.props;
    // This is a port to the GPU of a subset of https://github.com/geotiffjs/geotiff.js/blob/master/src/rgb.js
    // Safari was too slow doing this off of the GPU and it is noticably faster on other browsers as well.
    const photometricInterpretationShader = getPhotometricInterpretationShader(
      photometricInterpretation,
      tansparentColorInHook
    );
    if (!gl) {
      return null;
    }

    /*
      0,0 --- 1,0
       |       |
      0,1 --- 1,1
    */
    return new Model(gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new Geometry({
        drawMode: GL.TRIANGLES,
        vertexCount: 6
      }),
      isInstanced: false,
      inject: {
        'fs:DECKGL_FILTER_COLOR': photometricInterpretationShader
      }
    });
  }
}
class BitmapLayer extends CompositeLayer {
  initializeState(args) {
    const { gl } = this.context;
    // This tells WebGL how to read row data from the texture.  For example, the default here is 4 (i.e for RGBA, one byte per channel) so
    // each row of data is expected to be a multiple of 4.  This setting (i.e 1) allows us to have non-multiple-of-4 row sizes.  For example, for 2 byte (16 bit data),
    // we could use 2 as the value and it would still work, but 1 also works fine (and is more flexible for 8 bit - 1 byte - textures as well).
    // https://stackoverflow.com/questions/42789896/webgl-error-arraybuffer-not-big-enough-for-request-in-case-of-gl-luminance
    // This needs to be called here and not in the BitmapLayerWrapper because the `image` prop is converted to a texture outside of the layer, as controlled by the `image` type.
    // See: https://github.com/visgl/deck.gl/pull/5197
    gl.pixelStorei(GL.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(GL.PACK_ALIGNMENT, 1);
    super.initializeState(args);
  }

  renderLayers() {
    const {
      photometricInterpretation,
      transparentColor: tansparentColorInHook
    } = this.props;
    const transparentColor = getTransparentColor(photometricInterpretation);
    return new BitmapLayerWrapper(this.props, {
      // transparentColor is a prop applied to the original image data by deck.gl's
      // BitmapLayer and needs to be in the original colorspace.  It is used to determine
      // what color is "transparent" in the original color space (i.e what shows when opacity is 0).
      transparentColor,
      // This is our transparentColor props which needs to be applied in the hook that converts to the RGB space.
      tansparentColorInHook,
      id: `${this.props.id}-wrapped`
    });
  }
}

BitmapLayer.layerName = 'BitmapLayer';
// From https://github.com/geotiffjs/geotiff.js/blob/8ef472f41b51d18074aece2300b6a8ad91a21ae1/src/globals.js#L202-L213
BitmapLayer.PHOTOMETRIC_INTERPRETATIONS = PHOTOMETRIC_INTERPRETATIONS;
BitmapLayer.defaultProps = {
  ...defaultProps$1,
  // We don't want this layer to bind the texture so the type should not be `image`.
  image: { type: 'object', value: {}, compare: true }
};
BitmapLayerWrapper.defaultProps = defaultProps$1;
BitmapLayerWrapper.layerName = 'BitmapLayerWrapper';

function renderSubLayers(props) {
  const {
    bbox: { left, top, right, bottom },
    x,
    y,
    z
  } = props.tile;
  const {
    colorValues,
    sliderValues,
    channelIsOn,
    visible,
    opacity,
    data,
    colormap,
    dtype,
    id,
    onHover,
    pickable,
    unprojectLensBounds,
    isLensOn,
    lensSelection,
    onClick,
    loader,
    modelMatrix
  } = props;
  // Only render in positive coorinate system
  if ([left, bottom, right, top].some(v => v < 0) || !data) {
    return null;
  }
  const { height, width } = loader.getRasterSize({ z: 0 });
  // Tiles are exactly fitted to have height and width such that their bounds match that of the actual image (not some padded version).
  // Thus the right/bottom given by deck.gl are incorrect since they assume tiles are of uniform sizes, which is not the case for us.
  const bounds = [
    left,
    data.height < loader.tileSize ? height : bottom,
    data.width < loader.tileSize ? width : right,
    top
  ];
  const { isRgb, isInterleaved, photometricInterpretation } = loader;
  if (isRgb && isInterleaved) {
    return new BitmapLayer(props, {
      image: data,
      photometricInterpretation,
      // Shared props with XRLayer:
      bounds,
      id: `tile-sub-layer-${bounds}-${id}`,
      tileId: { x, y, z },
      onHover,
      pickable,
      onClick,
      modelMatrix,
      opacity,
      visible
    });
  }
  return new XRLayer(props, {
    channelData: data,
    // Uncomment to help debugging - shades the tile being hovered over.
    // autoHighlight: true,
    // highlightColor: [80, 80, 80, 50],
    data: null,
    sliderValues,
    colorValues,
    channelIsOn,
    dtype,
    colormap,
    unprojectLensBounds,
    isLensOn,
    lensSelection,
    // Shared props with BitmapLayer:
    bounds,
    id: `tile-sub-layer-${bounds}-${id}`,
    tileId: { x, y, z },
    onHover,
    pickable,
    onClick,
    modelMatrix,
    opacity,
    visible
  });
}

const defaultProps$2 = {
  pickable: true,
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  sliderValues: { type: 'array', value: [], compare: true },
  colorValues: { type: 'array', value: [], compare: true },
  channelIsOn: { type: 'array', value: [], compare: true },
  minZoom: { type: 'number', value: 0, compare: true },
  maxZoom: { type: 'number', value: 0, compare: true },
  renderSubLayers: { type: 'function', value: renderSubLayers, compare: false },
  opacity: { type: 'number', value: 1, compare: true },
  colormap: { type: 'string', value: '', compare: true },
  dtype: { type: 'string', value: '<u2', compare: true },
  domain: { type: 'array', value: [], compare: true },
  viewportId: { type: 'string', value: '', compare: true },
  unprojectLensBounds: { type: 'array', value: [0, 0, 0, 0], compare: true },
  isLensOn: { type: 'boolean', value: false, compare: true },
  lensSelection: { type: 'number', value: 0, compare: true },
  lensRadius: { type: 'number', value: 100, compare: true },
  lensBorderColor: { type: 'array', value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: 'number', value: 0.02, compare: true },
  transparentColor: { type: 'array', value: null, compare: true }
};

/**
 * This layer serves as a proxy of sorts to the rendering done in renderSubLayers, reacting to viewport changes in a custom manner.
 */
class MultiscaleImageLayerBase extends TileLayer {
  /**
   * This function allows us to controls which viewport gets to update the Tileset2D.
   * This is a uniquely TileLayer issue since it updates based on viewport updates thanks
   * to its ability to handle zoom-pan loading.  Essentially, with a picture-in-picture,
   * this prevents it from detecting the update of some other viewport that is unwanted.
   */
  _updateTileset() {
    if (!this.props.viewportId) {
      super._updateTileset();
    }
    if (
      (this.props.viewportId &&
        this.context.viewport.id === this.props.viewportId) ||
      // I don't know why, but DeckGL doesn't recognize multiple views on the first pass
      // so we force update on the first pass by checking if there is a viewport in the tileset.
      !this.state.tileset._viewport
    ) {
      super._updateTileset();
    }
  }
}

MultiscaleImageLayerBase.layerName = 'MultiscaleImageLayerBase';
MultiscaleImageLayerBase.defaultProps = defaultProps$2;

const defaultProps$3 = {
  pickable: true,
  coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
  sliderValues: { type: 'array', value: [], compare: true },
  channelIsOn: { type: 'array', value: [], compare: true },
  colorValues: { type: 'array', value: [], compare: true },
  loaderSelection: { type: 'array', value: [], compare: true },
  colormap: { type: 'string', value: '', compare: true },
  domain: { type: 'array', value: [], compare: true },
  viewportId: { type: 'string', value: '', compare: true },
  loader: {
    type: 'object',
    value: {
      getRaster: async () => ({ data: [], height: 0, width: 0 }),
      dtype: '<u2'
    },
    compare: true
  },
  z: { type: 'number', value: 0, compare: true },
  isLensOn: { type: 'boolean', value: false, compare: true },
  lensSelection: { type: 'number', value: 0, compare: true },
  lensRadius: { type: 'number', value: 100, compare: true },
  lensBorderColor: { type: 'array', value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: 'number', value: 0.02, compare: true },
  onClick: { type: 'function', value: null, compare: true },
  transparentColor: { type: 'array', value: null, compare: true }
};

/**
 * This layer wraps XRLayer and generates a static image
 * @param {Object} props
 * @param {Array} props.sliderValues List of [begin, end] values to control each channel's ramp function.
 * @param {Array} props.colorValues List of [r, g, b] values for each channel.
 * @param {Array} props.channelIsOn List of boolean values for each channel for whether or not it is visible.
 * @param {number} props.opacity Opacity of the layer.
 * @param {string} props.colormap String indicating a colormap (default: '').  The full list of options is here: https://github.com/glslify/glsl-colormap#glsl-colormap
 * @param {Array} props.domain Override for the possible max/min values (i.e something different than 65535 for uint16/'<u2').
 * @param {string} props.viewportId Id for the current view.  This needs to match the viewState id in deck.gl and is necessary for the lens.
 * @param {Object} props.loader Loader to be used for fetching data.  It must implement/return `getRaster` and `dtype`.
 * @param {function} props.onHover Hook function from deck.gl to handle hover objects.
 * @param {boolean} props.isLensOn Whether or not to use the lens.
 * @param {number} props.lensSelection Numeric index of the channel to be focused on by the lens.
 * @param {number} props.lensRadius Pixel radius of the lens (default: 100).
 * @param {Array} props.lensBorderColor RGB color of the border of the lens.
 * @param {number} props.lensBorderRadius Percentage of the radius of the lens for a border (default 0.02).
 * @param {function} props.onClick Hook function from deck.gl to handle clicked-on objects.
 * @param {Object} props.modelMatrix Math.gl Matrix4 object containing an affine transformation to be applied to the image.
 * @param {Array} props.transparentColor An RGB (0-255 range) color to be considered "transparent" if provided.
 * In other words, any fragment shader output equal transparentColor (before applying opacity) will have opacity 0.
 * This parameter only needs to be a truthy value when using colormaps because each colormap has its own transparent color that is calculated on the shader.
 * Thus setting this to a truthy value (with a colormap set) indicates that the shader should make that color transparent.
 */
class ImageLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      unprojectLensBounds: [0, 0, 0, 0],
      width: 0,
      height: 0,
      data: []
    };
    if (this.context.deck) {
      this.context.deck.eventManager.on({
        pointermove: () => onPointer(this),
        pointerleave: () => onPointer(this),
        wheel: () => onPointer(this)
      });
    }
  }

  updateState({ changeFlags, props, oldProps }) {
    const { propsChanged } = changeFlags;
    const loaderChanged =
      typeof propsChanged === 'string' && propsChanged.includes('props.loader');
    const loaderSelectionChanged =
      props.loaderSelection !== oldProps.loaderSelection;
    if (loaderChanged || loaderSelectionChanged) {
      // Only fetch new data to render if loader has changed
      const { loader, z, loaderSelection } = this.props;
      loader.getRaster({ z, loaderSelection }).then(raster => {
        /* eslint-disable no-param-reassign */
        if (loader.isInterleaved && loader.isRgb) {
          // data is for BitmapLayer and needs to be of form { data: Uint8Array, width, height };
          // eslint-disable-next-line prefer-destructuring
          raster.data = raster.data[0];
          if (raster.data.length === raster.width * raster.height * 3) {
            // data is RGB (not RGBA) and need to update texture formats
            raster.format = GL.RGB;
            raster.dataFormat = GL.RGB;
          }
        } else if (!isWebGL2(this.context.gl)) {
          // data is for XLRLayer in non-WebGL2 evironment
          // we need to convert data to compatible textures
          raster.data = to32BitFloat(raster.data);
        }
        this.setState({ ...raster });
        /* eslint-disable no-param-reassign */
      });
    }
  }

  // eslint-disable-next-line class-methods-use-this
  getPickingInfo({ info, sourceLayer }) {
    // eslint-disable-next-line no-param-reassign
    info.sourceLayer = sourceLayer;
    // eslint-disable-next-line no-param-reassign
    info.tile = sourceLayer.props.tile;
    return info;
  }

  renderLayers() {
    const {
      loader,
      visible,
      opacity,
      colormap,
      sliderValues,
      colorValues,
      channelIsOn,
      z,
      domain,
      pickable,
      isLensOn,
      lensSelection,
      lensBorderColor,
      lensRadius,
      id,
      onClick,
      onHover,
      modelMatrix,
      transparentColor
    } = this.props;
    const { dtype } = loader;
    const { width, height, data, unprojectLensBounds } = this.state;
    if (!(width && height)) return null;
    const bounds = [0, height, width, 0];
    const { isRgb, isInterleaved, photometricInterpretation } = loader;
    if (isRgb && isInterleaved) {
      return new BitmapLayer(this.props, {
        image: this.state,
        photometricInterpretation,
        // Shared props with XRLayer:
        bounds,
        id: `image-sub-layer-${bounds}-${id}-${z}`,
        onHover,
        pickable,
        onClick,
        modelMatrix,
        opacity,
        visible
      });
    }
    return new XRLayer(this.props, {
      channelData: { data, height, width },
      sliderValues,
      colorValues,
      channelIsOn,
      domain,
      dtype,
      colormap,
      unprojectLensBounds,
      isLensOn,
      lensSelection,
      lensBorderColor,
      lensRadius,
      // Shared props with BitmapLayer:
      bounds,
      id: `image-sub-layer-${bounds}-${id}-${z}`,
      onHover,
      pickable,
      onClick,
      modelMatrix,
      opacity,
      visible,
      transparentColor
    });
  }
}

ImageLayer.layerName = 'ImageLayer';
ImageLayer.defaultProps = defaultProps$3;

// From https://github.com/visgl/deck.gl/pull/4616/files#diff-4d6a2e500c0e79e12e562c4f1217dc80R128
const DECK_GL_TILE_SIZE = 512;

const defaultProps$4 = {
  pickable: true,
  onHover: { type: 'function', value: null, compare: false },
  sliderValues: { type: 'array', value: [], compare: true },
  colorValues: { type: 'array', value: [], compare: true },
  channelIsOn: { type: 'array', value: [], compare: true },
  opacity: { type: 'number', value: 1, compare: true },
  colormap: { type: 'string', value: '', compare: true },
  domain: { type: 'array', value: [], compare: true },
  viewportId: { type: 'string', value: '', compare: true },
  isLensOn: { type: 'boolean', value: false, compare: true },
  lensSelection: { type: 'number', value: 0, compare: true },
  lensRadius: { type: 'number', value: 100, compare: true },
  lensBorderColor: { type: 'array', value: [255, 255, 255], compare: true },
  lensBorderRadius: { type: 'number', value: 0.02, compare: true },
  maxRequests: { type: 'number', value: 10, compare: true },
  onClick: { type: 'function', value: null, compare: true },
  transparentColor: { type: 'array', value: null, compare: true },
  refinementStrategy: { type: 'string', value: null, compare: true },
  excludeBackground: { type: 'boolean', value: false, compare: true }
};

/**
 * This layer generates a MultiscaleImageLayer (tiled) and a ImageLayer (background for the tiled layer)
 * @param {Object} props
 * @param {Array} props.sliderValues List of [begin, end] values to control each channel's ramp function.
 * @param {Array} props.colorValues List of [r, g, b] values for each channel.
 * @param {Array} props.channelIsOn List of boolean values for each channel for whether or not it is visible.
 * @param {number} props.opacity Opacity of the layer.
 * @param {string} props.colormap String indicating a colormap (default: '').  The full list of options is here: https://github.com/glslify/glsl-colormap#glsl-colormap
 * @param {Array} props.domain Override for the possible max/min values (i.e something different than 65535 for uint16/'<u2').
 * @param {string} props.viewportId Id for the current view.  This needs to match the viewState id in deck.gl and is necessary for the lens.
 * @param {Object} props.loader Loader to be used for fetching data.  It must implement/return `getTile`, `dtype`, `numLevels`, and `tileSize`, and `getRaster`.
 * @param {Array} props.loaderSelection Selection to be used for fetching data.
 * @param {String} props.id Unique identifier for this layer.
 * @param {function} props.onTileError Custom override for handle tile fetching errors.
 * @param {function} props.onHover Hook function from deck.gl to handle hover objects.
 * @param {boolean} props.isLensOn Whether or not to use the lens.
 * @param {number} props.lensSelection Numeric index of the channel to be focused on by the lens.
 * @param {number} props.lensRadius Pixel radius of the lens (default: 100).
 * @param {Array} props.lensBorderColor RGB color of the border of the lens (default [255, 255, 255]).
 * @param {number} props.lensBorderRadius Percentage of the radius of the lens for a border (default 0.02).
 * @param {number} props.maxRequests Maximum parallel ongoing requests allowed before aborting.
 * @param {function} props.onClick Hook function from deck.gl to handle clicked-on objects.
 * @param {Object} props.modelMatrix Math.gl Matrix4 object containing an affine transformation to be applied to the image.
 * @param {Array} props.transparentColor An RGB (0-255 range) color to be considered "transparent" if provided.
 * In other words, any fragment shader output equal transparentColor (before applying opacity) will have opacity 0.
 * This parameter only needs to be a truthy value when using colormaps because each colormap has its own transparent color that is calculated on the shader.
 * Thus setting this to a truthy value (with a colormap set) indicates that the shader should make that color transparent.
 * @param {string} props.refinementStrategy 'best-available' | 'no-overlap' | 'never' will be passed to TileLayer. A default will be chosen based on opacity.
 * @param {boolean} props.excludeBackground Whether to exclude the background image. The background image is also excluded for opacity!=1.
 */

class MultiscaleImageLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      unprojectLensBounds: [0, 0, 0, 0]
    };
    if (this.context.deck) {
      this.context.deck.eventManager.on({
        pointermove: () => onPointer(this),
        pointerleave: () => onPointer(this),
        wheel: () => onPointer(this)
      });
    }
  }

  renderLayers() {
    const {
      loader,
      sliderValues,
      colorValues,
      channelIsOn,
      loaderSelection,
      domain,
      opacity,
      colormap,
      viewportId,
      onTileError,
      onHover,
      pickable,
      id,
      isLensOn,
      lensSelection,
      lensBorderColor,
      lensBorderRadius,
      maxRequests,
      onClick,
      modelMatrix,
      transparentColor,
      excludeBackground,
      onViewportLoad,
      refinementStrategy
    } = this.props;
    const { tileSize, numLevels, dtype, isInterleaved, isRgb } = loader;
    const { unprojectLensBounds } = this.state;
    // This is basically to invert:
    // https://github.com/visgl/deck.gl/pull/4616/files#diff-4d6a2e500c0e79e12e562c4f1217dc80R128
    // The z level can be wrong for showing the correct scales because of the calculation deck.gl does
    // so we need to invert it for fetching tiles and minZoom/maxZoom.
    const zoomOffset = Math.log2(DECK_GL_TILE_SIZE / tileSize);
    const noWebGl2 = !isWebGL2(this.context.gl);
    const getTileData = async ({ x, y, z, signal }) => {
      const tile = await loader.getTile({
        x,
        y,
        // See the above note within for why the use of zoomOffset and the rounding necessary.
        z: Math.round(-z + zoomOffset),
        loaderSelection,
        signal
      });
      if (isInterleaved && isRgb) {
        // eslint-disable-next-line prefer-destructuring
        tile.data = tile.data[0];
        if (tile.data.length === tile.width * tile.height * 3) {
          tile.format = GL.RGB;
          tile.dataFormat = GL.RGB; // is this not properly inferred?
        }
        // can just return early, no need  to check for webgl2
        return tile;
      }
      if (noWebGl2) {
        tile.data = to32BitFloat(tile.data);
      }
      return tile;
    };
    const { height, width } = loader.getRasterSize({ z: 0 });
    const tiledLayer = new MultiscaleImageLayerBase(this.props, {
      id: `Tiled-Image-${id}`,
      getTileData,
      dtype,
      // If you scale a matrix up or down, that is like zooming in or out.  After
      // https://github.com/visgl/deck.gl/pull/4616/files#diff-4d6a2e500c0e79e12e562c4f1217dc80R128,
      // tileSize controls the zoom level that the tile indexer thinks you are at for fetching tiles.
      // Because the indexing offsets `z` by math.log2(TILE_SIZE / tileSize), passing in
      // tileSize * (1 / modelMatrix.getScale()[0]) from this layer as below to TileLayer gives an offset of
      // math.log2(TILE_SIZE / (tileSize * (1 / modelMatrix.getScale()[0]))) = math.log2(TILE_SIZE / tileSize) + Math.log2(modelMatrix.getScale()[0])
      // as desired so that the z level used for indexing the tiles is larger (i.e more zoomed in) if the image is scaled larger, and vice-versa if scaled smaller.
      tileSize: modelMatrix
        ? tileSize * (1 / modelMatrix.getScale()[0])
        : tileSize,
      onClick,
      extent: [0, 0, width, height],
      // See the above note within for why the use of zoomOffset and the rounding necessary.
      minZoom: Math.round(-(numLevels - 1) + zoomOffset),
      maxZoom: Math.round(zoomOffset),
      colorValues,
      sliderValues,
      channelIsOn,
      maxRequests,
      domain,
      // We want a no-overlap caching strategy with an opacity < 1 to prevent
      // multiple rendered sublayers (some of which have been cached) from overlapping
      refinementStrategy:
        refinementStrategy || (opacity === 1 ? 'best-available' : 'no-overlap'),
      // TileLayer checks `changeFlags.updateTriggersChanged.getTileData` to see if tile cache
      // needs to be re-created. We want to trigger this behavior if the loader changes.
      // https://github.com/uber/deck.gl/blob/3f67ea6dfd09a4d74122f93903cb6b819dd88d52/modules/geo-layers/src/tile-layer/tile-layer.js#L50
      updateTriggers: {
        getTileData: [loader, loaderSelection]
      },
      onTileError: onTileError || loader.onTileError,
      opacity,
      colormap,
      viewportId,
      onHover,
      pickable,
      unprojectLensBounds,
      isLensOn,
      lensSelection,
      lensBorderColor,
      lensBorderRadius,
      modelMatrix,
      transparentColor,
      onViewportLoad
    });
    // This gives us a background image and also solves the current
    // minZoom funny business.  We don't use it for the background if we have an opacity
    // paramteter set to anything but 1, but we always use it for situations where
    // we are zoomed out too far.
    const implementsGetRaster = typeof loader.getRaster === 'function';
    const layerModelMatrix = modelMatrix ? modelMatrix.clone() : new Matrix4();
    const baseLayer =
      implementsGetRaster &&
      !excludeBackground &&
      new ImageLayer(this.props, {
        id: `Background-Image-${id}`,
        modelMatrix: layerModelMatrix.scale(2 ** (numLevels - 1)),
        visible:
          opacity === 1 &&
          (!viewportId || this.context.viewport.id === viewportId) &&
          // If we are using a transparent color, we shouldn't show the background image
          // since the background image might not have the same color output from the fragment shader
          // as the tiled layer at a higher resolution level.
          !transparentColor,
        z: numLevels - 1,
        pickable: true,
        onHover,
        onClick
      });
    const layers = [baseLayer, tiledLayer];
    return layers;
  }
}

MultiscaleImageLayer.layerName = 'MultiscaleImageLayer';
MultiscaleImageLayer.defaultProps = defaultProps$4;

const defaultProps$5 = {
  pickable: true,
  loader: {
    type: 'object',
    value: {
      getRaster: async () => ({ data: [], height: 0, width: 0 }),
      getRasterSize: () => ({ height: 0, width: 0 }),
      dtype: '<u2'
    },
    compare: true
  },
  id: { type: 'string', value: '', compare: true },
  boundingBox: {
    type: 'array',
    value: [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ],
    compare: true
  },
  boundingBoxColor: { type: 'array', value: [255, 0, 0], compare: true },
  boundingBoxOutlineWidth: { type: 'number', value: 1, compare: true },
  viewportOutlineColor: { type: 'array', value: [255, 190, 0], compare: true },
  viewportOutlineWidth: { type: 'number', value: 2, compare: true },
  overviewScale: { type: 'number', value: 1, compare: true },
  zoom: { type: 'number', value: 1, compare: true }
};

/**
 * This layer wraps a ImageLayer as an overview, as well as a bounding box of the detail view and a polygon boundary for the view
 * @param {Object} props
 * @param {Array} props.sliderValues List of [begin, end] values to control each channel's ramp function.
 * @param {Array} props.colorValues List of [r, g, b] values for each channel.
 * @param {Array} props.channelIsOn List of boolean values for each channel for whether or not it is visible.
 * @param {number} props.opacity Opacity of the layer.
 * @param {string} props.colormap String indicating a colormap (default: '').  The full list of options is here: https://github.com/glslify/glsl-colormap#glsl-colormap
 * @param {Array} props.domain Override for the possible max/min values (i.e something different than 65535 for uint16/'<u2').
 * @param {Object} props.loader Loader to be used for fetching data.  It must implement/return `getRaster` and `dtype`.
 * @param {Array} props.boundingBoxColor [r, g, b] color of the bounding box (default: [255, 0, 0]).
 * @param {number} props.boundingBoxOutlineWidth Width of the bounding box in px (default: 1).
 * @param {Array} props.viewportOutlineColor [r, g, b] color of the outline (default: [255, 190, 0]).
 * @param {number} props.viewportOutlineWidth Viewport outline width in px (default: 2).
 */
class OverviewLayer extends CompositeLayer {
  renderLayers() {
    const {
      loader,
      id,
      zoom,
      boundingBox,
      boundingBoxColor,
      boundingBoxOutlineWidth,
      viewportOutlineColor,
      viewportOutlineWidth,
      overviewScale
    } = this.props;
    const { numLevels } = loader;
    const { width, height } = loader.getRasterSize({
      z: 0
    });
    const overview = new ImageLayer(this.props, {
      id: `viewport-${id}`,
      modelMatrix: new Matrix4().scale(2 ** (numLevels - 1) * overviewScale),
      z: numLevels - 1
    });
    const boundingBoxOutline = new PolygonLayer({
      id: `bounding-box-overview-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [boundingBox],
      getPolygon: f => f,
      filled: false,
      stroked: true,
      getLineColor: boundingBoxColor,
      getLineWidth: boundingBoxOutlineWidth * 2 ** zoom
    });
    const viewportOutline = new PolygonLayer({
      id: `viewport-outline-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [0, 0],
          [width * overviewScale, 0],
          [width * overviewScale, height * overviewScale],
          [0, height * overviewScale]
        ]
      ],
      getPolygon: f => f,
      filled: false,
      stroked: true,
      getLineColor: viewportOutlineColor,
      getLineWidth: viewportOutlineWidth * 2 ** zoom
    });
    const layers = [overview, boundingBoxOutline, viewportOutline];
    return layers;
  }
}

OverviewLayer.layerName = 'OverviewLayer';
OverviewLayer.defaultProps = defaultProps$5;

function getVivId(id) {
  return `-#${id}#`;
}
/**
 * Create a boudning box from a viewport based on passed-in viewState.
 * @param {viewState} Object The viewState for a certain viewport.
 * @returns {View} The DeckGL View for this viewport.
 */
function makeBoundingBox(viewState) {
  const viewport = new OrthographicView().makeViewport({
    // From the current `detail` viewState, we need its projection matrix (actually the inverse).
    viewState,
    height: viewState.height,
    width: viewState.width
  });
  // Use the inverse of the projection matrix to map screen to the view space.
  return [
    viewport.unproject([0, 0]),
    viewport.unproject([viewport.width, 0]),
    viewport.unproject([viewport.width, viewport.height]),
    viewport.unproject([0, viewport.height])
  ];
}

/**
 * Create an initial view state that centers the image in the viewport at the zoom level that fills the dimensions in `viewSize`.
 * @param {Object} loader The loader of the image for which the view state is desired.
 * @param {Object} viewSize { height, width } object giving dimensions of the viewport for deducing the right zoom level to center the image.
 * @param {Object} zoomBackOff A positive number which controls how far zoomed out the view state is from filling the entire viewport (default is 0 so the image fully fills the view).
 * SideBySideViewer and PictureInPictureViewer use .5 when setting viewState automatically in their default behavior, so the viewport is slightly zoomed out from the image
 * filling the whole screen.  1 unit of zoomBackOff (so a passed-in value of 1) corresponds to a 2x zooming out.
 * @returns {ViewState} A default initial view state that centers the image within the view: { target: [x, y, 0], zoom: -zoom }.
 */
function getDefaultInitialViewState(loader, viewSize, zoomBackOff = 0) {
  const { height, width } = loader.getRasterSize({
    z: 0
  });
  const zoom =
    Math.log2(Math.min(viewSize.width / width, viewSize.height / height)) -
    zoomBackOff;
  const loaderInitialViewState = {
    target: [width / 2, height / 2, 0],
    zoom
  };
  return loaderInitialViewState;
}

/**
 * Creates the layers for viewing an image in detail.
 * @param {string} id The identifier of the view.
 * @param {Object} props The layer properties.
 * @returns {Array} An array of layers.
 */
function getImageLayers(id, props) {
  const {
    loaderSelection,
    newLoaderSelection,
    onViewportLoad,
    transitionFields,
    ...layerProps
  } = props;
  const { loader } = layerProps;
  // Create at least one layer even without loaderSelection so that the tests pass.
  if (loader.isPyramid) {
    return [loaderSelection, newLoaderSelection]
      .filter((s, i) => i === 0 || s)
      .map((s, i) => {
        const suffix = s
          ? `-${transitionFields.map(f => s[0][f]).join('-')}`
          : '';
        const newProps =
          i !== 0
            ? {
                onViewportLoad,
                refinementStrategy: 'never',
                excludeBackground: true
              }
            : {};
        return new MultiscaleImageLayer({
          ...layerProps,
          ...newProps,
          loaderSelection: s,
          id: `${loader.type}${getVivId(id)}${suffix}`,
          viewportId: id
        });
      });
  }
  return [
    new ImageLayer(layerProps, {
      id: `${loader.type}${getVivId(id)}`,
      viewportId: id,
      loaderSelection
    })
  ];
}

function getPosition(boundingBox, position, length) {
  const viewLength = boundingBox[2][0] - boundingBox[0][0];
  switch (position) {
    case 'bottom-right': {
      const yCoord =
        boundingBox[2][1] - (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = boundingBox[2][0] - viewLength * length;
      return [yCoord, xLeftCoord];
    }
    case 'top-right': {
      const yCoord = (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = boundingBox[2][0] - viewLength * length;
      return [yCoord, xLeftCoord];
    }
    case 'top-left': {
      const yCoord = (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = viewLength * length;
      return [yCoord, xLeftCoord];
    }
    case 'bottom-left': {
      const yCoord =
        boundingBox[2][1] - (boundingBox[2][1] - boundingBox[0][1]) * length;
      const xLeftCoord = viewLength * length;
      return [yCoord, xLeftCoord];
    }
    default: {
      throw new Error(`Position ${position} not found`);
    }
  }
}

const defaultProps$6 = {
  pickable: true,
  viewState: {
    type: 'object',
    value: { zoom: 0, target: [0, 0, 0] },
    compare: true
  },
  unit: { type: 'string', value: '', compare: true },
  size: { type: 'number', value: 1, compare: true },
  position: { type: 'string', value: 'bottom-right', compare: true },
  length: { type: 'number', value: 0.085, compare: true }
};

/**
 * This layer creates a scale bar using three LineLayers and a TextLayer.
 * Looks like: |--------| made up of three LineLayers (left tick, right tick, center length bar) and a bottom TextLayer
 * @param {Object} props
 * @param {String} props.unit Physical unit size per pixel at full resolution.
 * @param {Number} props.size Physical size of a pixel.
 * @param {Array} props.boundingBox Boudning box of the view in which this should render.
 * @param {id} props.id Id from the parent layer.
 * @param {ViewState} props.viewState The current viewState for the desired view.  We cannot internally use this.context.viewport because it is one frame behind:
 * https://github.com/visgl/deck.gl/issues/4504
 * @param {ViewState} props.length Value from 0 to 1 representing the portion of the view to be used for the length part of the scale bar.
 */
class ScaleBarLayer extends CompositeLayer {
  renderLayers() {
    const { id, unit, size, position, viewState, length } = this.props;
    const boundingBox = makeBoundingBox(viewState);
    const { zoom } = viewState;
    const viewLength = boundingBox[2][0] - boundingBox[0][0];
    const barLength = viewLength * 0.05;
    // This is a good heuristic for stopping the bar tick marks from getting too small
    // and/or the text squishing up into the bar.
    const barHeight = Math.max(
      2 ** (-zoom + 1.5),
      (boundingBox[2][1] - boundingBox[0][1]) * 0.007
    );
    const numUnits = barLength * size;
    const [yCoord, xLeftCoord] = getPosition(boundingBox, position, length);
    const lengthBar = new LineLayer({
      id: `scale-bar-length-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [xLeftCoord, yCoord],
          [xLeftCoord + barLength, yCoord]
        ]
      ],
      getSourcePosition: d => d[0],
      getTargetPosition: d => d[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const tickBoundsLeft = new LineLayer({
      id: `scale-bar-height-left-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [xLeftCoord, yCoord - barHeight],
          [xLeftCoord, yCoord + barHeight]
        ]
      ],
      getSourcePosition: d => d[0],
      getTargetPosition: d => d[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const tickBoundsRight = new LineLayer({
      id: `scale-bar-height-right-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        [
          [xLeftCoord + barLength, yCoord - barHeight],
          [xLeftCoord + barLength, yCoord + barHeight]
        ]
      ],
      getSourcePosition: d => d[0],
      getTargetPosition: d => d[1],
      getWidth: 2,
      getColor: [220, 220, 220]
    });
    const textLayer = new TextLayer({
      id: `units-label-layer-${id}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [
        {
          text:
            String(numUnits)
              .slice(0, 5)
              .replace(/\.$/, '') + unit,
          position: [xLeftCoord + barLength * 0.5, yCoord + barHeight * 4]
        }
      ],
      getColor: [220, 220, 220, 255],
      getSize: 12,
      fontFamily: DEFAULT_FONT_FAMILY,
      sizeUnits: 'meters',
      sizeScale: 2 ** -zoom,
      characterSet: [...unit.split(''), ...range(10).map(i => String(i)), '.']
    });
    return [lengthBar, tickBoundsLeft, tickBoundsRight, textLayer];
  }
}

ScaleBarLayer.layerName = 'ScaleBarLayer';
ScaleBarLayer.defaultProps = defaultProps$6;

function _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const areViewStatesEqual = (viewState, otherViewState) => {
  return (
    otherViewState === viewState ||
    (_optionalChain$1([viewState, 'optionalAccess', _ => _.zoom]) === _optionalChain$1([otherViewState, 'optionalAccess', _2 => _2.zoom]) &&
      equal(_optionalChain$1([viewState, 'optionalAccess', _3 => _3.target]), _optionalChain$1([otherViewState, 'optionalAccess', _4 => _4.target])))
  );
};

/**
 * @callback ViewStateChange
 * @param {Object} event
 */

/**
 * This component handles rendering the various views within the DeckGL contenxt.
 * @param {Object} props
 * @param {Array} props.layerProps  Props for the layers in each view.
 * @param {Array} props.randomize Whether or not to randomize which view goes first (for dynamic rendering).
 * @param {VivView} props.views Various VivViews to render.
 * @param {Array} props.viewStates List of objects like [{ target: [x, y, 0], zoom: -zoom, id: 'left' }, { target: [x, y, 0], zoom: -zoom, id: 'right' }]
 * @param {ViewStateChange} [props.onViewStateChange] Callback that returns the deck.gl view state (https://deck.gl/docs/api-reference/core/deck#onviewstatechange).
 * */
class VivViewer extends PureComponent {
  constructor(props) {
    super(props);
    this.state = {
      viewStates: {}
    };
    const { viewStates } = this.state;
    const { views, viewStates: initialViewStates } = this.props;
    views.forEach(view => {
      viewStates[view.id] = view.filterViewState({
        viewState: initialViewStates.find(v => v.id === view.id)
      });
    });
    this._onViewStateChange = this._onViewStateChange.bind(this);
    this.layerFilter = this.layerFilter.bind(this);
    this.onHover = this.onHover.bind(this);
  }

  /**
   * This prevents only the `draw` call of a layer from firing,
   * but not other layer lifecycle methods.  Nonetheless, it is
   * still useful.
   * @param {Layer} layer Layer being updated.
   * @param {Viewport} viewport Viewport being updated.
   * @returns {boolean} Whether or not this layer should be drawn in this viewport.
   */
  // eslint-disable-next-line class-methods-use-this
  layerFilter({ layer, viewport }) {
    return layer.id.includes(getVivId(viewport.id));
  }

  /**
   * This updates the viewState as a callback to the viewport changing in DeckGL
   * (hence the need for storing viewState in state).
   */
  _onViewStateChange({ viewId, viewState, interactionState, oldViewState }) {
    // Save the view state and trigger rerender.
    const { views, onViewStateChange } = this.props;
    // eslint-disable-next-line no-param-reassign
    viewState =
      (onViewStateChange &&
        onViewStateChange({
          viewId,
          viewState,
          interactionState,
          oldViewState
        })) ||
      viewState;
    this.setState(prevState => {
      const viewStates = {};
      views.forEach(view => {
        const currentViewState = prevState.viewStates[view.id];
        viewStates[view.id] = view.filterViewState({
          viewState: { ...viewState, id: viewId },
          oldViewState,
          currentViewState
        });
      });
      return { viewStates };
    });
    return viewState;
  }

  componentDidUpdate(prevProps) {
    const { props } = this;
    const { views } = props;
    // Only update state if the previous viewState prop does not match the current one
    // so that people can update viewState
    // eslint-disable-next-line react/destructuring-assignment
    const viewStates = { ...this.state.viewStates };
    let anyChanged = false;
    views.forEach(view => {
      const currViewState = _optionalChain$1([props, 'access', _5 => _5.viewStates, 'optionalAccess', _6 => _6.find, 'call', _7 => _7(
        viewState => viewState.id === view.id
      )]);
      if (!currViewState) {
        return;
      }
      const prevViewState = _optionalChain$1([prevProps, 'access', _8 => _8.viewStates, 'optionalAccess', _9 => _9.find, 'call', _10 => _10(
        viewState => viewState.id === view.id
      )]);
      if (areViewStatesEqual(currViewState, prevViewState)) {
        return;
      }
      anyChanged = true;
      const { height, width } = view;
      viewStates[view.id] = view.filterViewState({
        viewState: {
          ...currViewState,
          height,
          width,
          id: view.id
        }
      });
    });
    if (anyChanged) {
      // eslint-disable-next-line react/no-did-update-set-state
      this.setState({ viewStates });
    }
  }

  /**
   * This updates the viewStates' height and width with the newest height and
   * width on any call where the viewStates changes (i.e resize events),
   * using the previous state (falling back on the view's initial state) for target x and y, zoom level etc.
   */
  static getDerivedStateFromProps(props, prevState) {
    const { views, viewStates: viewStatesProps } = props;
    // Update internal viewState on view changes as well as height and width changes.
    // Maybe we should add x/y too?
    if (
      views.some(
        view =>
          !prevState.viewStates[view.id] ||
          view.height !== prevState.viewStates[view.id].height ||
          view.width !== prevState.viewStates[view.id].width
      )
    ) {
      const viewStates = {};
      views.forEach(view => {
        const { height, width } = view;
        const currentViewState = prevState.viewStates[view.id];
        viewStates[view.id] = view.filterViewState({
          viewState: {
            ...(currentViewState ||
              viewStatesProps.find(v => v.id === view.id)),
            height,
            width,
            id: view.id
          }
        });
      });
      return { viewStates };
    }
    return prevState;
  }

  // eslint-disable-next-line consistent-return
  onHover({ sourceLayer, coordinate, layer }) {
    if (!coordinate) {
      return null;
    }
    const { hoverHooks } = this.props;
    if (!hoverHooks) {
      return null;
    }
    const { handleValue } = hoverHooks;
    if (!handleValue) {
      return null;
    }
    const { channelData, bounds } = sourceLayer.props;
    if (!channelData) {
      return null;
    }
    const { data, width } = channelData;
    if (!data) {
      return null;
    }
    let dataCoords;
    // Tiled layer needs a custom layerZoomScale.
    if (sourceLayer.id.includes('Tiled')) {
      const {
        loader: { tileSize }
      } = layer.props;
      const {
        tileId: { z }
      } = sourceLayer.props;
      // The zoomed out layer needs to use the fixed zoom at which it is rendered.
      // See: https://github.com/visgl/deck.gl/blob/2b15bc459c6534ea38ce1153f254ce0901f51d6f/modules/geo-layers/src/tile-layer/utils.js#L130.
      const layerZoomScale = Math.max(
        1,
        2 ** Math.round(-z + Math.log2(512 / tileSize))
      );
      dataCoords = [
        Math.floor((coordinate[0] - bounds[0]) / layerZoomScale),
        Math.floor((coordinate[1] - bounds[3]) / layerZoomScale)
      ];
    } else {
      // Using floor means that as we zoom out, we are scaling by the zoom just passed, not the one coming.
      const { zoom } = layer.context.viewport;
      const layerZoomScale = Math.max(1, 2 ** Math.floor(-zoom));
      dataCoords = [
        Math.floor((coordinate[0] - bounds[0]) / layerZoomScale),
        Math.floor((coordinate[1] - bounds[3]) / layerZoomScale)
      ];
    }
    const coords = dataCoords[1] * width + dataCoords[0];
    const hoverData = data.map(d => d[coords]);
    handleValue(hoverData);
  }

  /**
   * This renders the layers in the DeckGL context.
   */
  _renderLayers() {
    const { onHover } = this;
    const { viewStates } = this.state;
    const { views, layerProps } = this.props;
    return views.map((view, i) =>
      view.getLayers({
        viewStates,
        props: {
          ...layerProps[i],
          onHover
        }
      })
    );
  }

  render() {
    /* eslint-disable react/destructuring-assignment */
    const { views, randomize } = this.props;
    const { viewStates } = this.state;
    const deckGLViews = views.map(view => view.getDeckGlView());
    // DeckGL seems to use the first view more than the second for updates
    // so this forces it to use the others more evenly.  This isn't perfect,
    // but I am not sure what else to do.  The DeckGL render hooks don't help,
    // but maybe useEffect() would help?  I couldn't work it out as
    // The issue is that I'm not sure how React would distinguish between forced updates
    // from permuting the views array and "real" updates like zoom/pan.
    // I tried keeping a counter but I couldn't figure out resetting it
    // without triggering a re-render.
    if (randomize) {
      const random = Math.random();
      const holdFirstElement = deckGLViews[0];
      // weight has to go to 1.5 because we use Math.round().
      const randomWieghted = random * 1.49;
      const randomizedIndex = Math.round(randomWieghted * (views.length - 1));
      deckGLViews[0] = deckGLViews[randomizedIndex];
      deckGLViews[randomizedIndex] = holdFirstElement;
    }
    return (
      React.createElement(DeckGL, {
        glOptions: { webgl2: true },
        layerFilter: this.layerFilter,
        layers: this._renderLayers(),
        onViewStateChange: this._onViewStateChange,
        views: deckGLViews,
        viewState: viewStates,
        getCursor: ({ isDragging }) => {
          return isDragging ? 'grabbing' : 'crosshair';
        },}
      )
    );

    /* eslint-disable react/destructuring-assignment */
  }
}

// eslint-disable-next-line max-classes-per-file

/**
 * This class generates a layer and a view for use in the VivViewer
 * @param {Object} args
 * @param {string} args.id id for this VivView.
 * @param {Object} args.height Width of the view.
 * @param {Object} args.width Height of the view.
 * @param {string} args.id Id for the current view
 * @param {number} args.x X (top-left) location on the screen for the current view
 * @param {number} args.y Y (top-left) location on the screen for the current view
 */
class VivView {
  constructor({ id, x = 0, y = 0, height, width }) {
    this.width = width;
    this.height = height;
    this.id = id;
    this.x = x;
    this.y = y;
  }

  /**
   * Create a DeckGL view based on this class.
   * @returns {View} The DeckGL View for this class.
   */
  getDeckGlView() {
    const { height, width, id, x, y } = this;
    return new OrthographicView({
      id,
      controller: true,
      height,
      width,
      x,
      y
    });
  }

  /**
   * Create a viewState for this class, checking the id to make sure this class and veiwState match.
   * @param {Object} args
   * @param {ViewState} args.ViewState ViewState object.
   * @returns {ViewState} ViewState for this class (or null by default if the ids do not match).
   */
  filterViewState({ viewState }) {
    const { id, height, width } = this;
    return viewState.id === id ? { height, width, ...viewState } : null;
  }

  /**
   * Create a layer for this instance.
   * @param {Object} args
   * @param {ViewState} args.viewStates ViewStates for all current views.
   * @param {number} args.props Props for this instance.
   * @returns {Layer} Instance of a layer.
   */
  // eslint-disable-next-line class-methods-use-this,no-unused-vars
  getLayers({ viewStates, props }) {}
}

/* eslint-disable max-classes-per-file */

const OVERVIEW_VIEW_ID = 'overview';

class OverviewState {}

class OverviewController extends Controller {
  constructor(props) {
    super(OverviewState, props);
    this.events = ['click'];
  }

  handleEvent(event) {
    if (event.type !== 'click') {
      return;
    }
    let [x, y] = this.getCenter(event);
    const { width, height, zoom, scale } = this.controllerStateProps;
    if (x < 0 || y < 0 || x > width || y > height) {
      return;
    }
    const scaleFactor = 1 / (2 ** zoom * scale);
    x *= scaleFactor;
    y *= scaleFactor;
    if (this.onViewStateChange) {
      this.onViewStateChange({ viewState: { target: [x, y, 0] } });
    }
  }
}

/**
 * This class generates a OverviewLayer and a view for use in the VivViewer as an overview to a Detailview (they must be used in conjection).
 * From the base class VivView, only the initialViewState argument is used.  This class uses private methods to position its x and y from the
 * additional arguments:
 * @param {Object} args
 * @param {string} args.id id for this VivView.
 * @param {Object} args.loader Loader to be used for inferring zoom level and fetching data.  It must have the properies `dtype`, `numLevels`, and `tileSize` and implement `getTile` and `getRaster`.
 * @param {number} args.detailHeight Height of the detail view.
 * @param {number} args.detailWidth Width of the detail view.
 * @param {number} [args.scale] Scale of this viewport relative to the detail. Default is .2.
 * @param {number} [args.margin] Margin to be offset from the the corner of the other viewport. Default is 25.
 * @param {string} [args.position] Location of the viewport - one of "bottom-right", "top-right", "top-left", "bottom-left."  Default is 'bottom-right'.
 * @param {number} [args.minimumWidth] Absolute lower bound for how small the viewport should scale. Default is 150.
 * @param {number} [args.maximumWidth] Absolute upper bound for how large the viewport should scale. Default is 350.
 * @param {number} [args.minimumHeight] Absolute lower bound for how small the viewport should scale. Default is 150.
 * @param {number} [args.maximumHeight] Absolute upper bound for how large the viewport should scale. Default is 350.
 * @param {Boolean} [args.clickCenter] Click to center the default view. Default is true.
 * */
class OverviewView extends VivView {
  constructor({
    id,
    loader,
    detailHeight,
    detailWidth,
    scale = 0.2,
    margin = 25,
    position = 'bottom-right',
    minimumWidth = 150,
    maximumWidth = 350,
    minimumHeight = 150,
    maximumHeight = 350,
    clickCenter = true
  }) {
    super({ id });
    this.margin = margin;
    this.loader = loader;
    this.position = position;
    this.detailHeight = detailHeight;
    this.detailWidth = detailWidth;
    this._setHeightWidthScale({
      detailWidth,
      detailHeight,
      scale,
      minimumWidth,
      maximumWidth,
      minimumHeight,
      maximumHeight
    });
    this._setXY();
    this.clickCenter = clickCenter;
  }

  /**
   * Set the image-pixel scale and height and width based on detail view.
   */
  _setHeightWidthScale({
    detailWidth,
    detailHeight,
    scale,
    minimumWidth,
    maximumWidth,
    minimumHeight,
    maximumHeight
  }) {
    const { loader } = this;
    const { numLevels } = loader;
    const { width: rasterWidth, height: rasterHeight } = loader.getRasterSize({
      z: 0
    });
    this._imageWidth = rasterWidth;
    this._imageHeight = rasterHeight;
    if (rasterWidth > rasterHeight) {
      const heightWidthRatio = rasterHeight / rasterWidth;
      this.width = Math.min(
        maximumWidth,
        Math.max(detailWidth * scale, minimumWidth)
      );
      this.height = this.width * heightWidthRatio;
      this.scale = (2 ** (numLevels - 1) / rasterWidth) * this.width;
    } else {
      const widthHeightRatio = rasterWidth / rasterHeight;
      this.height = Math.min(
        maximumHeight,
        Math.max(detailHeight * scale, minimumHeight)
      );
      this.width = this.height * widthHeightRatio;
      this.scale = (2 ** (numLevels - 1) / rasterHeight) * this.height;
    }
  }

  /**
   * Set the x and y (top left corner) of this overview relative to the detail.
   */
  _setXY() {
    const { height, width, margin, position, detailWidth, detailHeight } = this;
    switch (position) {
      case 'bottom-right': {
        this.x = detailWidth - width - margin;
        this.y = detailHeight - height - margin;
        break;
      }
      case 'top-right': {
        this.x = detailWidth - width - margin;
        this.y = margin;
        break;
      }
      case 'top-left': {
        this.x = margin;
        this.y = margin;
        break;
      }
      case 'bottom-left': {
        this.x = margin;
        this.y = detailHeight - height - margin;
        break;
      }
      default: {
        throw new Error(
          `overviewLocation prop needs to be one of ['bottom-right', 'top-right', 'top-left', 'bottom-left']`
        );
      }
    }
  }

  getDeckGlView() {
    const { x, y, id, height, width, scale, clickCenter } = this;
    const controller = clickCenter && { type: OverviewController, scale };
    return new OrthographicView({
      id,
      controller,
      height,
      width,
      x,
      y,
      clear: true
    });
  }

  filterViewState({ viewState }) {
    // Scale the view as the overviewScale changes with screen resizing - basically, do not react to any view state changes.
    const {
      _imageWidth,
      _imageHeight,
      scale,
      id,
      loader,
      height,
      width
    } = this;
    const { numLevels } = loader;
    return {
      ...viewState,
      height,
      width,
      id,
      target: [(_imageWidth * scale) / 2, (_imageHeight * scale) / 2, 0],
      zoom: -(numLevels - 1)
    };
  }

  getLayers({ viewStates, props }) {
    const { detail, overview } = viewStates;
    if (!detail) {
      throw new Error('Overview requires a viewState with id detail');
    }
    const { id, scale, loader } = this;
    // Scale the bounding box.
    const boundingBox = makeBoundingBox(detail).map(coords =>
      coords.map(e => e * scale)
    );
    const overviewLayer = new OverviewLayer(props, {
      id: `${loader.type}${getVivId(id)}`,
      boundingBox,
      overviewScale: scale,
      zoom: -overview.zoom
    });
    return [overviewLayer];
  }
}

const DETAIL_VIEW_ID = 'detail';

/**
 * This class generates a MultiscaleImageLayer and a view for use in the VivViewer as a detailed view.
 * It takes the same arguments for its constructor as its base class VivView.
 * */
class DetailView extends VivView {
  getLayers({ props, viewStates }) {
    const { loader } = props;
    const { id, height, width } = this;
    const layerViewState = viewStates[id];
    const layers = getImageLayers(id, props);

    const { physicalSizes } = loader;
    if (physicalSizes) {
      const { x } = physicalSizes;
      const { unit, value } = x;
      if (unit && value) {
        layers.push(
          new ScaleBarLayer({
            id: getVivId(id),
            loader,
            unit,
            size: value,
            viewState: { ...layerViewState, height, width }
          })
        );
      }
    }

    return layers;
  }

  /**
   * Create a viewState for this class, checking the id to make sure this class and viewState match.
   * @param {Object} args
   * @param {ViewState} args.ViewState ViewState object.
   * @returns {ViewState} ViewState for this class (or null by default if the ids do not match).
   */
  filterViewState({ viewState, currentViewState }) {
    if (viewState.id === OVERVIEW_VIEW_ID) {
      const { target } = viewState;
      if (target) {
        return { ...currentViewState, target };
      }
    }
    return super.filterViewState({ viewState });
  }
}

/**
 * This class generates a MultiscaleImageLayer and a view for use in the SideBySideViewer.
 * It is linked with its other views as controlled by `linkedIds`, `zoomLock`, and `panLock` parameters.
 * It takes the same arguments for its constructor as its base class VivView plus the following:
 * @param {Object} args
 * @param {Array} args.linkedIds Ids of the other views to which this could be locked via zoom/pan.
 * @param {Boolean} args.panLock Whether or not we lock pan.
 * @param {Boolean} args.zoomLock Whether or not we lock zoom.
 * @param {Array} args.viewportOutlineColor Outline color of the border (default [255, 255, 255])
 * @param {number} args.viewportOutlineWidth Default outline width (default 10)
 * */
class SideBySideView extends VivView {
  constructor({
    id,
    x,
    y,
    height,
    width,
    linkedIds = [],
    panLock = true,
    zoomLock = true,
    viewportOutlineColor = [255, 255, 255],
    viewportOutlineWidth = 10
  }) {
    super({ id, x, y, height, width });
    this.linkedIds = linkedIds;
    this.panLock = panLock;
    this.zoomLock = zoomLock;
    this.viewportOutlineColor = viewportOutlineColor;
    this.viewportOutlineWidth = viewportOutlineWidth;
  }

  filterViewState({ viewState, oldViewState, currentViewState }) {
    const { id: viewStateId } = viewState;
    const { id, linkedIds, panLock, zoomLock } = this;
    if (
      oldViewState &&
      linkedIds.indexOf(viewStateId) !== -1 &&
      (zoomLock || panLock)
    ) {
      const thisViewState = {
        height: currentViewState.height,
        width: currentViewState.width,
        target: [],
        zoom: null
      };
      const [currentX, currentY] = currentViewState.target;
      if (zoomLock) {
        const dZoom = viewState.zoom - oldViewState.zoom;
        thisViewState.zoom = currentViewState.zoom + dZoom;
      } else {
        thisViewState.zoom = currentViewState.zoom;
      }
      if (panLock) {
        const [oldX, oldY] = oldViewState.target;
        const [newX, newY] = viewState.target;
        const dx = newX - oldX;
        const dy = newY - oldY;
        thisViewState.target.push(currentX + dx);
        thisViewState.target.push(currentY + dy);
      } else {
        thisViewState.target.push(currentX);
        thisViewState.target.push(currentY);
      }
      return {
        id,
        target: thisViewState.target,
        zoom: thisViewState.zoom,
        height: thisViewState.height,
        width: thisViewState.width
      };
    }
    return viewState.id === id
      ? {
          id,
          target: viewState.target,
          zoom: viewState.zoom,
          height: viewState.height,
          width: viewState.width
        }
      : {
          id,
          target: currentViewState.target,
          zoom: currentViewState.zoom,
          height: currentViewState.height,
          width: currentViewState.width
        };
  }

  getLayers({ props, viewStates }) {
    const { loader } = props;
    const {
      id,
      viewportOutlineColor,
      viewportOutlineWidth,
      height,
      width
    } = this;
    const layerViewState = viewStates[id];
    const boundingBox = makeBoundingBox({ ...layerViewState, height, width });
    const layers = getImageLayers(id, props);

    const border = new PolygonLayer({
      id: `viewport-outline-${loader.type}${getVivId(id)}`,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      data: [boundingBox],
      getPolygon: f => f,
      filled: false,
      stroked: true,
      getLineColor: viewportOutlineColor,
      getLineWidth: viewportOutlineWidth * 2 ** -layerViewState.zoom
    });
    layers.push(border);

    const { physicalSizes } = loader;
    if (physicalSizes) {
      const { x } = physicalSizes;
      const { unit, value } = x;
      if (unit && value) {
        layers.push(
          new ScaleBarLayer({
            id: getVivId(id),
            loader,
            unit,
            size: value,
            viewState: { ...layerViewState, height, width }
          })
        );
      }
    }

    return layers;
  }
}

function _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
function useGlobalSelection(loaderSelection, transitionFields) {
  // viewportSelection is the last selection that had an onViewportLoad callback.
  const [viewportSelection, setViewportSelection] = useState(loaderSelection);
  let onViewportLoad;
  let newLoaderSelection = null;
  let oldLoaderSelection = loaderSelection;
  if (
    _optionalChain$2([loaderSelection, 'optionalAccess', _ => _.length]) &&
    _optionalChain$2([viewportSelection, 'optionalAccess', _2 => _2.length]) &&
    transitionFields.some(
      f => loaderSelection[0][f] !== viewportSelection[0][f]
    )
  ) {
    // onViewportLoad is a property of TileLayer that is passed through:
    // https://deck.gl/docs/api-reference/geo-layers/tile-layer#onviewportload
    onViewportLoad = () => {
      // Slightly delay to avoid issues with a render in the middle of a deck.gl layer state update.
      setTimeout(() => {
        setViewportSelection(loaderSelection);
      }, 0);
    };
    // Set newLoaderSelection to cause the creation of an extra tile layer.
    newLoaderSelection = loaderSelection;
    oldLoaderSelection = viewportSelection;
  }
  return { newLoaderSelection, oldLoaderSelection, onViewportLoad };
}

function _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
/**
 * This component provides a component for an overview-detail VivViewer of an image (i.e picture-in-picture).
 * @param {Object} props
 * @param {Array} props.sliderValues List of [begin, end] values to control each channel's ramp function.
 * @param {Array} props.colorValues List of [r, g, b] values for each channel.
 * @param {Array} props.channelIsOn List of boolean values for each channel for whether or not it is visible.
 * @param {string} props.colormap String indicating a colormap (default: '').  The full list of options is here: https://github.com/glslify/glsl-colormap#glsl-colormap
 * @param {Object} props.loader Loader to be used for fetching data.  It must have the properies `dtype`, `numLevels`, `isPyramid`, `isRgb`, `isInterleaved`, and `tileSize` and implement `getTile`, `getRaster`, and `getRasterSize`.
 * @param {Array} props.loaderSelection Selection to be used for fetching data.
 * @param {Object} props.overview Allows you to pass settings into the OverviewView: { scale, margin, position, minimumWidth, maximumWidth,
 * boundingBoxColor, boundingBoxOutlineWidth, viewportOutlineColor, viewportOutlineWidth}.  See http://viv.gehlenborglab.org/#overviewview for defaults.
 * @param {Boolean} props.overviewOn Whether or not to show the OverviewView.
 * @param {Object} props.hoverHooks Object including the allowable hooks - right now only accepting a function with key handleValue like { handleValue: (valueArray) => {} } where valueArray
 * has the pixel values for the image under the hover location.
 * @param {Array} [props.viewStates] Array of objects like [{ target: [x, y, 0], zoom: -zoom, id: DETAIL_VIEW_ID }] for setting where the viewer looks (optional - this is inferred from height/width/loader
 * internally by default using getDefaultInitialViewState).
 * @param {number} props.height Current height of the component.
 * @param {number} props.width Current width of the component.
 * @param {boolean} [props.isLensOn] Whether or not to use the lens (deafult false).
 * @param {number} [props.lensSelection] Numeric index of the channel to be focused on by the lens (default 0).
 * @param {number} [props.lensRadius] Pixel radius of the lens (default: 100).
 * @param {Array} [props.lensBorderColor] RGB color of the border of the lens (default [255, 255, 255]).
 * @param {number} [props.lensBorderRadius] Percentage of the radius of the lens for a border (default 0.02).
 * @param {number} [props.lensBorderRadius] Percentage of the radius of the lens for a border (default 0.02).
 * @param {Boolean} [props.clickCenter] Click to center the default view. Default is true.
 * @param {Array} [props.transparentColor] An RGB (0-255 range) color to be considered "transparent" if provided.
 * In other words, any fragment shader output equal transparentColor (before applying opacity) will have opacity 0.
 * This parameter only needs to be a truthy value when using colormaps because each colormap has its own transparent color that is calculated on the shader.
 * Thus setting this to a truthy value (with a colormap set) indicates that the shader should make that color transparent.
 * @param {import('./VivViewer').ViewStateChange} [props.onViewStateChange] Callback that returns the deck.gl view state (https://deck.gl/docs/api-reference/core/deck#onviewstatechange).
 * @param {Array} [transitionFields] A string array indicating which fields require a transition: Default: ['time', 'z'].
 */

const PictureInPictureViewer = props => {
  const {
    loader,
    sliderValues,
    colorValues,
    channelIsOn,
    viewStates: viewStatesProp,
    colormap,
    overview,
    overviewOn,
    loaderSelection,
    hoverHooks,
    height,
    width,
    isLensOn = false,
    lensSelection = 0,
    lensRadius = 100,
    lensBorderColor = [255, 255, 255],
    lensBorderRadius = 0.02,
    clickCenter = true,
    transparentColor,
    onViewStateChange,
    transitionFields = GLOBAL_SLIDER_DIMENSION_FIELDS
  } = props;
  const {
    newLoaderSelection,
    oldLoaderSelection,
    onViewportLoad
  } = useGlobalSelection(loaderSelection, transitionFields);
  const detailViewState = _optionalChain$3([viewStatesProp, 'optionalAccess', _ => _.find, 'call', _2 => _2(v => v.id === DETAIL_VIEW_ID)]);
  const baseViewState = useMemo(() => {
    return (
      detailViewState ||
      getDefaultInitialViewState(loader, { height, width }, 0.5)
    );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loader, detailViewState]);

  const detailView = new DetailView({
    id: DETAIL_VIEW_ID,
    height,
    width
  });
  const layerConfig = {
    loader,
    sliderValues,
    colorValues,
    channelIsOn,
    loaderSelection: oldLoaderSelection,
    newLoaderSelection,
    onViewportLoad,
    transitionFields,
    colormap,
    isLensOn,
    lensSelection,
    lensRadius,
    lensBorderColor,
    lensBorderRadius,
    transparentColor
  };
  const views = [detailView];
  const layerProps = [layerConfig];
  const viewStates = [{ ...baseViewState, id: DETAIL_VIEW_ID }];
  if (overviewOn && loader) {
    // It's unclear why this is needed because OverviewView.filterViewState sets "zoom" and "target".
    const overviewViewState = _optionalChain$3([viewStatesProp, 'optionalAccess', _3 => _3.find, 'call', _4 => _4(
      v => v.id === OVERVIEW_VIEW_ID
    )]) || { ...baseViewState, id: OVERVIEW_VIEW_ID };
    const overviewView = new OverviewView({
      id: OVERVIEW_VIEW_ID,
      loader,
      detailHeight: height,
      detailWidth: width,
      clickCenter,
      ...overview
    });
    views.push(overviewView);
    layerProps.push(layerConfig);
    viewStates.push(overviewViewState);
  }
  if (!loader) return null;
  return (
    React.createElement(VivViewer, {
      layerProps: layerProps,
      views: views,
      viewStates: viewStates,
      hoverHooks: hoverHooks,
      onViewStateChange: onViewStateChange,}
    )
  );
};

function _optionalChain$4(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
/**
 * This component provides a side-by-side VivViewer with linked zoom/pan.
 * @param {Object} props
 * @param {Array} props.sliderValues List of [begin, end] values to control each channel's ramp function.
 * @param {Array} props.colorValues List of [r, g, b] values for each channel.
 * @param {Array} props.channelIsOn List of boolean values for each channel for whether or not it is visible.
 * @param {string} props.colormap String indicating a colormap (default: '').  The full list of options is here: https://github.com/glslify/glsl-colormap#glsl-colormap
 * @param {Object} props.loader Loader to be used for fetching data.  It must have the properies `dtype`, `numLevels`, `isRgb`, `isInterleaved`, and `tileSize` and implement `getTile`, `getRasterSize`, and `getRaster`.
 * @param {Array} props.loaderSelection Selection to be used for fetching data.
 * @param {Boolean} props.zoomLock Whether or not lock the zooms of the two views.
 * @param {Boolean} props.panLock Whether or not lock the pans of the two views.
 * @param {Array} [props.viewStates] List of objects like [{ target: [x, y, 0], zoom: -zoom, id: 'left' }, { target: [x, y, 0], zoom: -zoom, id: 'right' }] for initializing where the viewer looks (optional - this is inferred from height/width/loader
 * internally by default using getDefaultInitialViewState).
 * @param {number} props.height Current height of the component.
 * @param {number} props.width Current width of the component.
 * @param {boolean} [props.isLensOn] Whether or not to use the lens deafult (false).
 * @param {number} [props.lensSelection] Numeric index of the channel to be focused on by the lens (default 0).
 * @param {Array} [props.lensBorderColor] RGB color of the border of the lens (default [255, 255, 255]).
 * @param {number} [props.lensBorderRadius] Percentage of the radius of the lens for a border (default 0.02).
 * @param {Array} [props.transparentColor] An RGB (0-255 range) color to be considered "transparent" if provided.
 * In other words, any fragment shader output equal transparentColor (before applying opacity) will have opacity 0.
 * This parameter only needs to be a truthy value when using colormaps because each colormap has its own transparent color that is calculated on the shader.
 * Thus setting this to a truthy value (with a colormap set) indicates that the shader should make that color transparent.
 * @param {import('./VivViewer').ViewStateChange} [props.onViewStateChange] Callback that returns the deck.gl view state (https://deck.gl/docs/api-reference/core/deck#onviewstatechange).
 * @param {Array} [transitionFields] A string array indicating which fields require a transition: Default: ['time', 'z'].
 */
const SideBySideViewer = props => {
  const {
    loader,
    sliderValues,
    colorValues,
    channelIsOn,
    viewStates: viewStatesProp,
    colormap,
    panLock,
    loaderSelection,
    zoomLock,
    height,
    width,
    isLensOn = false,
    lensSelection = 0,
    lensRadius = 100,
    lensBorderColor = [255, 255, 255],
    lensBorderRadius = 0.02,
    transparentColor,
    onViewStateChange,
    transitionFields = GLOBAL_SLIDER_DIMENSION_FIELDS
  } = props;
  const {
    newLoaderSelection,
    oldLoaderSelection,
    onViewportLoad
  } = useGlobalSelection(loaderSelection, transitionFields);
  const leftViewState = _optionalChain$4([viewStatesProp, 'optionalAccess', _ => _.find, 'call', _2 => _2(v => v.id === 'left')]);
  const rightViewState = _optionalChain$4([viewStatesProp, 'optionalAccess', _3 => _3.find, 'call', _4 => _4(v => v.id === 'right')]);
  const viewStates = useMemo(() => {
    if (leftViewState && rightViewState) {
      return viewStatesProp;
    }
    const defaultViewState = getDefaultInitialViewState(
      loader,
      { height, width: width / 2 },
      0.5
    );
    return [
      leftViewState || { ...defaultViewState, id: 'left' },
      rightViewState || { ...defaultViewState, id: 'right' }
    ];
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loader, leftViewState, rightViewState]);

  const detailViewLeft = new SideBySideView({
    id: 'left',
    linkedIds: ['right'],
    panLock,
    zoomLock,
    height,
    width: width / 2
  });
  const detailViewRight = new SideBySideView({
    id: 'right',
    x: width / 2,
    linkedIds: ['left'],
    panLock,
    zoomLock,
    height,
    width: width / 2
  });
  const layerConfig = {
    loader,
    sliderValues,
    colorValues,
    channelIsOn,
    loaderSelection: oldLoaderSelection,
    newLoaderSelection,
    onViewportLoad,
    transitionFields,
    colormap,
    isLensOn,
    lensSelection,
    lensRadius,
    lensBorderColor,
    lensBorderRadius,
    transparentColor
  };
  const views = [detailViewRight, detailViewLeft];
  const layerProps = [layerConfig, layerConfig];
  return loader ? (
    React.createElement(VivViewer, {
      layerProps: layerProps,
      views: views,
      randomize: true,
      onViewStateChange: onViewStateChange,
      viewStates: viewStates,}
    )
  ) : null;
};

function decodeBase64(base64, enableUnicode) {
    var binaryString = atob(base64);
    if (enableUnicode) {
        var binaryView = new Uint8Array(binaryString.length);
        for (var i = 0, n = binaryString.length; i < n; ++i) {
            binaryView[i] = binaryString.charCodeAt(i);
        }
        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
    }
    return binaryString;
}

function createURL(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    var blob = new Blob([body], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
}

function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
    var url;
    return function WorkerFactory(options) {
        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
        return new Worker(url, options);
    };
}

var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgZnVuY3Rpb24gZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlKSB7CiAgICBsZXQgbGVuZ3RoID0gcm93Lmxlbmd0aCAtIHN0cmlkZTsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgZG8gewogICAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgaS0tKSB7CiAgICAgICAgcm93W29mZnNldCArIHN0cmlkZV0gKz0gcm93W29mZnNldF07CiAgICAgICAgb2Zmc2V0Kys7CiAgICAgIH0KCiAgICAgIGxlbmd0aCAtPSBzdHJpZGU7CiAgICB9IHdoaWxlIChsZW5ndGggPiAwKTsKICB9CgogIGZ1bmN0aW9uIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKSB7CiAgICBsZXQgaW5kZXggPSAwOwogICAgbGV0IGNvdW50ID0gcm93Lmxlbmd0aDsKICAgIGNvbnN0IHdjID0gY291bnQgLyBieXRlc1BlclNhbXBsZTsKCiAgICB3aGlsZSAoY291bnQgPiBzdHJpZGUpIHsKICAgICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IC0taSkgewogICAgICAgIHJvd1tpbmRleCArIHN0cmlkZV0gKz0gcm93W2luZGV4XTsKICAgICAgICArK2luZGV4OwogICAgICB9CiAgICAgIGNvdW50IC09IHN0cmlkZTsKICAgIH0KCiAgICBjb25zdCBjb3B5ID0gcm93LnNsaWNlKCk7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdjOyArK2kpIHsKICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBieXRlc1BlclNhbXBsZTsgKytiKSB7CiAgICAgICAgcm93WyhieXRlc1BlclNhbXBsZSAqIGkpICsgYl0gPSBjb3B5WygoYnl0ZXNQZXJTYW1wbGUgLSBiIC0gMSkgKiB3YykgKyBpXTsKICAgICAgfQogICAgfQogIH0KCiAgZnVuY3Rpb24gYXBwbHlQcmVkaWN0b3IoYmxvY2ssIHByZWRpY3Rvciwgd2lkdGgsIGhlaWdodCwgYml0c1BlclNhbXBsZSwKICAgIHBsYW5hckNvbmZpZ3VyYXRpb24pIHsKICAgIGlmICghcHJlZGljdG9yIHx8IHByZWRpY3RvciA9PT0gMSkgewogICAgICByZXR1cm4gYmxvY2s7CiAgICB9CgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7CiAgICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICUgOCAhPT0gMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3Rvciwgb25seSBtdWx0aXBsZSBvZiA4IGJpdHMgYXJlIHN1cHBvcnRlZC4nKTsKICAgICAgfQogICAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAhPT0gYml0c1BlclNhbXBsZVswXSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3RvciwgYWxsIHNhbXBsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNpemUuJyk7CiAgICAgIH0KICAgIH0KCiAgICBjb25zdCBieXRlc1BlclNhbXBsZSA9IGJpdHNQZXJTYW1wbGVbMF0gLyA4OwogICAgY29uc3Qgc3RyaWRlID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMiA/IDEgOiBiaXRzUGVyU2FtcGxlLmxlbmd0aDsKCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7CiAgICAgIC8vIExhc3Qgc3RyaXAgd2lsbCBiZSB0cnVuY2F0ZWQgaWYgaGVpZ2h0ICUgc3RyaXBIZWlnaHQgIT0gMAogICAgICBpZiAoaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgPj0gYmxvY2suYnl0ZUxlbmd0aCkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGxldCByb3c7CiAgICAgIGlmIChwcmVkaWN0b3IgPT09IDIpIHsgLy8gaG9yaXpvbnRhbCBwcmVkaWN0aW9uCiAgICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlWzBdKSB7CiAgICAgICAgICBjYXNlIDg6CiAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KAogICAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwKICAgICAgICAgICAgKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDE2OgogICAgICAgICAgICByb3cgPSBuZXcgVWludDE2QXJyYXkoCiAgICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gMiwKICAgICAgICAgICAgKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDMyOgogICAgICAgICAgICByb3cgPSBuZXcgVWludDMyQXJyYXkoCiAgICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gNCwKICAgICAgICAgICAgKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWRpY3RvciAyIG5vdCBhbGxvd2VkIHdpdGggJHtiaXRzUGVyU2FtcGxlWzBdfSBiaXRzIHBlciBzYW1wbGUuYCk7CiAgICAgICAgfQogICAgICAgIGRlY29kZVJvd0FjYyhyb3csIHN0cmlkZSk7CiAgICAgIH0gZWxzZSBpZiAocHJlZGljdG9yID09PSAzKSB7IC8vIGhvcml6b250YWwgZmxvYXRpbmcgcG9pbnQKICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheSgKICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwKICAgICAgICApOwogICAgICAgIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIGJsb2NrOwogIH0KCiAgY2xhc3MgQmFzZURlY29kZXIgewogICAgYXN5bmMgZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikgewogICAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgdGhpcy5kZWNvZGVCbG9jayhidWZmZXIpOwogICAgICBjb25zdCBwcmVkaWN0b3IgPSBmaWxlRGlyZWN0b3J5LlByZWRpY3RvciB8fCAxOwogICAgICBpZiAocHJlZGljdG9yICE9PSAxKSB7CiAgICAgICAgY29uc3QgaXNUaWxlZCA9ICFmaWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0czsKICAgICAgICBjb25zdCB0aWxlV2lkdGggPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggOiBmaWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7CiAgICAgICAgY29uc3QgdGlsZUhlaWdodCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVMZW5ndGggOiAoCiAgICAgICAgICBmaWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCB8fCBmaWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoCiAgICAgICAgKTsKICAgICAgICByZXR1cm4gYXBwbHlQcmVkaWN0b3IoCiAgICAgICAgICBkZWNvZGVkLCBwcmVkaWN0b3IsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLAogICAgICAgICAgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uLAogICAgICAgICk7CiAgICAgIH0KICAgICAgcmV0dXJuIGRlY29kZWQ7CiAgICB9CiAgfQoKICBjbGFzcyBSYXdEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIgewogICAgZGVjb2RlQmxvY2soYnVmZmVyKSB7CiAgICAgIHJldHVybiBidWZmZXI7CiAgICB9CiAgfQoKICBsZXQgQSxJPW51bGw7ZnVuY3Rpb24gZygpe3JldHVybiBudWxsIT09SSYmSS5idWZmZXI9PT1BLm1lbW9yeS5idWZmZXJ8fChJPW5ldyBVaW50OEFycmF5KEEubWVtb3J5LmJ1ZmZlcikpLEl9bGV0IEI9MDtsZXQgUT1udWxsO2Z1bmN0aW9uIEMoKXtyZXR1cm4gbnVsbCE9PVEmJlEuYnVmZmVyPT09QS5tZW1vcnkuYnVmZmVyfHwoUT1uZXcgSW50MzJBcnJheShBLm1lbW9yeS5idWZmZXIpKSxRfWFzeW5jIGZ1bmN0aW9uIEUoSSl7dm9pZCAwPT09SSYmKEk9IiIucmVwbGFjZSgvXC5qcyQvLCJfYmcud2FzbSIpKTsoInN0cmluZyI9PXR5cGVvZiBJfHwiZnVuY3Rpb24iPT10eXBlb2YgUmVxdWVzdCYmSSBpbnN0YW5jZW9mIFJlcXVlc3R8fCJmdW5jdGlvbiI9PXR5cGVvZiBVUkwmJkkgaW5zdGFuY2VvZiBVUkwpJiYoST1mZXRjaChJKSk7Y29uc3R7aW5zdGFuY2U6Zyxtb2R1bGU6Qn09YXdhaXQgYXN5bmMgZnVuY3Rpb24oQSxJKXtpZigiZnVuY3Rpb24iPT10eXBlb2YgUmVzcG9uc2UmJkEgaW5zdGFuY2VvZiBSZXNwb25zZSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKXRyeXtyZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQSxJKX1jYXRjaChJKXtpZigiYXBwbGljYXRpb24vd2FzbSI9PUEuaGVhZGVycy5nZXQoIkNvbnRlbnQtVHlwZSIpKXRocm93IEk7Y29uc29sZS53YXJuKCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIHdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxuIixJKTt9Y29uc3QgZz1hd2FpdCBBLmFycmF5QnVmZmVyKCk7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGcsSSl9e2NvbnN0IGc9YXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQSxJKTtyZXR1cm4gZyBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlP3tpbnN0YW5jZTpnLG1vZHVsZTpBfTpnfX0oYXdhaXQgSSx7fSk7cmV0dXJuIEE9Zy5leHBvcnRzLEUuX193YmluZGdlbl93YXNtX21vZHVsZT1CLEF9dmFyIEQ9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVjb21wcmVzczpmdW5jdGlvbihJLFEpe3RyeXtjb25zdCBOPUEuX193YmluZGdlbl9leHBvcnRfMC52YWx1ZS0xNjtBLl9fd2JpbmRnZW5fZXhwb3J0XzAudmFsdWU9Tjt2YXIgRT1mdW5jdGlvbihBLEkpe2NvbnN0IFE9SSgxKkEubGVuZ3RoKTtyZXR1cm4gZygpLnNldChBLFEvMSksQj1BLmxlbmd0aCxRfShJLEEuX193YmluZGdlbl9tYWxsb2MpLEQ9QjtBLmRlY29tcHJlc3MoTixFLEQsUSk7dmFyIHc9QygpW04vNCswXSxpPUMoKVtOLzQrMV0sbz0oRz13LEY9aSxnKCkuc3ViYXJyYXkoRy8xLEcvMStGKSkuc2xpY2UoKTtyZXR1cm4gQS5fX3diaW5kZ2VuX2ZyZWUodywxKmkpLG99ZmluYWxseXtBLl9fd2JpbmRnZW5fZXhwb3J0XzAudmFsdWUrPTE2O312YXIgRyxGO30sZGVmYXVsdDpFfSk7Y29uc3Qgdz1bNjIsMCwwLDAsNjMsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsMCwwLDAsMCwwLDAsMCwwLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDAsMCwwLDAsMCwwLDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxXTtmdW5jdGlvbiBpKEEpe3JldHVybiB3W0EtNDNdfWNvbnN0IG89ZnVuY3Rpb24oQSl7bGV0IEksZz1BLmVuZHNXaXRoKCI9PSIpPzI6QS5lbmRzV2l0aCgiPSIpPzE6MCxCPUEubGVuZ3RoLFE9bmV3IFVpbnQ4QXJyYXkoQi80KjMpO2ZvcihsZXQgZz0wLEM9MDtnPEI7Zys9NCxDKz0zKUk9aShBLmNoYXJDb2RlQXQoZykpPDwxOHxpKEEuY2hhckNvZGVBdChnKzEpKTw8MTJ8aShBLmNoYXJDb2RlQXQoZysyKSk8PDZ8aShBLmNoYXJDb2RlQXQoZyszKSksUVtDXT1JPj4xNixRW0MrMV09ST4+OCYyNTUsUVtDKzJdPTI1NSZJO3JldHVybiBRLnN1YmFycmF5KDAsUS5sZW5ndGgtZyl9KCJBR0Z6YlFFQUFBQUJXUTVnQW45L0FYOWdBMzkvZndGL1lBSi9md0JnQVg4QVlBTi9mMzhBWUFGL0FYOWdCSDkvZjM4QVlBUi9mMzkvQVg5Z0JuOS9mMzkvZndCZ0FYOEJmbUFBQUdBRmYzOS9mMzhBWUFWL2YzOS9md0YvWUFKK2Z3Ri9BMmhuQlFnSUN3TUJBZ1VNQVFBQkFBSUFCUUFDQWdZTkJnTUNBQVlDQUFBRUJBSUVBZ1FHQUFZQkJnSUhBd1FFQkFBREF3TUZBd01FQkFRRUJBSUNBQWNBQkFBQ0F3RUNCd1VFQXdFRkFnSURBZ01DQWdNREJ3SUFBQVFCQUFvQUFBRUNBQU1GQ1FrREFnUUZBWEFCSnljRkF3RUFFUVlKQVg4QlFZQ0F3QUFMQjFNRkJtMWxiVzl5ZVFJQUNtUmxZMjl0Y0hKbGMzTUFKeE5mWDNkaWFXNWtaMlZ1WDJWNGNHOXlkRjh3QXdBUlgxOTNZbWx1WkdkbGJsOXRZV3hzYjJNQVNnOWZYM2RpYVc1a1oyVnVYMlp5WldVQVZRa3NBUUJCQVFzbVpTUTBBbUpoUWpRQlltRkNabVZaRER4alV4b2hVbVJkV2k0T1hGWmxZd3NjUUY0YlBtQUtzK1FCWjVncUFnaC9BWDRDUUFKQUFrQUNRQUpBSUFCQjlRRlBCRUFnQUVITi8zdFBEUVFnQUVFTGFpSUFRWGh4SVFWQjJLWEFBQ2dDQUNJSVJRMEJRUUFnQldzaEJnSkFBa0FDZjBFQUlBQkJDSFlpQUVVTkFCcEJIeUFGUWYvLy93ZExEUUFhSUFWQkJpQUFaeUlBYTBFZmNYWkJBWEVnQUVFQmRHdEJQbW9MSWdkQkFuUkI1S2ZBQUdvb0FnQWlBQVJBSUFWQkFFRVpJQWRCQVhaclFSOXhJQWRCSDBZYmRDRUNBMEFDUUNBQVFRUnFLQUlBUVhoeElnUWdCVWtOQUNBRUlBVnJJZ1FnQms4TkFDQUFJUU1nQkNJR0RRQkJBQ0VHREFNTElBQkJGR29vQWdBaUJDQUJJQVFnQUNBQ1FSMTJRUVJ4YWtFUWFpZ0NBQ0lBUnhzZ0FTQUVHeUVCSUFKQkFYUWhBaUFBRFFBTElBRUVRQ0FCSVFBTUFnc2dBdzBDQzBFQUlRTkJBaUFIUVI5eGRDSUFRUUFnQUd0eUlBaHhJZ0JGRFFNZ0FFRUFJQUJyY1doQkFuUkI1S2ZBQUdvb0FnQWlBRVVOQXdzRFFDQUFJQU1nQUVFRWFpZ0NBRUY0Y1NJQklBVlBJQUVnQldzaUFTQUdTWEVpQWhzaEF5QUJJQVlnQWhzaEJpQUFLQUlRSWdFRWZ5QUJCU0FBUVJScUtBSUFDeUlBRFFBTElBTkZEUUlMUWVTb3dBQW9BZ0FpQUNBRlQwRUFJQVlnQUNBRmEwOGJEUUVnQXlnQ0dDRUhBa0FDUUNBRElBTW9BZ3dpQVVZRVFDQURRUlJCRUNBRFFSUnFJZ0VvQWdBaUFodHFLQUlBSWdBTkFVRUFJUUVNQWdzZ0F5Z0NDQ0lBSUFFMkFnd2dBU0FBTmdJSURBRUxJQUVnQTBFUWFpQUNHeUVDQTBBZ0FpRUVJQUFpQVVFVWFpSUNLQUlBSWdCRkJFQWdBVUVRYWlFQ0lBRW9BaEFoQUFzZ0FBMEFDeUFFUVFBMkFnQUxBa0FnQjBVTkFBSkFJQU1nQXlnQ0hFRUNkRUhrcDhBQWFpSUFLQUlBUndSQUlBZEJFRUVVSUFjb0FoQWdBMFliYWlBQk5nSUFJQUZGRFFJTUFRc2dBQ0FCTmdJQUlBRU5BRUhZcGNBQVFkaWx3QUFvQWdCQmZpQURLQUljZDNFMkFnQU1BUXNnQVNBSE5nSVlJQU1vQWhBaUFBUkFJQUVnQURZQ0VDQUFJQUUyQWhnTElBTkJGR29vQWdBaUFFVU5BQ0FCUVJScUlBQTJBZ0FnQUNBQk5nSVlDd0pBSUFaQkVFOEVRQ0FESUFWQkEzSTJBZ1FnQXlBRmFpSUVJQVpCQVhJMkFnUWdCQ0FHYWlBR05nSUFJQVpCZ0FKUEJFQWdCRUlBTndJUUlBUUNmMEVBSUFaQkNIWWlBRVVOQUJwQkh5QUdRZi8vL3dkTERRQWFJQVpCQmlBQVp5SUFhMEVmY1haQkFYRWdBRUVCZEd0QlBtb0xJZ0EyQWh3Z0FFRUNkRUhrcDhBQWFpRUJBa0FDUUFKQUFrQkIyS1hBQUNnQ0FDSUNRUUVnQUVFZmNYUWlCWEVFUUNBQktBSUFJZ0pCQkdvb0FnQkJlSEVnQmtjTkFTQUNJUUFNQWd0QjJLWEFBQ0FDSUFWeU5nSUFJQUVnQkRZQ0FDQUVJQUUyQWhnTUF3c2dCa0VBUVJrZ0FFRUJkbXRCSDNFZ0FFRWZSaHQwSVFFRFFDQUNJQUZCSFhaQkJIRnFRUkJxSWdVb0FnQWlBRVVOQWlBQlFRRjBJUUVnQUNFQ0lBQkJCR29vQWdCQmVIRWdCa2NOQUFzTElBQW9BZ2dpQVNBRU5nSU1JQUFnQkRZQ0NDQUVRUUEyQWhnZ0JDQUFOZ0lNSUFRZ0FUWUNDQXdFQ3lBRklBUTJBZ0FnQkNBQ05nSVlDeUFFSUFRMkFnd2dCQ0FFTmdJSURBSUxJQVpCQTNZaUFVRURkRUhjcGNBQWFpRUFBbjlCMUtYQUFDZ0NBQ0lDUVFFZ0FYUWlBWEVFUUNBQUtBSUlEQUVMUWRTbHdBQWdBU0FDY2pZQ0FDQUFDeUVCSUFBZ0JEWUNDQ0FCSUFRMkFnd2dCQ0FBTmdJTUlBUWdBVFlDQ0F3QkN5QURJQVVnQm1vaUFFRURjallDQkNBQUlBTnFJZ0FnQUNnQ0JFRUJjallDQkFzZ0EwRUlhZzhMQWtBQ1FFSFVwY0FBS0FJQUlnSkJFQ0FBUVF0cVFYaHhJQUJCQzBrYklnVkJBM1lpQUhZaUFVRURjVVVFUUNBRlFlU293QUFvQWdCTkRRTWdBUTBCUWRpbHdBQW9BZ0FpQUVVTkF5QUFRUUFnQUd0eGFFRUNkRUhrcDhBQWFpZ0NBQ0lCUVFScUtBSUFRWGh4SUFWcklRWWdBU0VDQTBBZ0FTZ0NFQ0lBUlFSQUlBRkJGR29vQWdBaUFFVU5CQXNnQUVFRWFpZ0NBRUY0Y1NBRmF5SUJJQVlnQVNBR1NTSUJHeUVHSUFBZ0FpQUJHeUVDSUFBaEFRd0FDd0FMQWtBZ0FVRi9jMEVCY1NBQWFpSUFRUU4wUWRTbHdBQnFJZ1JCRUdvb0FnQWlBVUVJYWlJR0tBSUFJZ01nQkVFSWFpSUVSd1JBSUFNZ0JEWUNEQ0FFSUFNMkFnZ01BUXRCMUtYQUFDQUNRWDRnQUhkeE5nSUFDeUFCSUFCQkEzUWlBRUVEY2pZQ0JDQUFJQUZxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0ZDd0pBUVFJZ0FIUWlCa0VBSUFacmNpQUJJQUIwY1NJQVFRQWdBR3R4YUNJQlFRTjBRZFNsd0FCcUlnTkJFR29vQWdBaUFFRUlhaUlFS0FJQUlnWWdBMEVJYWlJRFJ3UkFJQVlnQXpZQ0RDQURJQVkyQWdnTUFRdEIxS1hBQUNBQ1FYNGdBWGR4TmdJQUN5QUFJQVZCQTNJMkFnUWdBQ0FGYWlJRElBRkJBM1FpQVNBRmF5SUNRUUZ5TmdJRUlBQWdBV29nQWpZQ0FFSGtxTUFBS0FJQUlnQUVRQ0FBUVFOMklnWkJBM1JCM0tYQUFHb2hBRUhzcU1BQUtBSUFJUUVDZjBIVXBjQUFLQUlBSWdWQkFTQUdRUjl4ZENJR2NRUkFJQUFvQWdnTUFRdEIxS1hBQUNBRklBWnlOZ0lBSUFBTElRWWdBQ0FCTmdJSUlBWWdBVFlDRENBQklBQTJBZ3dnQVNBR05nSUlDMEhzcU1BQUlBTTJBZ0JCNUtqQUFDQUNOZ0lBSUFRUEN5QUNLQUlZSVFjQ1FBSkFJQUlnQWlnQ0RDSUJSZ1JBSUFKQkZFRVFJQUpCRkdvaUFTZ0NBQ0lERzJvb0FnQWlBQTBCUVFBaEFRd0NDeUFDS0FJSUlnQWdBVFlDRENBQklBQTJBZ2dNQVFzZ0FTQUNRUkJxSUFNYklRTURRQ0FESVFRZ0FDSUJRUlJxSWdNb0FnQWlBRVVFUUNBQlFSQnFJUU1nQVNnQ0VDRUFDeUFBRFFBTElBUkJBRFlDQUFzZ0IwVU5BaUFDSUFJb0FoeEJBblJCNUtmQUFHb2lBQ2dDQUVjRVFDQUhRUkJCRkNBSEtBSVFJQUpHRzJvZ0FUWUNBQ0FCUlEwRERBSUxJQUFnQVRZQ0FDQUJEUUZCMktYQUFFSFlwY0FBS0FJQVFYNGdBaWdDSEhkeE5nSUFEQUlMQWtBQ1FBSkFBa0JCNUtqQUFDZ0NBQ0lBSUFWSkJFQkI2S2pBQUNnQ0FDSUFJQVZMRFFoQkFDRUdJQVZCcjRBRWFpSUFRUkIyUUFBaUFVRi9SZzBISUFGQkVIUWlCRVVOQjBIMHFNQUFJQUJCZ0lCOGNTSUhRZlNvd0FBb0FnQnFJZ0EyQWdCQitLakFBRUg0cU1BQUtBSUFJZ0VnQUNBQklBQkxHellDQUVId3FNQUFLQUlBSWdORkRRRkIvS2pBQUNFQUEwQWdBQ2dDQUNJQklBQW9BZ1FpQW1vZ0JFWU5BeUFBS0FJSUlnQU5BQXNNQXd0QjdLakFBQ2dDQUNFQkFuOGdBQ0FGYXlJQ1FROU5CRUJCN0tqQUFFRUFOZ0lBUWVTb3dBQkJBRFlDQUNBQklBQkJBM0kyQWdRZ0FDQUJhaUlDUVFScUlRQWdBaWdDQkVFQmNnd0JDMEhrcU1BQUlBSTJBZ0JCN0tqQUFDQUJJQVZxSWdZMkFnQWdCaUFDUVFGeU5nSUVJQUFnQVdvZ0FqWUNBQ0FCUVFScUlRQWdCVUVEY2dzaEFpQUFJQUkyQWdBZ0FVRUlhZzhMUVpDcHdBQW9BZ0FpQUVFQUlBQWdCRTBiUlFSQVFaQ3B3QUFnQkRZQ0FBdEJsS25BQUVIL0h6WUNBRUg4cU1BQUlBUTJBZ0JCaUtuQUFFRUFOZ0lBUVlDcHdBQWdCellDQUVIb3BjQUFRZHlsd0FBMkFnQkI4S1hBQUVIa3BjQUFOZ0lBUWVTbHdBQkIzS1hBQURZQ0FFSDRwY0FBUWV5bHdBQTJBZ0JCN0tYQUFFSGtwY0FBTmdJQVFZQ213QUJCOUtYQUFEWUNBRUgwcGNBQVFleWx3QUEyQWdCQmlLYkFBRUg4cGNBQU5nSUFRZnlsd0FCQjlLWEFBRFlDQUVHUXBzQUFRWVNtd0FBMkFnQkJoS2JBQUVIOHBjQUFOZ0lBUVppbXdBQkJqS2JBQURZQ0FFR01wc0FBUVlTbXdBQTJBZ0JCb0tiQUFFR1Vwc0FBTmdJQVFaU213QUJCaktiQUFEWUNBRUdvcHNBQVFaeW13QUEyQWdCQm5LYkFBRUdVcHNBQU5nSUFRYVNtd0FCQm5LYkFBRFlDQUVHd3BzQUFRYVNtd0FBMkFnQkJyS2JBQUVHa3BzQUFOZ0lBUWJpbXdBQkJyS2JBQURZQ0FFRzBwc0FBUWF5bXdBQTJBZ0JCd0tiQUFFRzBwc0FBTmdJQVFieW13QUJCdEtiQUFEWUNBRUhJcHNBQVFieW13QUEyQWdCQnhLYkFBRUc4cHNBQU5nSUFRZENtd0FCQnhLYkFBRFlDQUVITXBzQUFRY1Ntd0FBMkFnQkIyS2JBQUVITXBzQUFOZ0lBUWRTbXdBQkJ6S2JBQURZQ0FFSGdwc0FBUWRTbXdBQTJBZ0JCM0tiQUFFSFVwc0FBTmdJQVFlaW13QUJCM0tiQUFEWUNBRUh3cHNBQVFlU213QUEyQWdCQjVLYkFBRUhjcHNBQU5nSUFRZmltd0FCQjdLYkFBRFlDQUVIc3BzQUFRZVNtd0FBMkFnQkJnS2ZBQUVIMHBzQUFOZ0lBUWZTbXdBQkI3S2JBQURZQ0FFR0lwOEFBUWZ5bXdBQTJBZ0JCL0tiQUFFSDBwc0FBTmdJQVFaQ253QUJCaEtmQUFEWUNBRUdFcDhBQVFmeW13QUEyQWdCQm1LZkFBRUdNcDhBQU5nSUFRWXlud0FCQmhLZkFBRFlDQUVHZ3A4QUFRWlNud0FBMkFnQkJsS2ZBQUVHTXA4QUFOZ0lBUWFpbndBQkJuS2ZBQURZQ0FFR2NwOEFBUVpTbndBQTJBZ0JCc0tmQUFFR2twOEFBTmdJQVFhU253QUJCbktmQUFEWUNBRUc0cDhBQVFheW53QUEyQWdCQnJLZkFBRUdrcDhBQU5nSUFRY0Nud0FCQnRLZkFBRFlDQUVHMHA4QUFRYXlud0FBMkFnQkJ5S2ZBQUVHOHA4QUFOZ0lBUWJ5bndBQkJ0S2ZBQURZQ0FFSFFwOEFBUWNTbndBQTJBZ0JCeEtmQUFFRzhwOEFBTmdJQVFkaW53QUJCektmQUFEWUNBRUhNcDhBQVFjU253QUEyQWdCQjRLZkFBRUhVcDhBQU5nSUFRZFNud0FCQnpLZkFBRFlDQUVId3FNQUFJQVEyQWdCQjNLZkFBRUhVcDhBQU5nSUFRZWlvd0FBZ0IwRllhaUlBTmdJQUlBUWdBRUVCY2pZQ0JDQUFJQVJxUVNnMkFnUkJqS25BQUVHQWdJQUJOZ0lBREFJTElBQkJER29vQWdBRVFBd0JDeUFFSUFOTklBRWdBMHR5RFFBZ0FDQUNJQWRxTmdJRVFmQ293QUJCOEtqQUFDZ0NBQ0lBUVE5cVFYaHhJZ0ZCZUdvMkFnQkI2S2pBQUVIb3FNQUFLQUlBSUFkcUlnSWdBQ0FCYTJwQkNHb2lBellDQUNBQlFYeHFJQU5CQVhJMkFnQWdBQ0FDYWtFb05nSUVRWXlwd0FCQmdJQ0FBVFlDQUF3QkMwR1FxY0FBUVpDcHdBQW9BZ0FpQUNBRUlBQWdCRWtiTmdJQUlBUWdCMm9oQWtIOHFNQUFJUUFDUUFKQUEwQWdBaUFBS0FJQVJ3UkFJQUFvQWdnaUFBMEJEQUlMQ3lBQVFReHFLQUlBUlEwQkMwSDhxTUFBSVFBRFFBSkFJQUFvQWdBaUFTQURUUVJBSUFFZ0FDZ0NCR29pQWlBRFN3MEJDeUFBS0FJSUlRQU1BUXNMUWZDb3dBQWdCRFlDQUVIb3FNQUFJQWRCV0dvaUFEWUNBQ0FFSUFCQkFYSTJBZ1FnQUNBRWFrRW9OZ0lFUVl5cHdBQkJnSUNBQVRZQ0FDQURJQUpCWUdwQmVIRkJlR29pQUNBQUlBTkJFR3BKR3lJQlFSczJBZ1JCL0tqQUFDa0NBQ0VKSUFGQkVHcEJoS25BQUNrQ0FEY0NBQ0FCSUFrM0FnaEJpS25BQUVFQU5nSUFRWUNwd0FBZ0J6WUNBRUg4cU1BQUlBUTJBZ0JCaEtuQUFDQUJRUWhxTmdJQUlBRkJIR29oQUFOQUlBQkJCellDQUNBQ0lBQkJCR29pQUVzTkFBc2dBU0FEUmcwQklBRWdBU2dDQkVGK2NUWUNCQ0FESUFFZ0Eyc2lCRUVCY2pZQ0JDQUJJQVEyQWdBZ0JFR0FBazhFUUNBRFFnQTNBaEFnQTBFY2FnSi9RUUFnQkVFSWRpSUFSUTBBR2tFZklBUkIvLy8vQjBzTkFCb2dCRUVHSUFCbklnQnJRUjl4ZGtFQmNTQUFRUUYwYTBFK2Fnc2lBRFlDQUNBQVFRSjBRZVNud0FCcUlRRUNRQUpBQWtBQ1FFSFlwY0FBS0FJQUlnSkJBU0FBUVI5eGRDSUhjUVJBSUFFb0FnQWlBVUVFYWlnQ0FFRjRjU0FFUncwQklBRWhBQXdDQzBIWXBjQUFJQUlnQjNJMkFnQWdBU0FETmdJQURBTUxJQVJCQUVFWklBQkJBWFpyUVI5eElBQkJIMFliZENFQ0EwQWdBU0FDUVIxMlFRUnhha0VRYWlJSEtBSUFJZ0JGRFFJZ0FrRUJkQ0VDSUFBaEFTQUFRUVJxS0FJQVFYaHhJQVJIRFFBTEN5QUFLQUlJSWdFZ0F6WUNEQ0FBSUFNMkFnZ2dBMEVZYWtFQU5nSUFJQU1nQURZQ0RDQURJQUUyQWdnTUJBc2dCeUFETmdJQUN5QURRUmhxSUFFMkFnQWdBeUFETmdJTUlBTWdBellDQ0F3Q0N5QUVRUU4ySWdGQkEzUkIzS1hBQUdvaEFBSi9RZFNsd0FBb0FnQWlBa0VCSUFGMElnRnhCRUFnQUNnQ0NBd0JDMEhVcGNBQUlBRWdBbkkyQWdBZ0FBc2hBU0FBSUFNMkFnZ2dBU0FETmdJTUlBTWdBRFlDRENBRElBRTJBZ2dNQVFzZ0FDQUVOZ0lBSUFBZ0FDZ0NCQ0FIYWpZQ0JDQUVJQVZCQTNJMkFnUWdCQ0FGYWlFQUlBSWdCR3NnQldzaEJRSkFBa0FnQWtId3FNQUFLQUlBUndSQVFleW93QUFvQWdBZ0FrWU5BU0FDUVFScUtBSUFJZ0ZCQTNGQkFVWUVRQ0FDSUFGQmVIRWlBUkFSSUFFZ0JXb2hCU0FCSUFKcUlRSUxJQUlnQWlnQ0JFRitjVFlDQkNBQUlBVkJBWEkyQWdRZ0FDQUZhaUFGTmdJQUlBVkJnQUpQQkVBZ0FFSUFOd0lRSUFBQ2YwRUFJQVZCQ0hZaUFVVU5BQnBCSHlBRlFmLy8vd2RMRFFBYUlBVkJCaUFCWnlJQmEwRWZjWFpCQVhFZ0FVRUJkR3RCUG1vTElnRTJBaHdnQVVFQ2RFSGtwOEFBYWlFQ0FrQUNRQUpBQWtCQjJLWEFBQ2dDQUNJR1FRRWdBVUVmY1hRaUEzRUVRQ0FDS0FJQUlnSkJCR29vQWdCQmVIRWdCVWNOQVNBQ0lRWU1BZ3RCMktYQUFDQURJQVp5TmdJQUlBSWdBRFlDQUF3REN5QUZRUUJCR1NBQlFRRjJhMEVmY1NBQlFSOUdHM1FoQVFOQUlBSWdBVUVkZGtFRWNXcEJFR29pQXlnQ0FDSUdSUTBDSUFGQkFYUWhBU0FHSWdKQkJHb29BZ0JCZUhFZ0JVY05BQXNMSUFZb0FnZ2lBU0FBTmdJTUlBWWdBRFlDQ0NBQVFRQTJBaGdnQUNBR05nSU1JQUFnQVRZQ0NBd0ZDeUFESUFBMkFnQUxJQUFnQWpZQ0dDQUFJQUEyQWd3Z0FDQUFOZ0lJREFNTElBVkJBM1lpQWtFRGRFSGNwY0FBYWlFQkFuOUIxS1hBQUNnQ0FDSUdRUUVnQW5RaUFuRUVRQ0FCS0FJSURBRUxRZFNsd0FBZ0FpQUdjallDQUNBQkN5RUNJQUVnQURZQ0NDQUNJQUEyQWd3Z0FDQUJOZ0lNSUFBZ0FqWUNDQXdDQzBId3FNQUFJQUEyQWdCQjZLakFBRUhvcU1BQUtBSUFJQVZxSWdFMkFnQWdBQ0FCUVFGeU5nSUVEQUVMUWV5b3dBQWdBRFlDQUVIa3FNQUFRZVNvd0FBb0FnQWdCV29pQVRZQ0FDQUFJQUZCQVhJMkFnUWdBQ0FCYWlBQk5nSUFDeUFFUVFocUR3dEI2S2pBQUNnQ0FDSUFJQVZORFFJTUF3c2dBU0FITmdJWUlBSW9BaEFpQUFSQUlBRWdBRFlDRUNBQUlBRTJBaGdMSUFKQkZHb29BZ0FpQUVVTkFDQUJRUlJxSUFBMkFnQWdBQ0FCTmdJWUN3SkFJQVpCRUU4RVFDQUNJQVZCQTNJMkFnUWdBaUFGYWlJRElBWkJBWEkyQWdRZ0F5QUdhaUFHTmdJQVFlU293QUFvQWdBaUFBUkFJQUJCQTNZaUJFRURkRUhjcGNBQWFpRUFRZXlvd0FBb0FnQWhBUUovUWRTbHdBQW9BZ0FpQlVFQklBUkJIM0YwSWdSeEJFQWdBQ2dDQ0F3QkMwSFVwY0FBSUFRZ0JYSTJBZ0FnQUFzaEJDQUFJQUUyQWdnZ0JDQUJOZ0lNSUFFZ0FEWUNEQ0FCSUFRMkFnZ0xRZXlvd0FBZ0F6WUNBRUhrcU1BQUlBWTJBZ0FNQVFzZ0FpQUZJQVpxSWdCQkEzSTJBZ1FnQUNBQ2FpSUFJQUFvQWdSQkFYSTJBZ1FMSUFKQkNHb1BDeUFHRHd0QjZLakFBQ0FBSUFWcklnRTJBZ0JCOEtqQUFFSHdxTUFBS0FJQUlnQWdCV29pQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FGUVFOeU5nSUVJQUJCQ0dvTDRSQUNFbjhDZmlNQVFZQUJheUlHSkFBZ0JpQUROZ0lzSUFZZ0FqWUNLQUpBQW44Q1FBSkFBa0FDUUFKL0FrQWdBUzBBUjBVRVFDQUJLUU00SVJnZ0FVSUFOd000UVFFaERDQVlwMEgvL3dOeFFRRkhEUUVnR0VJd2lLY2hFU0FZUWhDSXB5RU5JQmhDSUlpbkRBSUxJQUJCQWpvQUNDQUFRZ0EzQWdBTUJ3c2dCa0VnYWlBQklBWkJLR29RS3lBR0x3RWdSUTBFUVFNaERDQUdMd0VpSWcwaUFpQUJMd0ZBVHcwRUlBSWdBUzhCUWtZTkFTQUJMd0ZFSUExQi8vOERjVVlOQWlBQlFSaHFLQUlBUlEwRUlBRkJLR29nQVVFUWFpSUhJQTBRSmhvZ0FTZ0NHQ0lDSUExQi8vOERjU0lLVFEwRElBY29BZ0FnQ2tFQ2RHb2lBaTBBQWlFUklBSXZBUUFMSVJNZ0JrRVlhaUFCUVNocUVFRWdCaWdDR0NFQ0FrQWdCaWdDSENJSElBVk5CRUFnQncwQlFRRWhFa0VCSVF3Z0JTRUhRUUVNQmdzZ0JVVUVRRUVCSVF4QkFDRUhRUUVNQmdzZ0JDQUNJQVVRU1JvZ0FVRXdhaUlDSUFJb0FnQWdCV28yQWdCQnI0WEFBQ0VFUVFBaERFRUFJUWRCQVF3RkN5QUVJQUlnQnhCSklBRkJNR29pQWlBQ0tBSUFJQWRxTmdJQUlBZHFJUVFnQlNBSGF5RUhRUUFoREVFQkRBUUxJQUVnQVMwQVJpSUhRUUZxSWdJNkFBb2dBVUVCSUFkQkQzRjBRUUpxT3dGQUlBRkJmeUFDUVE5eGRFRi9jenNCQ0NBQlFSQnFJQWNRRFVFQUlRMUJBQ0VNSUFVaEIwRUFEQU1MSUFGQkFUb0FSMEVDSVF3TUFRc2dDaUFDUWFDSXdBQVFOUUFMUVFBaERTQUZJUWRCQUFzaEFpQUdRVGhxUVFBMkFnQWdCa0lBTndNd0lBWkJ5QUJxUVFBMkFnQWdCa0lBTndOQUlBWkIvQUJxUVFBMkFnQWdCa0gwQUdwQkFEWUNBQ0FHUWV3QWFrRUFOZ0lBSUFaQjVBQnFRUUEyQWdBZ0JrSGNBR3BCQURZQ0FDQUdRWUNEd0FBMkFuZ2dCa0dBZzhBQU5nSndJQVpCZ0lQQUFEWUNhQ0FHUVlDRHdBQTJBbUFnQmtHQWc4QUFOZ0pZSUFaQkFEWUNWQ0FHUVlDRHdBQTJBbEFDUUFKL0FrQWdBa1VOQUNBQlFSQnFJUlFnQVVFb2FpRVZJQVpCeUFCcUlSY2dCa0UrYWlFV0FrQUNRQUpBQWtBQ1FBSkFBa0FEUUFKQUlBY05BQ0FHUVJCcUlCVVFRU0FHS0FJVVJRMEFRUUFoQnd3SUN5QUJJQVpCS0dvUUYwRUFJUXNnRnlFUVFRQWhEZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQURRQ0FCTFFBTElnSWdBUzBBQ2lJSVNRUkFJQTROQTBFQklBd2dFaHNoREF3UkN5QUJJQUlnQ0dzNkFBc2dCa0V3YWlBTGFpSUtJQUV2QVFnaUFpQUJLUU1BSUFpdGlTSVlwM0U3QVFBZ0FTQVlJQUt0UW4rRlFvQ0FmSVNETndNQUlBNEVRQ0FPUVg5cVFRVkxEUVFnQnlBTElCWnFMd0VBSWdKSkRRVWdFQ0FFTmdJQUlCQkJCR29nQWpZQ0FDQUhJQUpySVFjZ0FpQUVhaUVFQ3lBQkx3RkFJZ0lnRG1wQi8vOERjU0FCTHdFSUlBRXRBRWhyUWYvL0EzRkdEUUVnQ2k4QkFDSUtJQUpQRFFFZ0NpQUJMd0ZDUmcwQklBb2dBUzhCUkVZTkFTQUJLQUlrSWdJZ0NrME5CU0FISUFFb0Fod2dDa0VCZEdvdkFRQWlBa2tOQVNBT1FRRnFJUTRnQ3lBV2FrRUNhaUFDT3dFQUlCQkJDR29oRUNBTFFRSnFJZ3RCREVjTkFBdEJCaUVPUVFVaEVDQUdMd0U2SVFnTUJnc2dEa0VCYWlFT0N5QU9RUWRQRFFNZ0JrRXdhaUFPUVg5cUloQkJBWFJxTHdFQUlRZ2dFQTBFSUEwaENnd0ZDeUFPUVg5cVFRWkJzSVhBQUJBMUFBdEJnSVBBQUVFY1FZeUV3QUFRUndBTElBb2dBa0hBaGNBQUVEVUFDeUFPUVFaQjBJWEFBQkEyQUFzZ0JrSFFBR29oQWlBR1FUQnFJUXNEUUNBR1FRaHFJQlFnRkNBTEx3RUFJZ29nQWlnQ0FDQUNRUVJxS0FJQUVDa2dEUkFqSUFZdEFBb2hFU0FHTHdFSUlSTWdBU0FCTHdGQVFRRnFPd0ZBSUF0QkFtb2hDeUFDUVFocUlRSWdDaUVOSUJCQmYyb2lFQTBBQ3lBT1FRTjBJQVpxUVVCcklnSW9BZ1FoQ1NBQ1FRQTJBZ1FnQWlnQ0FDRVBJQUpCcjRYQUFEWUNBQXNnQ0NJTklBRXZBVUpHRFFFQ1FDQUJMd0ZFSUFoSEJFQWdDQ0FCTHdGQUlnSk5EUUZCQXlFTVFRQU1Dd3NnQVVFQk9nQkhRUUloREVFQURBb0xBa0FDZnlBSEFuOENRQUpBSUFJZ0NFY0VRQ0FCS0FJa0lnSWdDRXNOQVNBSUlBSkI4SVhBQUJBMUFBc2dBU2dDSkNJQ0lBcEIvLzhEY1NJSVRRMEhJQWNnQVNnQ0hDQUlRUUYwYWk4QkFFRUJha0gvL3dOeElnSlBEUUVnRHdSQUlBRW9BaXdpQWlBSlNRMEpJQUVvQWlnZ0R5QUpFRWthSUFFZ0NUWUNNQ0FCSUFrMkFqUUxRUUFoRHlBVkVESWhDMEVCREFNTElBY2dBU2dDSENBSVFRRjBhaThCQUNJQ1NRUkFRUUFoRHlBVklCUWdEUkFtSVF0QkFRd0RDeUFVSUEwZ0JDQUNFQ2toQ3lBQ0RBRUxJQTlGQkVBZ0FTZ0NMQ0lJSUFFb0FqUWlDVWtOQ0NBVktBSUFJUThMSUFsRkRRSWdDU0FDU3cwSUlBOHRBQUFoQ3lBRUlBOGdDUkJKSUFJZ0NVWU5DU0FKYWlBTE9nQUFJQUlMSWdscklRY2dDU0FFSWc5cUlRUkJBQXNnQVNnQ0dFSC9IMDBFUUNBR0lCUWdDeUFLRUNNZ0FTOEJRQ0VRSUFZdEFBSWhFU0FHTHdFQUlSTUNRQ0FCTFFBS0lnaEJDMHNOQUNBUUlBRXZBUWdpQ2lBQkxRQklhMEgvL3dOeFJ3MEFJQUVnQ0VFQmFqb0FDaUFCSUFwQkFYUkJBWEk3QVFnTElBRWdFRUVCYWpzQlFBdEJBQ0VTUlEwQkRBZ0xDMEVBUVFCQm9JYkFBQkExQUFzZ0FSQXpEQVlMSUFnZ0FrSGdoY0FBRURVQUN5QUpJQUpCZ0liQUFCQTJBQXNnQ1NBSVFaQ0d3QUFRTmdBTElBa2dBa0d3aHNBQUVEWUFDMEVBUVFCQndJYkFBQkExQUF0Q0FTRVpJQTlGRFFJZ0FTZ0NMQ0lDSUFsUEJFQWdBU2dDS0NBUElBa1FTUm9nQVNBSk5nSXdJQUVnQ1RZQ05Bd0RDeUFKSUFKQjBJYkFBQkEyQUF0QkFBc2hEVUVBSVJOQkFDRVJDeUFBSUFVZ0IyczJBZ1FnQUNBRElBWW9BaXdpQW1zMkFnQWdBRUVBSUF3Z0F5QUNTeHNnRENBTVFRRkdHem9BQ0NBQklBMnRRdi8vQTROQ0VJWWdHWVFnRTYxQy8vOERnMElnaG9RZ0VhMUMvd0dEUWpDR2hEY0RPQXNnQmtHQUFXb2tBQXZXRUFJUmZ3SitJd0JCZ0FGcklnWWtBQ0FHSUFNMkFpd2dCaUFDTmdJb0FrQUNmd0pBQWtBQ1FBSkFBbjhDUUNBQkxRQkhSUVJBSUFFcEF6Z2hGeUFCUWdBM0F6aEJBU0VNSUJlblFmLy9BM0ZCQVVjTkFTQVhRakNJcHlFUklCZENFSWluSVEwZ0YwSWdpS2NNQWdzZ0FFRUNPZ0FJSUFCQ0FEY0NBQXdIQ3lBR1FTQnFJQUVnQmtFb2FoQXRJQVl2QVNCRkRRUkJBeUVNSUFZdkFTSWlEU0lDSUFFdkFVQlBEUVFnQWlBQkx3RkNSZzBCSUFFdkFVUWdEVUgvL3dOeFJnMENJQUZCR0dvb0FnQkZEUVFnQVVFb2FpQUJRUkJxSWdjZ0RSQW1HaUFCS0FJWUlnSWdEVUgvL3dOeElnbE5EUU1nQnlnQ0FDQUpRUUowYWlJQ0xRQUNJUkVnQWk4QkFBc2hFaUFHUVJocUlBRkJLR29RUVNBR0tBSVlJUUlDUUNBR0tBSWNJZ2NnQlUwRVFDQUhEUUZCQVNFSVFRRWhEQ0FGSVFkQkFRd0dDeUFGUlFSQVFRRWhERUVBSVFkQkFRd0dDeUFFSUFJZ0JSQkpHaUFCUVRCcUlnSWdBaWdDQUNBRmFqWUNBRUd2aGNBQUlRUkJBQ0VNUVFBaEIwRUJEQVVMSUFRZ0FpQUhFRWtnQVVFd2FpSUNJQUlvQWdBZ0IybzJBZ0FnQjJvaEJDQUZJQWRySVFkQkFDRU1RUUVNQkFzZ0FTQUJMUUJHSWdkQkFXb2lBam9BQ2lBQlFRRWdCMEVQY1hSQkFtbzdBVUFnQVVGL0lBSkJEM0YwUVg5ek93RUlJQUZCRUdvZ0J4QU5RUUFoRFVFQUlRd2dCU0VIUVFBTUF3c2dBVUVCT2dCSFFRSWhEQXdCQ3lBSklBSkJvSWpBQUJBMUFBdEJBQ0VOSUFVaEIwRUFDeUVDSUFaQk9HcEJBRFlDQUNBR1FnQTNBekFnQmtISUFHcEJBRFlDQUNBR1FnQTNBMEFnQmtIOEFHcEJBRFlDQUNBR1FmUUFha0VBTmdJQUlBWkI3QUJxUVFBMkFnQWdCa0hrQUdwQkFEWUNBQ0FHUWR3QWFrRUFOZ0lBSUFaQmdJUEFBRFlDZUNBR1FZQ0R3QUEyQW5BZ0JrR0FnOEFBTmdKb0lBWkJnSVBBQURZQ1lDQUdRWUNEd0FBMkFsZ2dCa0VBTmdKVUlBWkJnSVBBQURZQ1VBSkFBbjhDUUNBQ1JRMEFJQUZCRUdvaEV5QUJRU2hxSVJRZ0JrSElBR29oRmlBR1FUNXFJUlVDUUFKQUFrQUNRQUpBQWtBQ1FBTkFBa0FnQncwQUlBWkJFR29nRkJCQklBWW9BaFJGRFFCQkFDRUhEQWdMSUFFZ0JrRW9haEFmUVFBaEN5QVdJUkJCQUNFT0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFOQUlBRXRBQXNpQWlBQkxRQUtJZ2xKQkVBZ0RnMERRUUVnRENBSUd5RU1EQkVMSUFFZ0FpQUphem9BQ3lBQklBRXBBd0FpRnlBSnJVSS9nNGczQXdBZ0JrRXdhaUFMYWlJSklBRXZBUWdnRjZkeE93RUFJQTRFUUNBT1FYOXFRUVZMRFFRZ0J5QUxJQlZxTHdFQUlnSkpEUVVnRUNBRU5nSUFJQkJCQkdvZ0FqWUNBQ0FISUFKcklRY2dBaUFFYWlFRUN5QUJMd0ZBSWdJZ0RtcEIvLzhEY1NBQkx3RUlJQUV0QUVoclFmLy9BM0ZHRFFFZ0NTOEJBQ0lKSUFKUERRRWdDU0FCTHdGQ1JnMEJJQWtnQVM4QlJFWU5BU0FCS0FJa0lnSWdDVTBOQlNBSElBRW9BaHdnQ1VFQmRHb3ZBUUFpQWtrTkFTQU9RUUZxSVE0Z0N5QVZha0VDYWlBQ093RUFJQkJCQ0dvaEVDQUxRUUpxSWd0QkRFY05BQXRCQmlFT1FRVWhFQ0FHTHdFNklRZ01CZ3NnRGtFQmFpRU9DeUFPUVFkUERRTWdCa0V3YWlBT1FYOXFJaEJCQVhScUx3RUFJUWdnRUEwRUlBMGhDUXdGQ3lBT1FYOXFRUVpCc0lYQUFCQTFBQXRCZ0lQQUFFRWNRWXlFd0FBUVJ3QUxJQWtnQWtIQWhjQUFFRFVBQ3lBT1FRWkIwSVhBQUJBMkFBc2dCa0hRQUdvaEFpQUdRVEJxSVFzRFFDQUdRUWhxSUJNZ0V5QUxMd0VBSWdrZ0FpZ0NBQ0FDUVFScUtBSUFFQ2tnRFJBaklBWXRBQW9oRVNBR0x3RUlJUklnQVNBQkx3RkFRUUZxT3dGQUlBdEJBbW9oQ3lBQ1FRaHFJUUlnQ1NFTklCQkJmMm9pRUEwQUN5QU9RUU4wSUFacVFVQnJJZ0lvQWdRaENpQUNRUUEyQWdRZ0FpZ0NBQ0VQSUFKQnI0WEFBRFlDQUFzZ0NDSU5JQUV2QVVKR0RRRUNRQ0FCTHdGRUlBaEhCRUFnQ0NBQkx3RkFJZ0pORFFGQkF5RU1RUUFNQ3dzZ0FVRUJPZ0JIUVFJaERFRUFEQW9MQWtBQ2Z5QUhBbjhDUUFKQUlBSWdDRWNFUUNBQktBSWtJZ0lnQ0VzTkFTQUlJQUpCOElYQUFCQTFBQXNnQVNnQ0pDSUNJQWxCLy84RGNTSUlUUTBISUFjZ0FTZ0NIQ0FJUVFGMGFpOEJBRUVCYWtILy93TnhJZ0pQRFFFZ0R3UkFJQUVvQWl3aUFpQUtTUTBKSUFFb0FpZ2dEeUFLRUVrYUlBRWdDallDTUNBQklBbzJBalFMUVFBaER5QVVFREloQzBFQkRBTUxJQWNnQVNnQ0hDQUlRUUYwYWk4QkFDSUNTUVJBUVFBaER5QVVJQk1nRFJBbUlRdEJBUXdEQ3lBVElBMGdCQ0FDRUNraEN5QUNEQUVMSUE5RkJFQWdBU2dDTENJSUlBRW9BalFpQ2trTkNDQVVLQUlBSVE4TElBcEZEUUlnQ2lBQ1N3MElJQTh0QUFBaEN5QUVJQThnQ2hCSklBSWdDa1lOQ1NBS2FpQUxPZ0FBSUFJTElncHJJUWNnQ2lBRUlnOXFJUVJCQUFzZ0FTZ0NHRUgvSDAwRVFDQUdJQk1nQ3lBSkVDTWdBUzhCUUNFUUlBWXRBQUloRVNBR0x3RUFJUklDUUNBQkxRQUtJZ2hCQzBzTkFDQVFJQUV2QVFnaUNTQUJMUUJJYTBILy93TnhSdzBBSUFFZ0NFRUJham9BQ2lBQklBbEJBWFJCQVhJN0FRZ0xJQUVnRUVFQmFqc0JRQXRCQUNFSVJRMEJEQWdMQzBFQVFRQkJvSWJBQUJBMUFBc2dBUkF6REFZTElBZ2dBa0hnaGNBQUVEVUFDeUFLSUFKQmdJYkFBQkEyQUFzZ0NpQUlRWkNHd0FBUU5nQUxJQW9nQWtHd2hzQUFFRFlBQzBFQVFRQkJ3SWJBQUJBMUFBdENBU0VZSUE5RkRRSWdBU2dDTENJQ0lBcFBCRUFnQVNnQ0tDQVBJQW9RU1JvZ0FTQUtOZ0l3SUFFZ0NqWUNOQXdEQ3lBS0lBSkIwSWJBQUJBMkFBdEJBQXNoRFVFQUlSSkJBQ0VSQ3lBQUlBVWdCMnMyQWdRZ0FDQURJQVlvQWl3aUFtczJBZ0FnQUVFQUlBd2dBeUFDU3hzZ0RDQU1RUUZHR3pvQUNDQUJJQTJ0UXYvL0E0TkNFSVlnR0lRZ0VxMUMvLzhEZzBJZ2hvUWdFYTFDL3dHRFFqQ0doRGNET0FzZ0JrR0FBV29rQUF1cUNBRUdmeU1BUWZBQWF5SUZKQUFnQlNBRE5nSU1JQVVnQWpZQ0NFRUJJUWNnQVNFR0FrQWdBVUdCQWtrTkFFRUFJQUZySVFsQmdBSWhDQU5BQWtBZ0NDQUJUdzBBUVFBaEJ5QUFJQWhxTEFBQVFiOS9UQTBBSUFnaEJnd0NDeUFJUVg5cUlRWkJBQ0VISUFoQkFVWU5BU0FJSUFscUlBWWhDRUVCUncwQUN3c2dCU0FHTmdJVUlBVWdBRFlDRUNBRlFRQkJCU0FIR3pZQ0hDQUZRYlNLd0FCQmhKSEFBQ0FIR3pZQ0dBSkFBbjhDUUFKQUlBSWdBVXNpQnlBRElBRkxja1VFUUNBQ0lBTkxEUUVDUUNBQ1JTQUJJQUpHY2tVRVFDQUJJQUpORFFFZ0FDQUNhaXdBQUVGQVNBMEJDeUFESVFJTElBVWdBallDSUNBQ1FRQWdBU0FDUnh0RkJFQWdBaUVIREFNTElBRkJBV29oQXdOQUFrQWdBaUFCVHcwQUlBQWdBbW9zQUFCQlFFZ05BQ0FDSVFjZ0JVRWthZ3dGQ3lBQ1FYOXFJUWNnQWtFQlJnMERJQUlnQTBZZ0J5RUNSUTBBQ3d3Q0N5QUZJQUlnQXlBSEd6WUNLQ0FGUWNRQWFrRUROZ0lBSUFWQjNBQnFRUmsyQWdBZ0JVSFVBR3BCR1RZQ0FDQUZRZ00zQWpRZ0JVR3NrY0FBTmdJd0lBVkJHRFlDVENBRklBVkJ5QUJxTmdKQUlBVWdCVUVZYWpZQ1dDQUZJQVZCRUdvMkFsQWdCU0FGUVNocU5nSklEQU1MSUFWQjVBQnFRUmsyQWdBZ0JVSGNBR3BCR1RZQ0FDQUZRZFFBYWtFWU5nSUFJQVZCeEFCcVFRUTJBZ0FnQlVJRU53STBJQVZCNkpIQUFEWUNNQ0FGUVJnMkFrd2dCU0FGUWNnQWFqWUNRQ0FGSUFWQkdHbzJBbUFnQlNBRlFSQnFOZ0pZSUFVZ0JVRU1hallDVUNBRklBVkJDR28yQWtnTUFnc2dCVUVrYWdzaENBSkFJQUVnQjBZTkFFRUJJUU1DUUFKQUFrQWdBQ0FIYWlJR0xBQUFJZ0pCZjB3RVFFRUFJUU1nQUNBQmFpSUJJUUFnQVNBR1FRRnFSd1JBSUFZdEFBRkJQM0VoQXlBR1FRSnFJUUFMSUFKQkgzRWhDU0FDUWY4QmNVSGZBVXNOQVNBRElBbEJCblJ5SVFJTUFnc2dCU0FDUWY4QmNUWUNKQ0FGUVNocUlRRU1BZ3RCQUNFS0lBRWhCaUFBSUFGSEJFQWdBQzBBQUVFL2NTRUtJQUJCQVdvaEJnc2dDaUFEUVFaMGNpRUFJQUpCL3dGeFFmQUJTUVJBSUFBZ0NVRU1kSEloQWd3QkMwRUFJUUlnQVNBR1J3Ui9JQVl0QUFCQlAzRUZRUUFMSUFsQkVuUkJnSUR3QUhFZ0FFRUdkSEp5SWdKQmdJREVBRVlOQWdzZ0JTQUNOZ0lrUVFFaEF5QUZRU2hxSVFFZ0FrR0FBVWtOQUVFQ0lRTWdBa0dBRUVrTkFFRURRUVFnQWtHQWdBUkpHeUVEQ3lBRklBYzJBaWdnQlNBRElBZHFOZ0lzSUFWQnhBQnFRUVUyQWdBZ0JVSHNBR3BCR1RZQ0FDQUZRZVFBYWtFWk5nSUFJQVZCM0FCcVFSbzJBZ0FnQlVIVUFHcEJHellDQUNBRlFnVTNBalFnQlVHOGtzQUFOZ0l3SUFVZ0FUWUNXQ0FGSUFnMkFsQWdCVUVZTmdKTUlBVWdCVUhJQUdvMkFrQWdCU0FGUVJocU5nSm9JQVVnQlVFUWFqWUNZQ0FGSUFWQklHbzJBa2dNQVF0QndJckFBRUVySUFRUVJ3QUxJQVZCTUdvZ0JCQlFBQXZjQ0FFRmZ5QUFRWGhxSWdFZ0FFRjhhaWdDQUNJRFFYaHhJZ0JxSVFJQ1FBSkFBa0FDUUNBRFFRRnhEUUFnQTBFRGNVVU5BU0FCS0FJQUlnTWdBR29oQUNBQklBTnJJZ0ZCN0tqQUFDZ0NBRVlFUUNBQ0tBSUVRUU54UVFOSERRRkI1S2pBQUNBQU5nSUFJQUlnQWlnQ0JFRitjVFlDQkNBQklBQkJBWEkyQWdRZ0FDQUJhaUFBTmdJQUR3c2dBU0FERUJFTEFrQWdBa0VFYWlJRUtBSUFJZ05CQW5FRVFDQUVJQU5CZm5FMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdCQ3dKQUlBSkI4S2pBQUNnQ0FFY0VRRUhzcU1BQUtBSUFJQUpHRFFFZ0FpQURRWGh4SWdJUUVTQUJJQUFnQW1vaUFFRUJjallDQkNBQUlBRnFJQUEyQWdBZ0FVSHNxTUFBS0FJQVJ3MENRZVNvd0FBZ0FEWUNBQThMUWZDb3dBQWdBVFlDQUVIb3FNQUFRZWlvd0FBb0FnQWdBR29pQURZQ0FDQUJJQUJCQVhJMkFnUkI3S2pBQUNnQ0FDQUJSZ1JBUWVTb3dBQkJBRFlDQUVIc3FNQUFRUUEyQWdBTFFZeXB3QUFvQWdBaUFpQUFUdzBDUWZDb3dBQW9BZ0FpQUVVTkFnSkFRZWlvd0FBb0FnQWlBMEVwU1EwQVFmeW93QUFoQVFOQUlBRW9BZ0FpQkNBQVRRUkFJQVFnQVNnQ0JHb2dBRXNOQWdzZ0FTZ0NDQ0lCRFFBTEMwR1VxY0FBQW45Qi94OUJoS25BQUNnQ0FDSUFSUTBBR2tFQUlRRURRQ0FCUVFGcUlRRWdBQ2dDQ0NJQURRQUxJQUZCL3g4Z0FVSC9IMHNiQ3pZQ0FDQURJQUpORFFKQmpLbkFBRUYvTmdJQUR3dEI3S2pBQUNBQk5nSUFRZVNvd0FCQjVLakFBQ2dDQUNBQWFpSUFOZ0lBSUFFZ0FFRUJjallDQkNBQUlBRnFJQUEyQWdBUEN5QUFRWUFDU1EwQklBRkNBRGNDRUNBQlFSeHFBbjlCQUNBQVFRaDJJZ0pGRFFBYVFSOGdBRUgvLy84SFN3MEFHaUFBUVFZZ0FtY2lBbXRCSDNGMlFRRnhJQUpCQVhSclFUNXFDeUlETmdJQUlBTkJBblJCNUtmQUFHb2hBZ0pBQWtBQ1FBSkFBa0JCMktYQUFDZ0NBQ0lFUVFFZ0EwRWZjWFFpQlhFRVFDQUNLQUlBSWdKQkJHb29BZ0JCZUhFZ0FFY05BU0FDSVFNTUFndEIyS1hBQUNBRUlBVnlOZ0lBSUFJZ0FUWUNBQXdEQ3lBQVFRQkJHU0FEUVFGMmEwRWZjU0FEUVI5R0czUWhCQU5BSUFJZ0JFRWRka0VFY1dwQkVHb2lCU2dDQUNJRFJRMENJQVJCQVhRaEJDQURJZ0pCQkdvb0FnQkJlSEVnQUVjTkFBc0xJQU1vQWdnaUFDQUJOZ0lNSUFNZ0FUWUNDQ0FCUVJocVFRQTJBZ0FnQVNBRE5nSU1JQUVnQURZQ0NBd0NDeUFGSUFFMkFnQUxJQUZCR0dvZ0FqWUNBQ0FCSUFFMkFnd2dBU0FCTmdJSUMwR1VxY0FBUVpTcHdBQW9BZ0JCZjJvaUFEWUNBQ0FBUlEwQ0N3OExJQUJCQTNZaUFrRURkRUhjcGNBQWFpRUFBbjlCMUtYQUFDZ0NBQ0lEUVFFZ0FuUWlBbkVFUUNBQUtBSUlEQUVMUWRTbHdBQWdBaUFEY2pZQ0FDQUFDeUVDSUFBZ0FUWUNDQ0FDSUFFMkFnd2dBU0FBTmdJTUlBRWdBallDQ0E4TFFZU3B3QUFvQWdBaUFFVUVRRUdVcWNBQVFmOGZOZ0lBRHd0QkFDRUJBMEFnQVVFQmFpRUJJQUFvQWdnaUFBMEFDMEdVcWNBQUlBRkIveDhnQVVIL0gwc2JOZ0lBQzlRR0FReC9JQUFvQWhBaEF3SkFBa0FDUUFKQUlBQW9BZ2dpRFVFQlJ3UkFJQU5CQVVZTkFTQUFLQUlZSUFFZ0FpQUFRUnhxS0FJQUtBSU1FUUVBSVFNTUF3c2dBMEVCUncwQkN3SkFJQUpGQkVCQkFDRUNEQUVMSUFFZ0Ftb2hCaUFBUVJScUtBSUFRUUZxSVFrZ0FTSURJUXNEUUNBRFFRRnFJUVFDUUFKL0lBTXNBQUFpQlVGL1RBUkFBbjhnQkNBR1JnUkFRUUFoQ0NBR0RBRUxJQU10QUFGQlAzRWhDQ0FEUVFKcUlnUUxJUU1nQlVFZmNTRUtJQWdnQ2tFR2RISWdCVUgvQVhFaURrSGZBVTBOQVJvQ2Z5QURJQVpHQkVCQkFDRU1JQVlNQVFzZ0F5MEFBRUUvY1NFTUlBTkJBV29pQkFzaEJTQU1JQWhCQm5SeUlRZ2dDQ0FLUVF4MGNpQU9RZkFCU1EwQkdnSi9JQVVnQmtZRVFDQUVJUU5CQUF3QkN5QUZRUUZxSVFNZ0JTMEFBRUUvY1FzZ0NrRVNkRUdBZ1BBQWNTQUlRUVowY25JaUJVR0FnTVFBUncwQ0RBUUxJQVZCL3dGeEN5RUZJQVFoQXdzZ0NVRi9haUlKQkVBZ0J5QUxheUFEYWlFSElBTWhDeUFESUFaSERRRU1BZ3NMSUFWQmdJREVBRVlOQUFKQUlBZEZJQUlnQjBaeVJRUkFRUUFoQXlBSElBSlBEUUVnQVNBSGFpd0FBRUZBU0EwQkN5QUJJUU1MSUFjZ0FpQURHeUVDSUFNZ0FTQURHeUVCQ3lBTlFRRkdEUUFNQWdzQ1FDQUNCRUJCQUNFRUlBSWhCU0FCSVFNRFFDQUVJQU10QUFCQndBRnhRWUFCUm1vaEJDQURRUUZxSVFNZ0JVRi9haUlGRFFBTElBSWdCR3NnQUNnQ0RDSUpUdzBEUVFBaEJDQUNJUVVnQVNFREEwQWdCQ0FETFFBQVFjQUJjVUdBQVVacUlRUWdBMEVCYWlFRElBVkJmMm9pQlEwQUN3d0JDMEVBSVFRZ0FDZ0NEQ0lKRFFBTUFndEJBQ0VESUFRZ0Ftc2dDV29pQkNFRkFrQUNRQUpBUVFBZ0FDMEFJQ0lHSUFaQkEwWWJRUU54UVFGckRnTUJBQUVDQ3lBRVFRRjJJUU1nQkVFQmFrRUJkaUVGREFFTFFRQWhCU0FFSVFNTElBTkJBV29oQXdKQUEwQWdBMEYvYWlJRFJRMEJJQUFvQWhnZ0FDZ0NCQ0FBS0FJY0tBSVFFUUFBUlEwQUMwRUJEd3NnQUNnQ0JDRUVRUUVoQXlBQUtBSVlJQUVnQWlBQUtBSWNLQUlNRVFFQURRQWdCVUVCYWlFRElBQW9BaHdoQVNBQUtBSVlJUUFEUUNBRFFYOXFJZ05GQkVCQkFBOExJQUFnQkNBQktBSVFFUUFBUlEwQUMwRUJEd3NnQXc4TElBQW9BaGdnQVNBQ0lBQkJIR29vQWdBb0Fnd1JBUUFMdlFZQkJIOGdBQ0FCYWlFQ0FrQUNRQUpBQWtBQ1FDQUFRUVJxS0FJQUlnTkJBWEVOQUNBRFFRTnhSUTBCSUFBb0FnQWlBeUFCYWlFQklBQWdBMnNpQUVIc3FNQUFLQUlBUmdSQUlBSW9BZ1JCQTNGQkEwY05BVUhrcU1BQUlBRTJBZ0FnQWlBQ0tBSUVRWDV4TmdJRUlBQWdBVUVCY2pZQ0JDQUNJQUUyQWdBUEN5QUFJQU1RRVFzQ1FDQUNRUVJxS0FJQUlnTkJBbkVFUUNBQ1FRUnFJQU5CZm5FMkFnQWdBQ0FCUVFGeU5nSUVJQUFnQVdvZ0FUWUNBQXdCQ3dKQUlBSkI4S2pBQUNnQ0FFY0VRRUhzcU1BQUtBSUFJQUpHRFFFZ0FpQURRWGh4SWdJUUVTQUFJQUVnQW1vaUFVRUJjallDQkNBQUlBRnFJQUUyQWdBZ0FFSHNxTUFBS0FJQVJ3MENRZVNvd0FBZ0FUWUNBQThMUWZDb3dBQWdBRFlDQUVIb3FNQUFRZWlvd0FBb0FnQWdBV29pQVRZQ0FDQUFJQUZCQVhJMkFnUWdBRUhzcU1BQUtBSUFSdzBDUWVTb3dBQkJBRFlDQUVIc3FNQUFRUUEyQWdBUEMwSHNxTUFBSUFBMkFnQkI1S2pBQUVIa3FNQUFLQUlBSUFGcUlnRTJBZ0FnQUNBQlFRRnlOZ0lFSUFBZ0FXb2dBVFlDQUE4TElBRkJnQUpKRFFNZ0FFSUFOd0lRSUFCQkhHb0NmMEVBSUFGQkNIWWlBa1VOQUJwQkh5QUJRZi8vL3dkTERRQWFJQUZCQmlBQ1p5SUNhMEVmY1haQkFYRWdBa0VCZEd0QlBtb0xJZ00yQWdBZ0EwRUNkRUhrcDhBQWFpRUNBa0FDUUVIWXBjQUFLQUlBSWdSQkFTQURRUjl4ZENJRmNRUkFJQUlvQWdBaUFrRUVhaWdDQUVGNGNTQUJSdzBCSUFJaEF3d0NDMEhZcGNBQUlBUWdCWEkyQWdBZ0FpQUFOZ0lBREFRTElBRkJBRUVaSUFOQkFYWnJRUjl4SUFOQkgwWWJkQ0VFQTBBZ0FpQUVRUjEyUVFSeGFrRVFhaUlGS0FJQUlnTkZEUU1nQkVFQmRDRUVJQU1pQWtFRWFpZ0NBRUY0Y1NBQlJ3MEFDd3NnQXlnQ0NDSUJJQUEyQWd3Z0F5QUFOZ0lJSUFCQkdHcEJBRFlDQUNBQUlBTTJBZ3dnQUNBQk5nSUlDdzhMSUFVZ0FEWUNBQXNnQUVFWWFpQUNOZ0lBSUFBZ0FEWUNEQ0FBSUFBMkFnZ1BDeUFCUVFOMklnSkJBM1JCM0tYQUFHb2hBUUovUWRTbHdBQW9BZ0FpQTBFQklBSjBJZ0p4QkVBZ0FTZ0NDQXdCQzBIVXBjQUFJQUlnQTNJMkFnQWdBUXNoQWlBQklBQTJBZ2dnQWlBQU5nSU1JQUFnQVRZQ0RDQUFJQUkyQWdnTHJnWUJCMzhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUVHQWdBUlBCRUFnQUVHQWdBaEpEUUVnQUVHMTJYTnFRYlhiSzBrZ0FFSGlpM1JxUWVJTFNYSWdBRUdmcUhScVFaOFlTU0FBUWQ3aWRHcEJEa2x5Y2lBQVFmNy8vd0J4UVo3d0NrWWdBRUdpc25WcVFTSkpjaUFBUWN1UmRXcEJDMGx5Y2cwSUlBQkI4SU00U1E4TElBQkJnUDREY1VFSWRpRUdRYXlUd0FBaEFTQUFRZjhCY1NFSEEwQWdBVUVDYWlFRklBSWdBUzBBQVNJRWFpRURJQVlnQVMwQUFDSUJSd1JBSUFFZ0Jrc05DQ0FESVFJZ0JTSUJRZjZUd0FCSERRRU1DQXNnQXlBQ1NRMENJQU5Cb2dKTERRTWdBa0grazhBQWFpRUJBa0FEUUNBRVJRMEJJQVJCZjJvaEJDQUJMUUFBSUFGQkFXb2hBU0FIUncwQUMwRUFJUVFNQ1FzZ0F5RUNJQVVpQVVIK2s4QUFSdzBBQ3d3R0N5QUFRWUQrQTNGQkNIWWhCa0hWbU1BQUlRRWdBRUgvQVhFaEJ3TkFJQUZCQW1vaEJTQUNJQUV0QUFFaUJHb2hBeUFHSUFFdEFBQWlBVWNFUUNBQklBWkxEUVlnQXlFQ0lBVWlBVUdobWNBQVJ3MEJEQVlMSUFNZ0Fra05BeUFEUWE4QlN3MEVJQUpCb1puQUFHb2hBUUpBQTBBZ0JFVU5BU0FFUVg5cUlRUWdBUzBBQUNBQlFRRnFJUUVnQjBjTkFBdEJBQ0VFREFnTElBTWhBaUFGSWdGQm9abkFBRWNOQUFzTUJBc2dBaUFEUVl5VHdBQVFOd0FMSUFOQm9nSkJqSlBBQUJBMkFBc2dBaUFEUVl5VHdBQVFOd0FMSUFOQnJ3RkJqSlBBQUJBMkFBc2dBRUgvL3dOeElRTkIwSnJBQUNFQlFRRWhCQU5BQWtBZ0FVRUJhaUVBQW44Z0FDQUJMUUFBSWdKQkdIUkJHSFVpQlVFQVRnMEFHaUFBUWZPZHdBQkdEUUVnQVMwQUFTQUZRZjhBY1VFSWRISWhBaUFCUVFKcUN5RUJJQU1nQW1zaUEwRUFTQTBESUFSQkFYTWhCQ0FCUWZPZHdBQkhEUUVNQXdzTFFjQ0t3QUJCSzBHY2s4QUFFRWNBQ3lBQVFmLy9BM0VoQTBHZ2xzQUFJUUZCQVNFRUEwQWdBVUVCYWlFQUFuOGdBQ0FCTFFBQUlnSkJHSFJCR0hVaUJVRUFUZzBBR2lBQVFkV1l3QUJHRFFNZ0FTMEFBU0FGUWY4QWNVRUlkSEloQWlBQlFRSnFDeUVCSUFNZ0Ftc2lBMEVBU0EwQklBUkJBWE1oQkNBQlFkV1l3QUJIRFFBTEN5QUVRUUZ4RHd0QndJckFBRUVyUVp5VHdBQVFSd0FMMFFVQkIzOUJLMEdBZ01RQUlBQW9BZ0FpQ1VFQmNTSUZHeUVLSUFRZ0JXb2hDQUpBSUFsQkJIRkZCRUJCQUNFQkRBRUxJQUlFUUNBQ0lRWWdBU0VGQTBBZ0J5QUZMUUFBUWNBQmNVR0FBVVpxSVFjZ0JVRUJhaUVGSUFaQmYyb2lCZzBBQ3dzZ0FpQUlhaUFIYXlFSUMwRUJJUVVDUUNBQUtBSUlRUUZIQkVBZ0FDQUtJQUVnQWhCRkRRRWdBQ2dDR0NBRElBUWdBRUVjYWlnQ0FDZ0NEQkVCQUNFRkRBRUxJQUJCREdvb0FnQWlCaUFJVFFSQUlBQWdDaUFCSUFJUVJRMEJJQUFvQWhnZ0F5QUVJQUJCSEdvb0FnQW9BZ3dSQVFBUEN3SkFBa0FDUUFKQUlBbEJDSEVFUUNBQUtBSUVJUWtnQUVFd05nSUVJQUF0QUNBaEN5QUFRUUU2QUNBZ0FDQUtJQUVnQWhCRkRRVkJBQ0VGSUFZZ0NHc2lBU0VDUVFFZ0FDMEFJQ0lHSUFaQkEwWWJRUU54UVFGckRnTUNBUUlEQzBFQUlRVWdCaUFJYXlJR0lRZ0NRQUpBQWtCQkFTQUFMUUFnSWdjZ0IwRURSaHRCQTNGQkFXc09Bd0VBQVFJTElBWkJBWFloQlNBR1FRRnFRUUYySVFnTUFRdEJBQ0VJSUFZaEJRc2dCVUVCYWlFRkEwQWdCVUYvYWlJRlJRMEVJQUFvQWhnZ0FDZ0NCQ0FBS0FJY0tBSVFFUUFBUlEwQUMwRUJEd3NnQVVFQmRpRUZJQUZCQVdwQkFYWWhBZ3dCQzBFQUlRSWdBU0VGQ3lBRlFRRnFJUVVDUUFOQUlBVkJmMm9pQlVVTkFTQUFLQUlZSUFBb0FnUWdBQ2dDSENnQ0VCRUFBRVVOQUF0QkFROExJQUFvQWdRaEFVRUJJUVVnQUNnQ0dDQURJQVFnQUNnQ0hDZ0NEQkVCQUEwQklBSkJBV29oQnlBQUtBSWNJUUlnQUNnQ0dDRURBMEFnQjBGL2FpSUhCRUFnQXlBQklBSW9BaEFSQUFCRkRRRU1Bd3NMSUFBZ0N6b0FJQ0FBSUFrMkFnUkJBQThMSUFBb0FnUWhCa0VCSVFVZ0FDQUtJQUVnQWhCRkRRQWdBQ2dDR0NBRElBUWdBQ2dDSENnQ0RCRUJBQTBBSUFoQkFXb2hCeUFBS0FJY0lRRWdBQ2dDR0NFQUEwQWdCMEYvYWlJSFJRUkFRUUFQQ3lBQUlBWWdBU2dDRUJFQUFFVU5BQXNMSUFVTDlBVUJDbjhqQUVFd2F5SURKQUFnQTBFa2FpQUJOZ0lBSUFOQkF6b0FLQ0FEUW9DQWdJQ0FCRGNEQ0NBRElBQTJBaUFnQTBFQU5nSVlJQU5CQURZQ0VBSi9Ba0FDUUFKQUlBSW9BZ2dpQkFSQUlBSW9BZ0FoQmlBQ0tBSUVJZ2dnQWtFTWFpZ0NBQ0lGSUFVZ0NFc2JJZ1ZGRFFFZ0FDQUdLQUlBSUFZb0FnUWdBU2dDREJFQkFBMERJQVpCREdvaEFDQUNLQUlVSVFjZ0FpZ0NFQ0VLSUFVaENRTkFJQU1nQkVFY2FpMEFBRG9BS0NBRElBUkJCR29wQWdCQ0lJazNBd2dnQkVFWWFpZ0NBQ0VDUVFBaEMwRUFJUUVDUUFKQUFrQWdCRUVVYWlnQ0FFRUJhdzRDQUFJQkN5QUNJQWRQQkVBZ0FpQUhRZmlPd0FBUU5RQUxJQUpCQTNRZ0Ntb2lEQ2dDQkVFY1J3MEJJQXdvQWdBb0FnQWhBZ3RCQVNFQkN5QURJQUkyQWhRZ0F5QUJOZ0lRSUFSQkVHb29BZ0FoQWdKQUFrQUNRQ0FFUVF4cUtBSUFRUUZyRGdJQUFnRUxJQUlnQjA4RVFDQUNJQWRCK0k3QUFCQTFBQXNnQWtFRGRDQUthaUlCS0FJRVFSeEhEUUVnQVNnQ0FDZ0NBQ0VDQzBFQklRc0xJQU1nQWpZQ0hDQURJQXMyQWhnZ0JDZ0NBQ0lCSUFkSkJFQWdDaUFCUVFOMGFpSUJLQUlBSUFOQkNHb2dBU2dDQkJFQUFBMEZJQWxCZjJvaUNVVU5CQ0FFUVNCcUlRUWdBRUY4YWlFQklBQW9BZ0FoQWlBQVFRaHFJUUFnQXlnQ0lDQUJLQUlBSUFJZ0F5Z0NKQ2dDREJFQkFFVU5BUXdGQ3dzZ0FTQUhRZWlPd0FBUU5RQUxJQUlvQWdBaEJpQUNLQUlFSWdnZ0FrRVVhaWdDQUNJRklBVWdDRXNiSWdWRkRRQWdBaWdDRUNFRUlBQWdCaWdDQUNBR0tBSUVJQUVvQWd3UkFRQU5BaUFHUVF4cUlRQWdCU0VDQTBBZ0JDZ0NBQ0FEUVFocUlBUkJCR29vQWdBUkFBQU5BeUFDUVg5cUlnSkZEUUlnQkVFSWFpRUVJQUJCZkdvaEFTQUFLQUlBSVFrZ0FFRUlhaUVBSUFNb0FpQWdBU2dDQUNBSklBTW9BaVFvQWd3UkFRQkZEUUFMREFJTFFRQWhCUXNnQ0NBRlN3UkFJQU1vQWlBZ0JpQUZRUU4wYWlJQUtBSUFJQUFvQWdRZ0F5Z0NKQ2dDREJFQkFBMEJDMEVBREFFTFFRRUxJQU5CTUdva0FBdU5CUUVIZndKQUlBRkJ6UDk3U3cwQVFSQWdBVUVMYWtGNGNTQUJRUXRKR3lFQ0lBQkJmR29pQlNnQ0FDSUdRWGh4SVFNQ1FBSkFBa0FDUUFKQUFrQWdCa0VEY1FSQUlBQkJlR29pQnlBRGFpRUlJQU1nQWs4TkFVSHdxTUFBS0FJQUlBaEdEUUpCN0tqQUFDZ0NBQ0FJUmcwRElBaEJCR29vQWdBaUJrRUNjUTBHSUFaQmVIRWlCaUFEYWlJRElBSlBEUVFNQmdzZ0FrR0FBa2tnQXlBQ1FRUnlTWElnQXlBQ2EwR0JnQWhQY2cwRkRBUUxJQU1nQW1zaUFVRVFTUTBESUFVZ0FpQUdRUUZ4Y2tFQ2NqWUNBQ0FDSUFkcUlnUWdBVUVEY2pZQ0JDQUlJQWdvQWdSQkFYSTJBZ1FnQkNBQkVBWU1Bd3RCNktqQUFDZ0NBQ0FEYWlJRElBSk5EUU1nQlNBQ0lBWkJBWEZ5UVFKeU5nSUFJQUlnQjJvaUFTQURJQUpySWdSQkFYSTJBZ1JCNktqQUFDQUVOZ0lBUWZDb3dBQWdBVFlDQUF3Q0MwSGtxTUFBS0FJQUlBTnFJZ01nQWtrTkFnSkFJQU1nQW1zaUFVRVBUUVJBSUFVZ0JrRUJjU0FEY2tFQ2NqWUNBQ0FESUFkcUlnRWdBU2dDQkVFQmNqWUNCRUVBSVFFTUFRc2dCU0FDSUFaQkFYRnlRUUp5TmdJQUlBSWdCMm9pQkNBQlFRRnlOZ0lFSUFNZ0Iyb2lBaUFCTmdJQUlBSWdBaWdDQkVGK2NUWUNCQXRCN0tqQUFDQUVOZ0lBUWVTb3dBQWdBVFlDQUF3QkN5QUlJQVlRRVNBRElBSnJJZ0ZCRUU4RVFDQUZJQUlnQlNnQ0FFRUJjWEpCQW5JMkFnQWdBaUFIYWlJRUlBRkJBM0kyQWdRZ0F5QUhhaUlDSUFJb0FnUkJBWEkyQWdRZ0JDQUJFQVlNQVFzZ0JTQURJQVVvQWdCQkFYRnlRUUp5TmdJQUlBTWdCMm9pQVNBQktBSUVRUUZ5TmdJRUN5QUFJUVFNQVFzZ0FSQUFJZ0pGRFFBZ0FpQUFJQUZCZkVGNElBVW9BZ0FpQkVFRGNSc2dCRUY0Y1dvaUJDQUVJQUZMR3hCSklBQVFCQThMSUFRTG5BUUJCMzhqQUVFd2F5SURKQUFDZjBFQUlBSkZEUUFhSUFOQktHb2hDQUpBQWtBQ1FBTkFJQUFvQWdndEFBQUVRQ0FBS0FJQVFZeU13QUJCQkNBQUtBSUVLQUlNRVFFQURRUUxJQU5CQ2pZQ0tDQURRb3FBZ0lBUU53TWdJQU1nQWpZQ0hDQURRUUEyQWhnZ0F5QUNOZ0lVSUFNZ0FUWUNFQ0FEUVFocVFRb2dBU0FDRUJNQ2Z3SkFBa0FnQXlnQ0NFRUJSZ1JBSUFNb0Fnd2hCQU5BSUFNZ0JDQURLQUlZYWtFQmFpSUVOZ0lZQWtBZ0JDQURLQUlrSWdWSkJFQWdBeWdDRkNFSERBRUxJQU1vQWhRaUJ5QUVTUTBBSUFWQkJVOE5CeUFFSUFWcklnWWdBeWdDRUdvaUNTQUlSZzBFSUFrZ0NDQUZFRU5GRFFRTElBTW9BaHdpQmlBRVNTQUhJQVpKY2cwQ0lBTWdBeUFGYWtFbmFpMEFBQ0FES0FJUUlBUnFJQVlnQkdzUUV5QURLQUlFSVFRZ0F5Z0NBRUVCUmcwQUN3c2dBeUFES0FJY05nSVlDeUFBS0FJSVFRQTZBQUFnQWd3QkN5QUFLQUlJUVFFNkFBQWdCa0VCYWdzaEJDQUFLQUlFSVFVZ0FDZ0NBQ0VIQWtBQ1FDQUVSU0FDSUFSR2NrVUVRQ0FDSUFSTEJFQWdBU0FFYWlJR0xBQUFRYjkvU2cwQ0N5QUJJQUpCQUNBRVFaQ013QUFRQXdBTElBY2dBU0FFSUFVb0Fnd1JBUUFOQlF3QkN5QUhJQUVnQkNBRktBSU1FUUVBRFFRZ0Jpd0FBRUcvZjB3TkF3c2dBU0FFYWlFQklBSWdCR3NpQWcwQUMwRUFEQU1MSUFWQkJFSDBrTUFBRURZQUN5QUJJQUlnQkNBQ1FhQ013QUFRQXdBTFFRRUxJQU5CTUdva0FBdTNBd0VFZnlNQVFSQnJJZ0lrQUNBQUtBSUFJUUFDUUFKQUFrQUNmd0pBQWtBZ0FVR0FBVThFUUNBQ1FRQTJBZ3dnQVVHQUVFa05BU0FDUVF4cUlRUWdBVUdBZ0FSSkJFQWdBaUFCUVQ5eFFZQUJjam9BRGlBQ0lBRkJESFpCNEFGeU9nQU1JQUlnQVVFR2RrRS9jVUdBQVhJNkFBMUJBeUVCREFZTElBSWdBVUUvY1VHQUFYSTZBQThnQWlBQlFSSjJRZkFCY2pvQURDQUNJQUZCQm5aQlAzRkJnQUZ5T2dBT0lBSWdBVUVNZGtFL2NVR0FBWEk2QUExQkJDRUJEQVVMSUFBb0FnZ2lCQ0FBUVFScUtBSUFSd1JBSUFBb0FnQWhCUXdFQ3dKQUlBUkJBV29pQXlBRVNRMEFJQVJCQVhRaUJTQURJQVVnQTBzYklnTkJDQ0FEUVFoTEd5RURJQVFFUUNBRFFRQklEUUVnQUNnQ0FDSUZSUTBESUFVZ0JFRUJJQU1RVkF3RUN5QURRUUJPRFFJTEVGc0FDeUFDSUFGQlAzRkJnQUZ5T2dBTklBSWdBVUVHZGtIQUFYSTZBQXdnQWtFTWFpRUVRUUloQVF3REN5QURRUUVRVndzaUJRUkFJQUFnQlRZQ0FDQUFRUVJxSUFNMkFnQWdBQ2dDQ0NFRURBRUxJQU5CQVJCZkFBc2dCQ0FGYWlBQk9nQUFJQUFnQUNnQ0NFRUJhallDQ0F3QkN5QUFJQVFnQVJBZ0N5QUNRUkJxSkFCQkFBdTBBd0VFZnlBQVFRQTJBZ2dnQUVFVWFrRUFOZ0lBSUFGQkQzRWhCQ0FBUVF4cUlRSkJBQ0VCQTBBZ0FDZ0NCQ0FCUmdSQUlBQWdBUkE2SUFBb0FnZ2hBUXNnQUNnQ0FDQUJRUUowYWlJQklBTTZBQUlnQVVFQU93RUFJQUFnQUNnQ0NFRUJhallDQ0NBQUtBSVVJZ0VnQUNnQ0VFWUVRQ0FDSUFFUU95QUFLQUlVSVFFTElBQW9BZ3dnQVVFQmRHcEJBVHNCQUNBQUlBQW9BaFJCQVdvMkFoUWdBQ2dDQ0NFQklBTkJBV29pQlNFRElBVkIvLzhEY1NBRWRrVU5BQXNnQUNnQ0JDQUJSZ1JBSUFBZ0FSQTZJQUFvQWdnaEFRc2dBQ2dDQUNBQlFRSjBhaUlCUVFBNkFBSWdBVUVBT3dFQUlBQWdBQ2dDQ0VFQmFqWUNDQ0FBS0FJVUlnRWdBQ2dDRUVZRVFDQUNJQUVRT3lBQUtBSVVJUUVMSUFBb0Fnd2dBVUVCZEdwQkFEc0JBQ0FBSUFBb0FoUkJBV28yQWhRZ0FDZ0NDQ0lCSUFBb0FnUkdCRUFnQUNBQkVEb2dBQ2dDQ0NFQkN5QUFLQUlBSUFGQkFuUnFJZ0ZCQURvQUFpQUJRUUE3QVFBZ0FDQUFLQUlJUVFGcU5nSUlJQUFvQWhRaUFTQUFLQUlRUmdSQUlBSWdBUkE3SUFBb0FoUWhBUXNnQUNnQ0RDQUJRUUYwYWtFQU93RUFJQUFnQUNnQ0ZFRUJhallDRkF2MkF3SURmd0YrSUFFb0FoaEJKeUFCUVJ4cUtBSUFLQUlRRVFBQVJRUkFRZlFBSVFOQkFpRUNBa0FDUUFKQUFrQUNRQUpBSUFBb0FnQWlBRUYzYWc0ZkJRRURBd0FEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdRREF3TURCQUlMUWZJQUlRTU1CQXRCN2dBaEF3d0RDeUFBUWR3QVJnMEJDd0ovQW40Z0FFRUJjbWRCQW5aQkIzT3RRb0NBZ0lEUUFJUWdBQkFQRFFBYVFRRWdBQkFIRFFFYUlBQkJBWEpuUVFKMlFRZHpyVUtBZ0lDQTBBQ0VDeUVGUVFNTElRSWdBQ0VEREFFTElBQWhBd3NEUUNBQ0lRUkIzQUFoQUVFQklRSUNRQUorQWtBQ1FBSkFBa0FnQkVFQmF3NERBUVVBQWdzQ1FBSkFBa0FDUUNBRlFpQ0lwMEgvQVhGQkFXc09CUU1DQVFBR0JRdEI5UUFoQUNBRlF2Ly8vLytQWUlOQ2dJQ0FnRENFREFZTFFmc0FJUUFnQlVMLy8vLy9qMkNEUW9DQWdJQWdoQXdGQzBFd1FkY0FJQU1nQmFjaUJFRUNkRUVjY1haQkQzRWlBRUVLU1JzZ0FHb2hBQ0FGUW45OFF2Ly8vLzhQZ3lBRlFvQ0FnSUJ3ZzRRZ0JBMEVHaUFGUXYvLy8vK1BZSU5DZ0lDQWdCQ0VEQVFMUWYwQUlRQWdCVUwvLy8vL2oyQ0REQU1MUVFBaEFpQURJUUFNQXdzZ0FTZ0NHRUVuSUFFb0Fod29BaEFSQUFBUEN5QUZRdi8vLy8rUFlJTkNnSUNBZ01BQWhBc2hCVUVESVFJTElBRW9BaGdnQUNBQktBSWNLQUlRRVFBQVJRMEFDd3RCQVF1Z0F3RUZmd0pBQWtCQkFFRVBJQUJCcEpvRVNSc2lBU0FCUVFocUlnRWdBVUVDZEVIY25zQUFhaWdDQUVFTGRDQUFRUXQwSWdKTEd5SUJJQUZCQkdvaUFTQUJRUUowUWR5ZXdBQnFLQUlBUVF0MElBSkxHeUlCSUFGQkFtb2lBU0FCUVFKMFFkeWV3QUJxS0FJQVFRdDBJQUpMR3lJQklBRkJBV29pQVNBQlFRSjBRZHlld0FCcUtBSUFRUXQwSUFKTEd5SURRUUowUWR5ZXdBQnFLQUlBUVF0MElnRWdBa1lnQVNBQ1NXb2dBMm9pQWtFZVRRUkFRYkVGSVFRZ0FrRWVSd1JBSUFKQkFuUkI0SjdBQUdvb0FnQkJGWFloQkF0QkFDRUJJQUpCZjJvaUF5QUNUUVJBSUFOQkgwOE5BeUFEUVFKMFFkeWV3QUJxS0FJQVFmLy8vd0J4SVFFTEFrQWdCQ0FDUVFKMFFkeWV3QUJxS0FJQVFSVjJJZ05CQVdwR0RRQWdBQ0FCYXlFQ0lBTkJzUVVnQTBHeEJVc2JJUVVnQkVGL2FpRUJRUUFoQUFOQUlBTWdCVVlOQXlBQUlBTkIySi9BQUdvdEFBQnFJZ0FnQWtzTkFTQUJJQU5CQVdvaUEwY05BQXNnQVNFREN5QURRUUZ4RHdzZ0FrRWZRWnlld0FBUU5RQUxJQVZCc1FWQnJKN0FBQkExQUFzZ0EwRWZRYnlld0FBUU5RQUw2QUlCQlg4Q1FFSE4vM3NnQUVFUUlBQkJFRXNiSWdCcklBRk5EUUFnQUVFUUlBRkJDMnBCZUhFZ0FVRUxTUnNpQkdwQkRHb1FBQ0lDUlEwQUlBSkJlR29oQVFKQUlBQkJmMm9pQXlBQ2NVVUVRQ0FCSVFBTUFRc2dBa0Y4YWlJRktBSUFJZ1pCZUhFZ0FpQURha0VBSUFCcmNVRjRhaUlDSUFBZ0Ftb2dBaUFCYTBFUVN4c2lBQ0FCYXlJQ2F5RURJQVpCQTNFRVFDQUFJQU1nQUNnQ0JFRUJjWEpCQW5JMkFnUWdBQ0FEYWlJRElBTW9BZ1JCQVhJMkFnUWdCU0FDSUFVb0FnQkJBWEZ5UVFKeU5nSUFJQUFnQUNnQ0JFRUJjallDQkNBQklBSVFCZ3dCQ3lBQktBSUFJUUVnQUNBRE5nSUVJQUFnQVNBQ2FqWUNBQXNDUUNBQVFRUnFLQUlBSWdGQkEzRkZEUUFnQVVGNGNTSUNJQVJCRUdwTkRRQWdBRUVFYWlBRUlBRkJBWEZ5UVFKeU5nSUFJQUFnQkdvaUFTQUNJQVJySWdSQkEzSTJBZ1FnQUNBQ2FpSUNJQUlvQWdSQkFYSTJBZ1FnQVNBRUVBWUxJQUJCQ0dvaEF3c2dBd3VGQXdFRWZ3SkFBa0FnQVVHQUFrOEVRQ0FBUVJocUtBSUFJUVFDUUFKQUlBQWdBQ2dDRENJQ1JnUkFJQUJCRkVFUUlBQkJGR29pQWlnQ0FDSURHMm9vQWdBaUFRMEJRUUFoQWd3Q0N5QUFLQUlJSWdFZ0FqWUNEQ0FDSUFFMkFnZ01BUXNnQWlBQVFSQnFJQU1iSVFNRFFDQURJUVVnQVNJQ1FSUnFJZ01vQWdBaUFVVUVRQ0FDUVJCcUlRTWdBaWdDRUNFQkN5QUJEUUFMSUFWQkFEWUNBQXNnQkVVTkFpQUFJQUJCSEdvb0FnQkJBblJCNUtmQUFHb2lBU2dDQUVjRVFDQUVRUkJCRkNBRUtBSVFJQUJHRzJvZ0FqWUNBQ0FDUlEwRERBSUxJQUVnQWpZQ0FDQUNEUUZCMktYQUFFSFlwY0FBS0FJQVFYNGdBQ2dDSEhkeE5nSUFEd3NnQUVFTWFpZ0NBQ0lDSUFCQkNHb29BZ0FpQUVjRVFDQUFJQUkyQWd3Z0FpQUFOZ0lJRHd0QjFLWEFBRUhVcGNBQUtBSUFRWDRnQVVFRGRuZHhOZ0lBREFFTElBSWdCRFlDR0NBQUtBSVFJZ0VFUUNBQ0lBRTJBaEFnQVNBQ05nSVlDeUFBUVJScUtBSUFJZ0JGRFFBZ0FrRVVhaUFBTmdJQUlBQWdBallDR0FzTG93TUNCSDhDZmlNQVFVQnFJZ0lrQUVFQklRUUNRQ0FBTFFBRURRQWdBQzBBQlNFRklBQW9BZ0FpQXkwQUFFRUVjVVVFUUNBREtBSVlRYldNd0FCQnQ0ekFBQ0FGRzBFQ1FRTWdCUnNnQTBFY2FpZ0NBQ2dDREJFQkFBMEJJQUFvQWdBaUF5Z0NHRUdTcGNBQVFRY2dBMEVjYWlnQ0FDZ0NEQkVCQUEwQklBQW9BZ0FpQXlnQ0dFSHJpc0FBUVFJZ0EwRWNhaWdDQUNnQ0RCRUJBQTBCSUFFZ0FDZ0NBRUhZbnNBQUtBSUFFUUFBSVFRTUFRc2dCVVVFUUNBREtBSVlRYkNNd0FCQkF5QURRUnhxS0FJQUtBSU1FUUVBRFFFZ0FDZ0NBQ0VEQ3lBQ1FRRTZBQmNnQWtFMGFrSDBpOEFBTmdJQUlBSWdBeWtDR0RjRENDQUNJQUpCRjJvMkFoQWdBeWtDQ0NFR0lBTXBBaEFoQnlBQ0lBTXRBQ0E2QURnZ0FpQUhOd01vSUFJZ0JqY0RJQ0FDSUFNcEFnQTNBeGdnQWlBQ1FRaHFOZ0l3SUFKQkNHcEJrcVhBQUVFSEVBc05BQ0FDUVFocVFldUt3QUJCQWhBTERRQWdBU0FDUVJocVFkaWV3QUFvQWdBUkFBQU5BQ0FDS0FJd1FiT013QUJCQWlBQ0tBSTBLQUlNRVFFQUlRUUxJQUJCQVRvQUJTQUFJQVE2QUFRZ0FrRkFheVFBQzhRQ0FRVi9Ba0FDUUFKQUFrQkJBQ0FDYTBFRGNTSUVSUTBBSUFNZ0JDQUVJQU5MR3lJRVJRMEFJQUZCL3dGeElRVURRQ0FDSUFacUxRQUFJQVZHRFFJZ0JDQUdRUUZxSWdaSERRQUxJQVFoQlFzZ0EwRUlTUTBCSUFVZ0EwRjRhaUlJU3cwQklBRkIvd0Z4UVlHQ2hBaHNJUWNEUUNBQ0lBVnFJZ1pCQkdvb0FnQWdCM01pQkVGL2N5QUVRZi85KzNkcWNTQUdLQUlBSUFkeklnUkJmM01nQkVILy9mdDNhbkZ5UVlDQmdvUjRjVVVFUUNBRlFRaHFJZ1VnQ0UwTkFRc0xJQVVnQTAwTkFTQUZJQU5CckkvQUFCQTRBQXRCQVNFRURBRUxRUUFoQmtFQUlRUWdBeUFGUndSQUlBSWdCV29oQWlBRElBVnJJUU1nQVVIL0FYRWhBUUpBQTBBZ0FpQUdhaTBBQUNBQlJnMEJJQU1nQmtFQmFpSUdSdzBBQ3lBRElBVnFJUVlNQWd0QkFTRUVDeUFGSUFacUlRWUxJQUFnQmpZQ0JDQUFJQVEyQWdBTHZnSUNCWDhCZmlNQVFUQnJJZ1FrQUVFbklRSUNRQ0FBUXBET0FGUUVRQ0FBSVFjTUFRc0RRQ0FFUVFscUlBSnFJZ05CZkdvZ0FDQUFRcERPQUlBaUIwS1F6Z0IrZmFjaUJVSC8vd054UWVRQWJpSUdRUUYwUWVxTXdBQnFMd0FBT3dBQUlBTkJmbW9nQlNBR1FlUUFiR3RCLy84RGNVRUJkRUhxak1BQWFpOEFBRHNBQUNBQ1FYeHFJUUlnQUVML3dkY3ZWaUFISVFBTkFBc0xJQWVuSWdOQjR3QktCRUFnQWtGK2FpSUNJQVJCQ1dwcUlBZW5JZ01nQTBILy93TnhRZVFBYmlJRFFlUUFiR3RCLy84RGNVRUJkRUhxak1BQWFpOEFBRHNBQUFzQ1FDQURRUXBPQkVBZ0FrRithaUlDSUFSQkNXcHFJQU5CQVhSQjZvekFBR292QUFBN0FBQU1BUXNnQWtGL2FpSUNJQVJCQ1dwcUlBTkJNR282QUFBTElBRkJ0SXJBQUVFQUlBUkJDV29nQW1wQkp5QUNheEFJSUFSQk1Hb2tBQXVqQWdJRWZ3RitJd0JCUUdvaUJDUUFBa0FDUUFKQUlBSWdBMm9pQXlBQ1R3UkFJQUVvQWdRaEJTQUVRUmhxUW9HQWdJQVFOd01BSUFRb0Fod2lBa0YvYWlJR0lBUW9BaGhxUVFBZ0Ftc2lCM0d0SUFWQkFYUWlCU0FESUFVZ0Ewc2JJZ05CQ0NBRFFRaExHNjErSWdoQ0lJaW5JQUpGY2cwQklBSnBRUUZHQkVBZ0NLY2dCbW9nQjNFaEF3d0RDeUFFUVRCcUVEQUFDeUFFUVFocUlBTkJBQkJZSUFBZ0JDa0RDRGNDQkVFQklRSU1BZ3RCQUNFQ0N5QUVRVEJxSUFFUVN5QUVRU0JxSUFNZ0FpQUVRVEJxRUNWQkFTRUNJQVJCS0dvb0FnQWhBeUFFS0FJa0lRVWdCQ2dDSUVFQlJ3UkFJQUVnQlNBREVGaEJBQ0VDREFFTElBUkJFR29nQlNBREVGZ2dBQ0FFS1FNUU53SUVDeUFBSUFJMkFnQWdCRUZBYXlRQUM2NENBUWgvSXdCQk1Hc2lBU1FBUVlBZ0lRSWdBVUVZYWhBdklBRW9BaHdoQkNBQktBSVlJUVVnQVVFUWFoQXhJQUVvQWhRaEJpQUJLQUlRSVFjZ0FVRUlha0dBSUVFQkVEOGdBVUdBSURZQ0tDQUJJQUVvQWd3aUNEWUNKQ0FCSUFFb0FnZ2lBellDSUNBSVFZRWdUd1JBSUFGQklHcEJnQ0FRUkNBQktBSWdJUU1nQVNnQ0tDRUNDeUFBUVFBN0FFY2dBRUVBT3dFNElBQWdBellDS0NBQUlBVTJBaEFnQUVFSU9nQkdJQUJCQURvQUN5QUFRZ0EzQXdBZ0FFRXdha0lBTndNQUlBQkJMR29nQWpZQ0FDQUFRU1JxUVFBMkFnQWdBRUVnYWlBR05nSUFJQUJCSEdvZ0J6WUNBQ0FBUVJocVFRQTJBZ0FnQUVFVWFpQUVOZ0lBSUFCQkNUb0FDaUFBUVlBQ093RkNJQUJCZ1FJN0FVUWdBRUdDQWpzQlFDQUFRZjhET3dFSUlBRkJNR29rQUF2SEFnSUZmd0YrSXdCQkVHc2lBeVFBSUFBdEFBc2hBaUFEUWdBM0F3Z2dBU2dDQUNFRkFrQUNRQ0FBQW44Z0FTZ0NCQ0lFUWNBQUlBSnJJZ1pCK0FGeFFRTjJJZ0pKQkVBZ0JFRUpUdzBDSUFOQkNHb2dCU0FFRUVrYUlBRkJBRFlDQkNBQlFhK0Z3QUEyQWdBZ0JFRURkQXdCQ3lBR1FmOEJjVUhJQUU4TkFpQURRUWhxSUFVZ0FoQkpHaUFCSUFRZ0FtczJBZ1FnQVNBQ0lBVnFOZ0lBSUFaQitBRnhDeUFBTFFBTElnRnFPZ0FMSUFBZ0FDa0RBQ0FES1FNSUlnZENPSVlnQjBJb2hrS0FnSUNBZ0lEQS93Q0RoQ0FIUWhpR1FvQ0FnSUNBNEQrRElBZENDSVpDZ0lDQWdQQWZnNFNFSUFkQ0NJaENnSUNBK0ErRElBZENHSWhDZ0lEOEI0T0VJQWRDS0loQ2dQNERneUFIUWppSWhJU0VJQUZCUDNHdGlJUTNBd0FnQTBFUWFpUUFEd3NnQkVFSVFmQ0d3QUFRTmdBTElBSkJDRUhnaHNBQUVEWUFDNm9DQVFOL0l3QkJnQUZySWdRa0FBSkFBa0FDZndKQUlBRW9BZ0FpQTBFUWNVVUVRQ0FBS0FJQUlRSWdBMEVnY1EwQklBS3RJQUVRRkF3Q0N5QUFLQUlBSVFKQkFDRUFBMEFnQUNBRWFrSC9BR29nQWtFUGNTSURRVEJ5SUFOQjF3QnFJQU5CQ2trYk9nQUFJQUJCZjJvaEFDQUNRUVIySWdJTkFBc2dBRUdBQVdvaUFrR0JBVThOQWlBQlFlaU13QUJCQWlBQUlBUnFRWUFCYWtFQUlBQnJFQWdNQVF0QkFDRUFBMEFnQUNBRWFrSC9BR29nQWtFUGNTSURRVEJ5SUFOQk4yb2dBMEVLU1JzNkFBQWdBRUYvYWlFQUlBSkJCSFlpQWcwQUN5QUFRWUFCYWlJQ1FZRUJUdzBDSUFGQjZJekFBRUVDSUFBZ0JHcEJnQUZxUVFBZ0FHc1FDQXNnQkVHQUFXb2tBQThMSUFKQmdBRkIySXpBQUJBNEFBc2dBa0dBQVVIWWpNQUFFRGdBQzZvQ0FnWi9BWDRqQUVFd2F5SUVKQUFnQkVFUWFoQXFJQVFnQkNrREVEY0RHQ0FFUVFocUlBTkJBQkEvSUFRcEF3Z2hDaUFBUVFBMkFnZ2dBQ0FLTndJQUFrQURRQ0FISUFKUElBVWdBMDl5UlFSQUlBQWdCVUdBSUJBNUlBQWdBQ2dDQkJCT0lBQW9BZ0FoQ0NBQUtBSUlJZ1lnQlVrTkFpQUVRU0JxSUFSQkdHb2lDU2dDQUNBQklBZHFJQUlnQjJzZ0JTQUlhaUFHSUFWcklBa29BZ1FvQWd3UkNBQWdCQ2dDSUNFSUlBUW9BaVFnQldvaEJpQUFLQUlJSWdVZ0JrOEVRQ0FBS0FJQUdpQUFJQVkyQWdnZ0JpRUZDeUFISUFocUlRY2dCQzBBS0VFQ1J3MEJDd3NnQkNnQ0dDQUVLQUljS0FJQUVRTUFJQVFvQWh3aUFDZ0NDQm9nQkNnQ0dDRUJJQUFvQWdRRVFDQUJFQVFMSUFSQk1Hb2tBQThMSUFVZ0JrSE1nY0FBRURnQUM3RUNBUVIvSXdCQlFHb2lBaVFBSUFFb0FnUWlBMFVFUUNBQlFRUnFJUU1nQVNnQ0FDRUVJQUpCQURZQ0lDQUNRZ0UzQXhnZ0FpQUNRUmhxTmdJa0lBSkJPR29nQkVFUWFpa0NBRGNEQUNBQ1FUQnFJQVJCQ0dvcEFnQTNBd0FnQWlBRUtRSUFOd01vSUFKQkpHcEJ3SWpBQUNBQ1FTaHFFQWthSUFKQkVHb2lCQ0FDS0FJZ05nSUFJQUlnQWlrREdEY0RDQUpBSUFFb0FnUWlCVVVOQUNBQlFRaHFLQUlBUlEwQUlBVVFCQXNnQXlBQ0tRTUlOd0lBSUFOQkNHb2dCQ2dDQURZQ0FDQURLQUlBSVFNTElBRkJBVFlDQkNBQlFReHFLQUlBSVFRZ0FVRUlhaUlCS0FJQUlRVWdBVUlBTndJQVFReEJCQkJYSWdGRkJFQkJERUVFRUY4QUN5QUJJQVEyQWdnZ0FTQUZOZ0lFSUFFZ0F6WUNBQ0FBUWVTSndBQTJBZ1FnQUNBQk5nSUFJQUpCUUdza0FBdjhBUUVDZnlNQVFSQnJJZ0lrQUNBQUtBSUFJQUpCQURZQ0RBSi9Ba0FDUUNBQlFZQUJUd1JBSUFGQmdCQkpEUUVnQWtFTWFpRUFJQUZCZ0lBRVR3MENJQUlnQVVFL2NVR0FBWEk2QUE0Z0FpQUJRUXgyUWVBQmNqb0FEQ0FDSUFGQkJuWkJQM0ZCZ0FGeU9nQU5RUU1NQXdzZ0FpQUJPZ0FNSUFKQkRHb2hBRUVCREFJTElBSWdBVUUvY1VHQUFYSTZBQTBnQWlBQlFRWjJRY0FCY2pvQURDQUNRUXhxSVFCQkFnd0JDeUFDSUFGQlAzRkJnQUZ5T2dBUElBSWdBVUVTZGtId0FYSTZBQXdnQWlBQlFRWjJRVDl4UVlBQmNqb0FEaUFDSUFGQkRIWkJQM0ZCZ0FGeU9nQU5RUVFMSVFFZ0FDQUJFQXNnQWtFUWFpUUFDL2tCQVFKL0l3QkJFR3NpQWlRQUlBSkJBRFlDREFKL0FrQUNRQ0FCUVlBQlR3UkFJQUZCZ0JCSkRRRWdBa0VNYWlFRElBRkJnSUFFVHcwQ0lBSWdBVUUvY1VHQUFYSTZBQTRnQWlBQlFReDJRZUFCY2pvQURDQUNJQUZCQm5aQlAzRkJnQUZ5T2dBTlFRTU1Bd3NnQWlBQk9nQU1JQUpCREdvaEEwRUJEQUlMSUFJZ0FVRS9jVUdBQVhJNkFBMGdBaUFCUVFaMlFjQUJjam9BRENBQ1FReHFJUU5CQWd3QkN5QUNJQUZCUDNGQmdBRnlPZ0FQSUFJZ0FVRVNka0h3QVhJNkFBd2dBaUFCUVFaMlFUOXhRWUFCY2pvQURpQUNJQUZCREhaQlAzRkJnQUZ5T2dBTlFRUUxJUUVnQUNBRElBRVFDeUFDUVJCcUpBQUwvQUVCQTM4akFFRWdheUlFSkFBQ1FDQUNRUUZxSWdNZ0FrOEVRQ0FCS0FJRUlnSkJBWFFpQlNBRElBVWdBMHNiSWdOQkJDQURRUVJMR3lJRFFmLy8vLzhEY1NBRFJrRUJkQ0VGSUFOQkFuUWhBd0pBSUFJRVFDQUVRUmhxUVFJMkFnQWdCQ0FDUVFKME5nSVVJQVFnQVNnQ0FEWUNFQXdCQ3lBRVFRQTJBaEFMSUFRZ0F5QUZJQVJCRUdvUUpVRUJJUUlnQkVFSWFpZ0NBQ0VESUFRb0FnUWhCU0FFS0FJQVFRRkhCRUFnQVNBRk5nSUFJQUVnQTBFQ2RqWUNCRUVBSVFJTUFnc2dBQ0FGTmdJRUlBQkJDR29nQXpZQ0FBd0JDeUFBSUFNMkFnUWdBRUVJYWtFQU5nSUFRUUVoQWdzZ0FDQUNOZ0lBSUFSQklHb2tBQXZ3QVFFRWZ5TUFRU0JySWdRa0FBSkFJQUpCQVdvaUF5QUNUd1JBSUFFb0FnUWlCVUVCZENJQ0lBTWdBaUFEU3hzaUEwRUVJQU5CQkVzYklnTWdBMm9pQmlBRFQwRUJkQ0VEQWtBZ0JRUkFJQVJCR0dwQkFqWUNBQ0FFSUFJMkFoUWdCQ0FCS0FJQU5nSVFEQUVMSUFSQkFEWUNFQXNnQkNBR0lBTWdCRUVRYWhBbFFRRWhBaUFFUVFocUtBSUFJUU1nQkNnQ0JDRUZJQVFvQWdCQkFVY0VRQ0FCSUFVMkFnQWdBU0FEUVFGMk5nSUVRUUFoQWd3Q0N5QUFJQVUyQWdRZ0FFRUlhaUFETmdJQURBRUxJQUFnQXpZQ0JDQUFRUWhxUVFBMkFnQkJBU0VDQ3lBQUlBSTJBZ0FnQkVFZ2FpUUFDK2dCQVFWL0l3QkJFR3NpQXlRQUlBQXRBQXNoQWlBRFFnQTNBd2dnQVNnQ0FDRUZBa0FDUUNBQUFuOGdBU2dDQkNJRVFjQUFJQUpySWdaQitBRnhRUU4ySWdKSkJFQWdCRUVKVHcwQ0lBTkJDR29nQlNBRUVFa2FJQUZCQURZQ0JDQUJRYStGd0FBMkFnQWdCRUVEZEF3QkN5QUdRZjhCY1VISUFFOE5BaUFEUVFocUlBVWdBaEJKR2lBQklBUWdBbXMyQWdRZ0FTQUNJQVZxTmdJQUlBWkIrQUZ4Q3lBQUxRQUxJZ0ZxT2dBTElBQWdBQ2tEQUNBREtRTUlJQUZCUDNHdGhvUTNBd0FnQTBFUWFpUUFEd3NnQkVFSVFaQ0h3QUFRTmdBTElBSkJDRUdBaDhBQUVEWUFDODhCQVFOL0FrQWdBRUVFYWlnQ0FDSUVJQUJCQ0dvb0FnQWlBMnNnQWs4RVFDQUFLQUlBSVFRTUFRc0Nmd0pBQWtBZ0FpQURhaUlGSUFOSkRRQWdCRUVCZENJRElBVWdBeUFGU3hzaUEwRUlJQU5CQ0VzYklRTWdCQVJBSUFOQkFFZ05BU0FBS0FJQUlnVkZEUUlnQlNBRVFRRWdBeEJVREFNTElBTkJBRTROQVFzUVd3QUxJQU5CQVJCWEN5SUVCRUFnQUNBRU5nSUFJQUJCQkdvZ0F6WUNBQ0FBUVFocUtBSUFJUU1NQVFzZ0EwRUJFRjhBQ3lBRElBUnFJQUVnQWhCSkdpQUFRUWhxSUFJZ0EybzJBZ0FMM0FFQkJIOGpBRUZBYWlJQ0pBQWdBVUVFYWlFRUlBRW9BZ1JGQkVBZ0FTZ0NBQ0VESUFKQkFEWUNJQ0FDUWdFM0F4Z2dBaUFDUVJocU5nSWtJQUpCT0dvZ0EwRVFhaWtDQURjREFDQUNRVEJxSUFOQkNHb3BBZ0EzQXdBZ0FpQURLUUlBTndNb0lBSkJKR3BCd0lqQUFDQUNRU2hxRUFrYUlBSkJFR29pQXlBQ0tBSWdOZ0lBSUFJZ0Fpa0RHRGNEQ0FKQUlBRW9BZ1FpQlVVTkFDQUJRUWhxS0FJQVJRMEFJQVVRQkFzZ0JDQUNLUU1JTndJQUlBUkJDR29nQXlnQ0FEWUNBQXNnQUVIa2ljQUFOZ0lFSUFBZ0JEWUNBQ0FDUVVCckpBQUxuZ0lCQW44akFFRWdheUlESkFCQkFTRUVRZENsd0FCQjBLWEFBQ2dDQUVFQmFqWUNBQUpBQWtBQ1FFR1lxY0FBS0FJQVFRRkhCRUJCbUtuQUFFS0JnSUNBRURjREFBd0JDMEdjcWNBQVFaeXB3QUFvQWdCQkFXb2lCRFlDQUNBRVFRSkxEUUVMSUFNZ0FqWUNIQ0FESUFFMkFoZ2dBMEhZaU1BQU5nSVVJQU5CMklqQUFEWUNFRUhFcGNBQUtBSUFJZ0ZCZjB3TkFFSEVwY0FBSUFGQkFXb2lBVFlDQUVIRXBjQUFRY3lsd0FBb0FnQWlBZ1IvUWNpbHdBQW9BZ0FnQTBFSWFpQUFRZUNKd0FBb0FnQVJBZ0FnQXlBREtRTUlOd01RSUFOQkVHb2dBaWdDREJFQ0FFSEVwY0FBS0FJQUJTQUJDMEYvYWpZQ0FDQUVRUUZORFFFTEFBc2pBRUVRYXlJQkpBQWdBVUhRaWNBQU5nSU1JQUVnQURZQ0NBQUx6QUVCQW44Z0FVRVVhaWdDQUNJRklBTkIvLzhEY1NJRVN3UkFJQUVvQWd3Z0JFRUJkR292QVFBaEJTQUJLQUlJSWdRZ0FTZ0NCRVlFUUNBQklBUVFPaUFCS0FJSUlRUUxJQUVvQWdBZ0JFRUNkR29pQkNBQ09nQUNJQVFnQXpzQkFDQUJJQUVvQWdoQkFXbzJBZ2dnQVNnQ0ZDSUVJQUZCRUdvb0FnQkdCRUFnQVVFTWFpQUVFRHNnQVNnQ0ZDRUVDeUFCS0FJTUlBUkJBWFJxSUFWQkFXbzdBUUFnQVNBQktBSVVRUUZxTmdJVUlBQWdBam9BQWlBQUlBTTdBUUFQQ3lBRUlBVkJzSWpBQUJBMUFBdkpBUUVDZnlNQVFSQnJJZ0lrQUNBQktBSVlRWW1sd0FCQkNTQUJRUnhxS0FJQUtBSU1FUUVBSVFNZ0FrRUFPZ0FGSUFJZ0F6b0FCQ0FDSUFFMkFnQWdBaUFBTmdJTUlBSWdBa0VNYWhBU0lBSXRBQVFoQVNBQ0xRQUZCRUFnQVVIL0FYRWhBQ0FDQW45QkFTQUFEUUFhSUFJb0FnQWlBRUVjYWlnQ0FDZ0NEQ0VCSUFBb0FoZ2hBeUFBTFFBQVFRUnhSUVJBSUFOQnU0ekFBRUVDSUFFUkFRQU1BUXNnQTBHNmpNQUFRUUVnQVJFQkFBc2lBVG9BQkFzZ0FrRVFhaVFBSUFGQi93RnhRUUJIQzdZQkFRSi9Ba0FDZnlBQ1JRUkFJQUVoQkVFQUlRRkJBUXdCQ3lBQlFRQklCRUJCQVNFRFFRQWhBUXdDQ3dKQUFrQUNRQ0FES0FJQUlnVkZCRUFnQVVVTkFTQUJJQUlRVnlJRURRSU1Bd3NnQTBFSWFpZ0NBQ0VFSUFNb0FnUWlBd1JBSUFVZ0F5QUVJQUVRVkNJRVJRMEREQUlMSUFGRkRRRWdBU0FFRUZjaUJFVU5BZ3dCQ3lBQ0lRUUxRUUFNQVFzZ0FTRUVJQUloQVVFQkN5RURJQUFnQkRZQ0JBc2dBQ0FETmdJQUlBQkJDR29nQVRZQ0FBdWZBUUVEZnlBQVFnQTNBZ2dDUUNBQlFSUnFLQUlBSWdRZ0FrSC8vd054SWdOTEJFQWdBU2dDRENBRFFRRjBhaThCQUNFRElBQW9BZ1FoQkNBQVFRQTJBZ1FnQUNnQ0FDRUZJQUJCQVRZQ0FDQUVJQU5KRFFFZ0FTQUNJQVVnQXhBcElBQW9BZ1FFUUNBQUtBSUFFQVFMSUFBZ0F6WUNEQ0FBSUFRMkFnUWdBQ0FGTmdJQUR3c2dBeUFFUWRDSHdBQVFOUUFMSUFNZ0JFSGdoOEFBRURZQUM0Y0JBUUovSXdCQk1Hc2lCQ1FBSUFSQklHb2lCU0FDTmdJSUlBVWdBallDQkNBRklBRTJBZ0FnQkVFSWFpQUVRU0JxRUV3Z0JFRVFhaUFFS0FJSUlnRWdCQ2dDRENJQ0lBTVFHU0FDQkVBZ0FSQUVDeUFFUVNocUlBUkJHR29vQWdBMkFnQWdCQ0FFS1FNUU53TWdJQVFnQkVFZ2FoQk1JQUFnQkNrREFEY0RBQ0FFUVRCcUpBQUxnZ0VCQm44akFFRVFheUlESkFBZ0FDQUFLQUlJSUFFUU9TQUFLQUlBSVFVZ0FDZ0NDQ0VDSUFOQkNHcEJBU0FCRUZnZ0FpQUZhaUVFSUFNb0Fnd2lCaUFES0FJSUlnZExCRUFnQkNBR0lBZHJFRkVnQlNBQ0lBWnFJQWRySWdKcUlRUUxJQUFnQVFSL0lBUkJBRG9BQUNBQ1FRRnFCU0FDQ3pZQ0NDQURRUkJxSkFBTGpnRUJBMzhnQUNnQ0NDSUVJQUZCLy84RGNTSUZTd1JBSUFNRVFDQUFLQUlBSVFRZ0FrRi9haUVGSUFFaEFBTkFJQVFnQUVILy93TnhRUUowYWlJR0x3RUFJUUFnQXlBRmFpQUdMUUFDT2dBQUlBQWdBU0FBSUFGQi8vOERjVWtiSVFBZ0EwRi9haUlERFFBTElBSXRBQUFQQzBFQVFRQkJnSWpBQUJBMUFBc2dCVUVCYWlBRVFmQ0h3QUFRTmdBTFdBRURmeU1BUWRBQWF5SUJKQUFnQVJBV1FkQUFRUWdRVnlJQ0JFQWdBaUFCUWRBQUVFa2FRYmlFd0FBaEF5QUNRUUU2QUVnZ0FFRzRoTUFBTmdJRUlBQWdBallDQUNBQlFkQUFhaVFBRHd0QjBBQkJDQkJmQUF1QUFRSUNmd0YrSUFFdEFBc2lCQ0FCTFFBS0lnTkpCRUFnQVNBQ0VCY2dBUzBBQ3lFRUlBRXRBQW9oQXdzZ0JDQURRZjhCY1VrRWYwRUFCU0FCSUFRZ0EyczZBQXNnQVNBQktRTUFJQU90aVNJRklBRXZBUWdpQWExQ2Y0VkNnSUI4aElNM0F3QWdBU0FGcDNFaEEwRUJDeUVCSUFBZ0F6c0JBaUFBSUFFN0FRQUxlZ0VEZnlBQktBSUVJZ01nQWs4RVFBSkFJQU5GRFFBZ0FTZ0NBQ0VFQWtBZ0FnUkFJQVFnQTBFQklBSVFWQ0lERFFFZ0FDQUNOZ0lFSUFCQkNHcEJBVFlDQUVFQklRVU1BZ3RCQVNFRElBUVFCQXNnQVNBQ05nSUVJQUVnQXpZQ0FBc2dBQ0FGTmdJQUR3dEJ5NExBQUVFa1FmQ0N3QUFRUndBTGRRSUNmd0YrSUFFdEFBc2lCQ0FCTFFBS0lnTkpCRUFnQVNBQ0VCOGdBUzBBQ3lFRUlBRXRBQW9oQXdzZ0JDQURRZjhCY1VrRWYwRUFCU0FCSUFRZ0EyczZBQXNnQVNBQktRTUFJZ1VnQTYxQ1A0T0lOd01BSUFFdkFRZ2dCYWR4SVFOQkFRc2hBU0FBSUFNN0FRSWdBQ0FCT3dFQUMzUUJBMzhqQUVFZ2F5SUNKQUFDUUNBQUlBRVFHRVVFUUNBQlFSeHFLQUlBSVFNZ0FTZ0NHQ0FDUVJ4cVFRQTJBZ0FnQWtHMGlzQUFOZ0lZSUFKQ0FUY0NEQ0FDUWJpS3dBQTJBZ2dnQXlBQ1FRaHFFQWxGRFFFTElBSkJJR29rQUVFQkR3c2dBRUVFYWlBQkVCZ2dBa0VnYWlRQUN6QUJBWDhDUUFKQVFZQ0FBVUVDRUZjaUFRMEJEQUFMUVlDQUFVRUNFRjhBQ3lBQUlBRTJBZ0FnQUVHQUlEWUNCQXVHQVFFQmZ5TUFRVUJxSWdFa0FDQUJRU3MyQWd3Z0FVR0VnY0FBTmdJSUlBRkJzSUhBQURZQ0ZDQUJJQUEyQWhBZ0FVRXNha0VDTmdJQUlBRkJQR3BCSFRZQ0FDQUJRZ0kzQWh3Z0FVSHdpc0FBTmdJWUlBRkJHVFlDTkNBQklBRkJNR28yQWlnZ0FTQUJRUkJxTmdJNElBRWdBVUVJYWpZQ01DQUJRUmhxUWZTQXdBQVFVQUFMTUFFQmZ3SkFBa0JCZ01BQVFRSVFWeUlCRFFFTUFBdEJnTUFBUVFJUVh3QUxJQUFnQVRZQ0FDQUFRWUFnTmdJRUMzc0JBbjhDUUFKQUlBQW9BZ1FpQVFSQUlBQW9BZ3dpQWlBQlR3MEJJQUFvQWdBaUFTQUNhaUFCTFFBQU9nQUFJQUJCQURZQ0NDQUFJQUFvQWd4QkFXbzJBZ3dnQUNnQ0JFVU5BaUFBS0FJQUxRQUFEd3RCQUVFQVFhQ0h3QUFRTlFBTElBSWdBVUd3aDhBQUVEVUFDMEVBUVFCQndJZkFBQkExQUF0b0FRSi9JQUFnQUMwQVJpSUJRUUZxSWdJNkFBb2dBRUVCSUFGQkQzRjBRUUpxSWdFN0FVQWdBRUYvSUFKQkQzRjBRWDl6T3dFSUlBQkJHR29vQWdBZ0FVSC8vd054SWdGUEJFQWdBQ0FCTmdJWUN5QUFRU1JxS0FJQUlBRlBCRUFnQUNBQk5nSWtDd3RRQVFGL0lBQkJGR29vQWdBaUFVVWdBVUVDZEVWeVJRUkFJQUFvQWhBUUJBc2dBRUVnYWlnQ0FDSUJSU0FCUVFGMFJYSkZCRUFnQUNnQ0hCQUVDeUFBUVN4cUtBSUFCRUFnQUNnQ0tCQUVDd3RzQVFGL0l3QkJNR3NpQXlRQUlBTWdBVFlDQkNBRElBQTJBZ0FnQTBFY2FrRUNOZ0lBSUFOQkxHcEJHRFlDQUNBRFFnSTNBZ3dnQTBIRWk4QUFOZ0lJSUFOQkdEWUNKQ0FESUFOQklHbzJBaGdnQXlBRE5nSW9JQU1nQTBFRWFqWUNJQ0FEUVFocUlBSVFVQUFMYkFFQmZ5TUFRVEJySWdNa0FDQURJQUUyQWdRZ0F5QUFOZ0lBSUFOQkhHcEJBallDQUNBRFFTeHFRUmcyQWdBZ0EwSUNOd0lNSUFOQmtKREFBRFlDQ0NBRFFSZzJBaVFnQXlBRFFTQnFOZ0lZSUFNZ0EwRUVhallDS0NBRElBTTJBaUFnQTBFSWFpQUNFRkFBQzJ3QkFYOGpBRUV3YXlJREpBQWdBeUFCTmdJRUlBTWdBRFlDQUNBRFFSeHFRUUkyQWdBZ0EwRXNha0VZTmdJQUlBTkNBamNDRENBRFFjU1F3QUEyQWdnZ0EwRVlOZ0lrSUFNZ0EwRWdhallDR0NBRElBTkJCR28yQWlnZ0F5QUROZ0lnSUFOQkNHb2dBaEJRQUF0c0FRRi9Jd0JCTUdzaUF5UUFJQU1nQVRZQ0JDQURJQUEyQWdBZ0EwRWNha0VDTmdJQUlBTkJMR3BCR0RZQ0FDQURRZ0kzQWd3Z0EwSHdqOEFBTmdJSUlBTkJHRFlDSkNBRElBTkJJR28yQWhnZ0F5QURRUVJxTmdJb0lBTWdBellDSUNBRFFRaHFJQUlRVUFBTFhBRUJmeU1BUVJCcklnTWtBQUpBSUFBb0FnUWdBV3NnQWs4RVFDQURRUUEyQWdBTUFRc2dBeUFBSUFFZ0FoQVZJQU1vQWdCQkFVY05BQ0FEUVFocUtBSUFJZ0FFUUNBREtBSUVJQUFRWHdBTEVGc0FDeUFEUVJCcUpBQUxXZ0VCZnlNQVFSQnJJZ0lrQUFKQUlBQW9BZ1FnQVd0QkFVOEVRQ0FDUVFBMkFnQU1BUXNnQWlBQUlBRVFIU0FDS0FJQVFRRkhEUUFnQWtFSWFpZ0NBQ0lBQkVBZ0FpZ0NCQ0FBRUY4QUN4QmJBQXNnQWtFUWFpUUFDMW9CQVg4akFFRVFheUlDSkFBQ1FDQUFLQUlFSUFGclFRRlBCRUFnQWtFQU5nSUFEQUVMSUFJZ0FDQUJFQjRnQWlnQ0FFRUJSdzBBSUFKQkNHb29BZ0FpQUFSQUlBSW9BZ1FnQUJCZkFBc1FXd0FMSUFKQkVHb2tBQXRaQVFGL0l3QkJJR3NpQWlRQUlBSWdBQ2dDQURZQ0JDQUNRUmhxSUFGQkVHb3BBZ0EzQXdBZ0FrRVFhaUFCUVFocUtRSUFOd01BSUFJZ0FTa0NBRGNEQ0NBQ1FRUnFRY0NJd0FBZ0FrRUlhaEFKSUFKQklHb2tBQXRHQUFKQVFRZ2dBa2tFUUFKL1FRZ2dBa2tFUUNBQ0lBTVFFQXdCQ3lBREVBQUxJZ0lOQVVFQUR3c2dBQ0FERUFvUEN5QUNJQUFnQXlBQklBRWdBMHNiRUVrZ0FCQUVDMWtCQVg4akFFRWdheUlDSkFBZ0FpQUFLQUlBTmdJRUlBSkJHR29nQVVFUWFpa0NBRGNEQUNBQ1FSQnFJQUZCQ0dvcEFnQTNBd0FnQWlBQktRSUFOd01JSUFKQkJHcEJ0STdBQUNBQ1FRaHFFQWtnQWtFZ2FpUUFDMWtBQWtBQ1FBSkFJQUZCZjBvRVFBSkFJQUlFUUNBQkRRRU1CQXNnQVVVTkF5QUJRUUVRVnlJQ0RRUU1BZ3NnQVJCR0lnSkZEUUVNQXdzUVd3QUxJQUZCQVJCZkFBdEJBU0VDQ3lBQUlBRTJBZ1FnQUNBQ05nSUFDMVlCQVg4akFFRWdheUlDSkFBZ0FpQUFOZ0lFSUFKQkdHb2dBVUVRYWlrQ0FEY0RBQ0FDUVJCcUlBRkJDR29wQWdBM0F3QWdBaUFCS1FJQU53TUlJQUpCQkdwQnRJN0FBQ0FDUVFocUVBa2dBa0VnYWlRQUMxa0JBMzhDUUNBQktBSU1JZ0lnQVNnQ0NDSURUd1JBSUFFb0FnUWlCQ0FDU1EwQklBRW9BZ0FoQVNBQUlBSWdBMnMyQWdRZ0FDQUJJQU5xTmdJQUR3c2dBeUFDUVpDSXdBQVFOd0FMSUFJZ0JFR1FpTUFBRURZQUMxVUJBWDhnQUVFUWFpQUFMUUJHRUEwZ0FFRUFPZ0JISUFCQkFEc0JPQ0FBUVRCcVFnQTNBd0FnQUVFQU9nQUxJQUJDQURjREFDQUFJQUF0QUVaQkFXb2lBVG9BQ2lBQVFYOGdBVUVQY1hSQmYzTTdBUWdMUXdFRGZ3SkFJQUpGRFFBRFFDQUFMUUFBSWdRZ0FTMEFBQ0lGUmdSQUlBQkJBV29oQUNBQlFRRnFJUUVnQWtGL2FpSUNEUUVNQWdzTElBUWdCV3NoQXdzZ0F3dEZBUUYvSXdCQkVHc2lBaVFBSUFJZ0FDQUJFQ3dDUUNBQ0tBSUFRUUZHQkVBZ0FrRUlhaWdDQUNJQVJRMEJJQUlvQWdRZ0FCQmZBQXNnQWtFUWFpUUFEd3NRV3dBTFNnQUNmeUFCUVlDQXhBQkhCRUJCQVNBQUtBSVlJQUVnQUVFY2FpZ0NBQ2dDRUJFQUFBMEJHZ3NnQWtVRVFFRUFEd3NnQUNnQ0dDQUNJQU1nQUVFY2FpZ0NBQ2dDREJFQkFBc0xKZ0VCZndKQUlBQVFBQ0lCUlEwQUlBRkJmR290QUFCQkEzRkZEUUFnQVNBQUVGRUxJQUVMUndFQmZ5TUFRU0JySWdNa0FDQURRUlJxUVFBMkFnQWdBMEcwaXNBQU5nSVFJQU5DQVRjQ0JDQURJQUUyQWh3Z0F5QUFOZ0lZSUFNZ0EwRVlhallDQUNBRElBSVFVQUFMV3dFRGZ5TUFRUkJySWdFa0FDQUFLQUlNSWdKRkJFQkI2SWpBQUVFclFiQ0p3QUFRUndBTElBQW9BZ2dpQTBVRVFFSG9pTUFBUVN0QndJbkFBQkJIQUFzZ0FTQUNOZ0lJSUFFZ0FEWUNCQ0FCSUFNMkFnQWdBUkJQQUFzekFRRi9JQUlFUUNBQUlRTURRQ0FESUFFdEFBQTZBQUFnQVVFQmFpRUJJQU5CQVdvaEF5QUNRWDlxSWdJTkFBc0xJQUFMS2dBQ1FDQUFRWHhMRFFBZ0FFVUVRRUVFRHdzZ0FDQUFRWDFKUVFKMEVGY2lBRVVOQUNBQUR3c0FDekVCQVg4Z0FTZ0NCQ0lDQkVBZ0FDQUNOZ0lFSUFCQkNHcEJBVFlDQUNBQUlBRW9BZ0EyQWdBUEN5QUFRUUEyQWdBTE1RRUJmeUFBSUFFb0FnUWdBU2dDQ0NJQ1N3Ui9JQUVnQWhCRUlBRW9BZ2dGSUFJTE5nSUVJQUFnQVNnQ0FEWUNBQXN3QVFGL0l3QkJFR3NpQVNRQUlBRkJBRFlDQkNBQklBQW9BZ0EyQWdBZ0FTQUFLQUlFS0FJSUlBQW9BZ2dRSWdBTEtBRUJmeUFBS0FJSUlnSWdBVThFUUNBQUtBSUFHaUFBSUFFMkFnZ1BDeUFBSUFFZ0Ftc1FLQXNzQVFGL0l3QkJFR3NpQVNRQUlBRkJDR29nQUVFSWFpZ0NBRFlDQUNBQklBQXBBZ0EzQXdBZ0FSQk5BQXMwQVFGL0l3QkJFR3NpQWlRQUlBSWdBVFlDRENBQ0lBQTJBZ2dnQWtHQWk4QUFOZ0lFSUFKQnRJckFBRFlDQUNBQ0VFZ0FDeUVBSUFFRVFBTkFJQUJCQURvQUFDQUFRUUZxSVFBZ0FVRi9haUlCRFFBTEN3c2dBUUYvQWtBZ0FDZ0NBQ0lCUlEwQUlBQkJCR29vQWdCRkRRQWdBUkFFQ3dzZ0FRRi9Ba0FnQUNnQ0JDSUJSUTBBSUFCQkNHb29BZ0JGRFFBZ0FSQUVDd3NNQUNBQUlBRWdBaUFERUQwTEN3QWdBUVJBSUFBUUJBc0xGQUFnQUNnQ0FDQUJJQUFvQWdRb0Fnd1JBQUFMR1FBQ2YwRUlJQUZKQkVBZ0FTQUFFQkFNQVFzZ0FCQUFDd3NRQUNBQUlBSTJBZ1FnQUNBQk5nSUFDdzhBSUFBb0FnQWdBU0FDRUNCQkFBc1FBQ0FCSUFBb0FnQWdBQ2dDQkJBRkN4RUFRWkNLd0FCQkVVR2tpc0FBRUVjQUN3NEFJQUFvQWdBYUEwQU1BQXNBQ3dzQUlBQTFBZ0FnQVJBVUN3MEFJQUFvQWdBZ0FTQUNFQXNMR1FBZ0FDQUJRY0Nsd0FBb0FnQWlBRUVOSUFBYkVRSUFBQXNOQUNBQlFZaVB3QUJCQWhBRkN3a0FJQUJCQURvQVJ3c0hBQ0FBTFFCSEN3MEFRcnFaejdiQWlxNzYxZ0FMREFCQ3dJcjY4K2l6bzYxQUN3TUFBUXNEQUFFTEM2TWxBUUJCZ0lEQUFBdVpKUzlWYzJWeWN5OTBjbVYyYjNKdFlXNTZMeTV5ZFhOMGRYQXZkRzl2YkdOb1lXbHVjeTlpWlhSaExYZzRObDgyTkMxaGNIQnNaUzFrWVhKM2FXNHZiR2xpTDNKMWMzUnNhV0l2YzNKakwzSjFjM1F2YkdsaWNtRnllUzlqYjNKbEwzTnlZeTloYkd4dll5OXNZWGx2ZFhRdWNuTUFBQUFRQUhNQUFBQUtBUUFBT1FBQUFHTmhiR3hsWkNCZ1VtVnpkV3gwT2pwMWJuZHlZWEFvS1dBZ2IyNGdZVzRnWUVWeWNtQWdkbUZzZFdVQUFRQUFBQUFBQUFBQkFBQUFBZ0FBQUhOeVl5OXNhV0l1Y25NQUFNQUFFQUFLQUFBQUhRQUFBQklBQUFBdlZYTmxjbk12ZEhKbGRtOXliV0Z1ZWk4dWNuVnpkSFZ3TDNSdmIyeGphR0ZwYm5NdlltVjBZUzE0T0RaZk5qUXRZWEJ3YkdVdFpHRnlkMmx1TDJ4cFlpOXlkWE4wYkdsaUwzTnlZeTl5ZFhOMEwyeHBZbkpoY25rdllXeHNiMk12YzNKakwzSmhkMTkyWldNdWNuTlVjbWxsWkNCMGJ5QnphSEpwYm1zZ2RHOGdZU0JzWVhKblpYSWdZMkZ3WVdOcGRIa0EzQUFRQUc4QUFBRE9BUUFBQ1FBQUFHRnpjMlZ5ZEdsdmJpQm1ZV2xzWldRNklHMXBaQ0E4UFNCc1pXNHZWWE5sY25NdmRISmxkbTl5YldGdWVpOHVjblZ6ZEhWd0wzUnZiMnhqYUdGcGJuTXZZbVYwWVMxNE9EWmZOalF0WVhCd2JHVXRaR0Z5ZDJsdUwyeHBZaTl5ZFhOMGJHbGlMM055WXk5eWRYTjBMMnhwWW5KaGNua3ZZMjl5WlM5emNtTXZjMnhwWTJVdmJXOWtMbkp6bkFFUUFIQUFBQUNqQkFBQURRQUFBQU1BQUFCUUFBQUFDQUFBQUFRQUFBQUZBQUFBQmdBQUFBY0FBQUFJQUFBQVVBQUFBQWdBQUFBSkFBQUFDZ0FBQUFzQUFBQU1BQUFBTDFWelpYSnpMM1J5WlhadmNtMWhibm92TG1OaGNtZHZMM0psWjJsemRISjVMM055WXk5bmFYUm9kV0l1WTI5dExURmxZMk0yTWprNVpHSTVaV000TWpNdmQyVmxlbXd0TUM0eExqQXZjM0pqTDJSbFkyOWtaUzV5Y3dCVUFoQUFXd0FBQVA4QkFBQWZBQUFBVkFJUUFGc0FBQUFTQWdBQUd3QUFBRlFDRUFCYkFBQUFKd0lBQUNZQUFBQlVBaEFBV3dBQUFGQUNBQUFSQUFBQVZBSVFBRnNBQUFCU0FnQUFFUUFBQUZRQ0VBQmJBQUFBWGdJQUFCa0FBQUJVQWhBQVd3QUFBSElDQUFBaUFBQUFWQUlRQUZzQUFBQjBBZ0FBR3dBQUFGUUNFQUJiQUFBQWRRSUFBQlVBQUFCVUFoQUFXd0FBQUhZQ0FBQVZBQUFBVkFJUUFGc0FBQUNnQWdBQURRQUFBRlFDRUFCYkFBQUE3QUlBQUJFQUFBQlVBaEFBV3dBQUFQSUNBQUFSQUFBQVZBSVFBRnNBQUFBeEF3QUFFUUFBQUZRQ0VBQmJBQUFBTndNQUFCRUFBQUJVQWhBQVd3QUFBRjhEQUFBbkFBQUFWQUlRQUZzQUFBQmZBd0FBQ1FBQUFGUUNFQUJiQUFBQVlnTUFBQWtBQUFCVUFoQUFXd0FBQUdnREFBQVZBQUFBVkFJUUFGc0FBQUJyQXdBQUdBQUFBRlFDRUFCYkFBQUFkUU1BQUJZQUFBQlVBaEFBV3dBQUFJQURBQUFKQUFBQVZBSVFBRnNBQUFDRUF3QUFDZ0FBQUZRQ0VBQmJBQUFBcWdNQUFBb0FBQUJVQWhBQVd3QUFBTGNEQUFBVkFBQUFEZ0FBQUFRQUFBQUVBQUFBRHdBQUFCQUFBQUFSQUFBQURnQUFBQUFBQUFBQkFBQUFFZ0FBQUdOaGJHeGxaQ0JnVDNCMGFXOXVPanAxYm5keVlYQW9LV0FnYjI0Z1lTQmdUbTl1WldBZ2RtRnNkV1ZzYVdKeVlYSjVMM04wWkM5emNtTXZjR0Z1YVdOcmFXNW5Mbkp6QUpNRUVBQWNBQUFBMlFFQUFCOEFBQUNUQkJBQUhBQUFBTm9CQUFBZUFBQUFFd0FBQUJBQUFBQUVBQUFBRkFBQUFCVUFBQUFXQUFBQURBQUFBQVFBQUFBWEFBQUFiR2xpY21GeWVTOWhiR3h2WXk5emNtTXZjbUYzWDNabFl5NXljMk5oY0dGamFYUjVJRzkyWlhKbWJHOTNBQUFBOUFRUUFCd0FBQUFaQWdBQUJRQUFBR0F1TGdBMUJSQUFBZ0FBQUdOaGJHeGxaQ0JnVDNCMGFXOXVPanAxYm5keVlYQW9LV0FnYjI0Z1lTQmdUbTl1WldBZ2RtRnNkV1U2SUFBQUFEUUZFQUFBQUFBQWF3VVFBQUlBQUFBZUFBQUFBQUFBQUFFQUFBQWZBQUFBYVc1a1pYZ2diM1YwSUc5bUlHSnZkVzVrY3pvZ2RHaGxJR3hsYmlCcGN5QWdZblYwSUhSb1pTQnBibVJsZUNCcGN5QUFBSkFGRUFBZ0FBQUFzQVVRQUJJQUFBQnNhV0p5WVhKNUwyTnZjbVV2YzNKakwyWnRkQzlpZFdsc1pHVnljeTV5Y3g0QUFBQU1BQUFBQkFBQUFDQUFBQUFoQUFBQUlnQUFBQ0FnSUNEVUJSQUFJQUFBQURBQUFBQWhBQUFBMUFVUUFDQUFBQUF4QUFBQUVnQUFBQ0I3Q2l3S0xDQWdleUI5SUgxc2FXSnlZWEo1TDJOdmNtVXZjM0pqTDJadGRDOXVkVzB1Y25NOUJoQUFHd0FBQUZRQUFBQVVBQUFBTUhnd01EQXhNREl3TXpBME1EVXdOakEzTURnd09URXdNVEV4TWpFek1UUXhOVEUyTVRjeE9ERTVNakF5TVRJeU1qTXlOREkxTWpZeU56STRNamt6TURNeE16SXpNek0wTXpVek5qTTNNemd6T1RRd05ERTBNalF6TkRRME5UUTJORGMwT0RRNU5UQTFNVFV5TlRNMU5EVTFOVFkxTnpVNE5UazJNRFl4TmpJMk16WTBOalUyTmpZM05qZzJPVGN3TnpFM01qY3pOelEzTlRjMk56YzNPRGM1T0RBNE1UZ3lPRE00TkRnMU9EWTROemc0T0RrNU1Ea3hPVEk1TXprME9UVTVOamszT1RnNU9RQUFIZ0FBQUFRQUFBQUVBQUFBSXdBQUFDUUFBQUFsQUFBQWJHbGljbUZ5ZVM5amIzSmxMM055WXk5bWJYUXZiVzlrTG5KekFFd0hFQUFiQUFBQVdRUUFBQkVBQUFCTUJ4QUFHd0FBQUdNRUFBQWtBQUFBS0Nsc2FXSnlZWEo1TDJOdmNtVXZjM0pqTDNOc2FXTmxMMjFsYldOb2NpNXljd0FBaWdjUUFDQUFBQUJTQUFBQUJRQUFBSEpoYm1kbElITjBZWEowSUdsdVpHVjRJQ0J2ZFhRZ2IyWWdjbUZ1WjJVZ1ptOXlJSE5zYVdObElHOW1JR3hsYm1kMGFDQzhCeEFBRWdBQUFNNEhFQUFpQUFBQWNtRnVaMlVnWlc1a0lHbHVaR1Y0SUFBSUVBQVFBQUFBemdjUUFDSUFBQUJ6YkdsalpTQnBibVJsZUNCemRHRnlkSE1nWVhRZ0lHSjFkQ0JsYm1SeklHRjBJQUFnQ0JBQUZnQUFBRFlJRUFBTkFBQUFiR2xpY21GeWVTOWpiM0psTDNOeVl5OXpkSEl2Y0dGMGRHVnliaTV5Y3dCVUNCQUFId0FBQUxBQkFBQW1BQUFBV3k0dUxsMWllWFJsSUdsdVpHVjRJQ0JwY3lCdmRYUWdiMllnWW05MWJtUnpJRzltSUdBQUFJa0lFQUFMQUFBQWxBZ1FBQllBQUFBMEJSQUFBUUFBQUdKbFoybHVJRHc5SUdWdVpDQW9JRHc5SUNrZ2QyaGxiaUJ6YkdsamFXNW5JR0FBQU1RSUVBQU9BQUFBMGdnUUFBUUFBQURXQ0JBQUVBQUFBRFFGRUFBQkFBQUFJR2x6SUc1dmRDQmhJR05vWVhJZ1ltOTFibVJoY25rN0lHbDBJR2x6SUdsdWMybGtaU0FnS0dKNWRHVnpJQ2tnYjJZZ1lJa0lFQUFMQUFBQUNBa1FBQ1lBQUFBdUNSQUFDQUFBQURZSkVBQUdBQUFBTkFVUUFBRUFBQUJzYVdKeVlYSjVMMk52Y21VdmMzSmpMM1Z1YVdOdlpHVXZjSEpwYm5SaFlteGxMbkp6QUFBQVpBa1FBQ1VBQUFBS0FBQUFIQUFBQUdRSkVBQWxBQUFBR2dBQUFEWUFBQUFBQVFNRkJRWUdBd2NHQ0FnSkVRb2NDeGtNRkEwUURnMFBCQkFERWhJVENSWUJGd1VZQWhrREdnY2NBaDBCSHhZZ0F5c0RMQUl0Q3k0Qk1BTXhBaklCcHdLcEFxb0Vxd2o2QXZzRi9RVCtBLzhKclhoNWk0MmlNRmRZaTR5UUhCM2REZzlMVFB2OExpOC9YRjFmdGVLRWpZNlJrcW14dXJ2RnhzbkszdVRsL3dBRUVSSXBNVFEzT2pzOVNVcGRoSTZTcWJHMHVydkd5czdQNU9VQUJBME9FUklwTVRRNk8wVkdTVXBlWkdXRWtadWR5YzdQRFJFcFJVbFhaR1dOa2FtMHVydkZ5ZC9rNWZBTkVVVkpaR1dBaExLOHZyL1YxL0R4ZzRXTHBLYSt2OFhIenMvYTIwaVl2YzNHenM5SlRrOVhXVjVmaVk2UHNiYTN2OEhHeDljUkZoZGJYUGIzL3YrQURXMXgzdDhPRHg5dWJ4d2RYMzErcnErN3ZQb1dGeDRmUmtkT1QxaGFYRjUrZjdYRjFOWGM4UEgxY25PUGRIV1dMMThtTGkrbnI3ZS94OC9YMzVwQWw1Z3dqeC9Bd2M3L1RrOWFXd2NJRHhBbkwrN3ZibTgzUFQ5Q1JaQ1IvdjlUWjNYSXlkRFIyTm5uL3Y4QUlGOGlndDhFZ2tRSUd3UUdFWUdzRG9Dck5TZ0xnT0FER1FnQkJDOEVOQVFIQXdFSEJnY1JDbEFQRWdkVkJ3TUVIQW9KQXdnREJ3TUNBd01EREFRRkF3c0dBUTRWQlRvREVRY0dCUkFIVndjQ0J4VU5VQVJEQXkwREFRUVJCZzhNT2dRZEpWOGdiUVJxSllESUJZS3dBeG9HZ3YwRFdRY1ZDeGNKRkF3VURHb0dDZ1lhQmxrSEt3VkdDaXdFREFRQkF6RUxMQVFhQmdzRGdLd0dDZ1loUDB3RUxRTjBDRHdERHdNOEJ6Z0lLd1dDL3hFWUNDOFJMUU1nRUNFUGdJd0VncGNaQ3hXSWxBVXZCVHNIQWc0WUNZQ3pMWFFNZ05ZYURBV0Evd1dBM3d6dURRT0VqUU0zQ1lGY0ZJQzRDSURMS2pnRENnWTRDRVlJREFaMEN4NERXZ1JaQ1lDREdCd0tGZ2xNQklDS0JxdWtEQmNFTWFFRWdkb21Cd3dGQllDbEVZRnRFSGdvS2daTUJJQ05CSUMrQXhzRER3MEFCZ0VCQXdFRUFnZ0lDUUlLQlFzQ0RnUVFBUkVDRWdVVEVSUUJGUUlYQWhrTkhBVWRDQ1FCYWdOckFyd0MwUUxVRE5VSjFnTFhBdG9CNEFYaEF1Z0M3aUR3QlBnQytRTDZBdnNCRENjN1BrNVBqNTZlbndZSENUWTlQbGJ6ME5FRUZCZzJOMVpYZjZxdXI3MDE0QktIaVk2ZUJBME9FUklwTVRRNlJVWkpTazVQWkdWY3RyY2JIQWNJQ2dzVUZ6WTVPcWlwMk5rSk41Q1JxQWNLT3o1bWFZK1NiMS91NzFwaW1wc25LRldkb0tHanBLZW9yYnE4eEFZTERCVWRPajlGVWFhbnpNMmdCeGthSWlVK1A4WEdCQ0FqSlNZb016ZzZTRXBNVUZOVlZsaGFYRjVnWTJWbWEzTjRmWCtLcEtxdnNNRFFycTk1ekc1dmsxNGlld1VEQkMwRFpnTUJMeTZBZ2gwRE1ROGNCQ1FKSGdVckJVUUVEaXFBcWdZa0JDUUVLQWcwQ3dHQWtJRTNDUllLQ0lDWU9RTmpDQWt3RmdVaEF4c0ZBVUE0QkVzRkx3UUtCd2tIUUNBbkJBd0pOZ002QlJvSEJBd0hVRWszTXcwekJ5NElDb0VtVWs0b0NDcFdIQlFYQ1U0RUhnOUREaGtIQ2daSUNDY0pkUXMvUVNvR093VUtCbEVHQVFVUUF3V0FpMkllU0FnS2dLWmVJa1VMQ2dZTkV6a0hDallzQkJDQXdEeGtVd3hJQ1FwR1JSdElDRk1kT1lFSFJnb2RBMGRKTndNT0NBb0dPUWNLZ1RZWmdMY0JEeklOZzV0bWRRdUF4SXE4aEMrUDBZSkhvYm1DT1FjcUJBSmdKZ3BHQ2lnRkU0S3dXMlZMQkRrSEVVQUZDd0lPbC9nSWhOWXFDYUwzZ1I4eEF4RUVDSUdNaVFSckJRMERDUWNRazJDQTlncHpDRzRYUm9DYUZBeFhDUm1BaDRGSEE0VkNEeFdGVUN1QTFTMERHZ1FDZ1hBNkJRR0ZBSURYS1V3RUNnUUNneEZFVEQyQXdqd0dBUVJWQlJzMEFvRU9MQVJrREZZS2dLNDRIUTBzQkFrSEFnNEdnSnFEMkFnTkF3MERkQXhaQnd3VURBUTRDQW9HS0FnaVRvRlVEQlVEQXdVSENSa0hCd2tERFFjcGdNc2xDb1FHYkdsaWNtRnllUzlqYjNKbEwzTnlZeTkxYm1samIyUmxMM1Z1YVdOdlpHVmZaR0YwWVM1eWN3RHpEaEFBS0FBQUFFc0FBQUFvQUFBQTh3NFFBQ2dBQUFCWEFBQUFGZ0FBQVBNT0VBQW9BQUFBVWdBQUFENEFBQUFlQUFBQUJBQUFBQVFBQUFBbUFBQUFBQU1BQUlNRUlBQ1JCV0FBWFJPZ0FCSVhvQjRNSU9BZTd5d2dLeW93b0N0dnBtQXNBcWpnTEI3NzRDMEEvcUExbnYvZ05mMEJZVFlCQ3FFMkpBMWhONnNPNFRndkdDRTVNQnhoUnZNZW9VcndhbUZPVDIraFRwMjhJVTlsMGVGUEFOb2hVQURnNFZFdzRXRlQ3T0toVk5EbzRWUWdBQzVWOEFHL1ZRQndBQWNBTFFFQkFRSUJBZ0VCU0Fzd0ZSQUJaUWNDQmdJQ0FRUWpBUjRiV3dzNkNRa0JHQVFCQ1FFREFRVXJBM2NQQVNBM0FRRUJCQWdFQVFNSENnSWRBVG9CQVFFQ0JBZ0JDUUVLQWhvQkFnSTVBUVFDQkFJQ0F3TUJIZ0lEQVFzQ09RRUVCUUVDQkFFVUFoWUdBUUU2QVFFQ0FRUUlBUWNEQ2dJZUFUc0JBUUVNQVFrQktBRURBVGtEQlFNQkJBY0NDd0lkQVRvQkFnRUNBUU1CQlFJSEFnc0NIQUk1QWdFQkFnUUlBUWtCQ2dJZEFVZ0JCQUVDQXdFQkNBRlJBUUlIREFoaUFRSUpDd1pLQWhzQkFRRUJBVGNPQVFVQkFnVUxBU1FKQVdZRUFRWUJBZ0lDR1FJRUF4QUVEUUVDQWdZQkR3RUFBd0FESFFNZEFoNENRQUlCQndnQkFnc0pBUzBEZHdJaUFYWURCQUlKQVFZRDJ3SUNBVG9CQVFjQkFRRUJBZ2dHQ2dJQk1CRS9CREFIQVFFRkFTZ0pEQUlnQkFJQ0FRTTRBUUVDQXdFQkF6b0lBZ0tZQXdFTkFRY0VBUVlCQXdMR09nRUZBQUhESVFBRGpRRmdJQUFHYVFJQUJBRUtJQUpRQWdBQkF3RUVBUmtDQlFHWEFob1NEUUVtQ0JrTExnTXdBUUlFQWdJbkFVTUdBZ0lDQWd3QkNBRXZBVE1CQVFNQ0FnVUNBUUVxQWdnQjdnRUNBUVFCQUFFQUVCQVFBQUlBQWVJQmxRVUFBd0VDQlFRb0F3UUJwUUlBQkFBQ21RdXdBVFlQT0FNeEJBSUNSUU1rQlFFSVBnRU1BalFKQ2dRQ0FWOERBZ0VCQWdZQm9BRURDQlVDT1FJQkFRRUJGZ0VPQndNRnd3Z0NBd0VCRndGUkFRSUdBUUVDQVFFQ0FRTHJBUUlFQmdJQkFoc0NWUWdDQVFFQ2FnRUJBUUlHQVFGbEF3SUVBUVVBQ1FFQzlRRUtBZ0VCQkFHUUJBSUNCQUVnQ2lnR0FnUUlBUWtHQWdNdURRRUNBQWNCQmdFQlVoWUNCd0VDQVFKNkJnTUJBUUlCQndFQlNBSURBUUVCQUFJQUJUc0hBQUUvQkZFQkFBSUFBUUVEQkFVSUNBSUhIZ1NVQXdBM0JESUlBUTRCRmdVQkR3QUhBUkVDQndFQ0FRVUFCd0FFQUFkdEJ3QmdnUEFBVEdGNWIzVjBSWEp5Y0hKcGRtRjBaUUNDQVFsd2NtOWtkV05sY25NQ0NHeGhibWQxWVdkbEFRUlNkWE4wQUF4d2NtOWpaWE56WldRdFlua0RCWEoxYzNSakpERXVORGN1TUMxaVpYUmhMaklnS0RnMFlqQTBOMkptTmlBeU1ESXdMVEE0TFRJNEtRWjNZV3h5ZFhNR01DNHhPQzR3REhkaGMyMHRZbWx1WkdkbGJoSXdMakl1TmpjZ0tEZGlZV1JqWkROaFpDaz0iKTtsZXQgRzthc3luYyBmdW5jdGlvbiBGKEEsSSl7R3x8KEc9YXdhaXQoYXN5bmMoKT0+KGF3YWl0IEUobyksRCkpKCkpO2NvbnN0IGc9Ry5kZWNvbXByZXNzKEEsSSk7aWYoMD09PWcubGVuZ3RoKXRocm93IEVycm9yKCJGYWlsZWQgdG8gZGVjb2RlIHdpdGggTFpXIGRlY29kZXIuIik7cmV0dXJuIGd9CgogIGNsYXNzIExaV0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7CiAgICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5KSB7CiAgICAgIHN1cGVyKCk7CiAgICAgIGNvbnN0IHdpZHRoID0gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggfHwgZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoOwogICAgICBjb25zdCBoZWlnaHQgPSBmaWxlRGlyZWN0b3J5LlRpbGVMZW5ndGggfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aDsKICAgICAgY29uc3QgbmJ5dGVzID0gZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdIC8gODsKICAgICAgdGhpcy5tYXhVbmNvbXByZXNzZWRTaXplID0gd2lkdGggKiBoZWlnaHQgKiBuYnl0ZXM7CiAgICB9CgogICAgYXN5bmMgZGVjb2RlQmxvY2soYnVmZmVyKSB7CiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTsKICAgICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IEYoYnl0ZXMsIHRoaXMubWF4VW5jb21wcmVzc2VkU2l6ZSk7CiAgICAgIHJldHVybiBkZWNvZGVkLmJ1ZmZlcjsKICAgIH0KICB9CgogIC8qIC0qLSB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotIC8KICAvKiB2aW06IHNldCBzaGlmdHdpZHRoPTIgdGFic3RvcD0yIGF1dG9pbmRlbnQgY2luZGVudCBleHBhbmR0YWI6ICovCiAgLyoKICAgICBDb3B5cmlnaHQgMjAxMSBub3RtYXN0ZXJ5ZXQKICAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICAgICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAgICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiAgICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUKICAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAiQVMgSVMiIEJBU0lTLAogICAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgogICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQKICAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KICAqLwoKICAvLyAtIFRoZSBKUEVHIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBJVFUgQ0NJVFQgUmVjb21tZW5kYXRpb24gVC44MQogIC8vICAgKHd3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZikKICAvLyAtIFRoZSBKRklGIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBKUEVHIEZpbGUgSW50ZXJjaGFuZ2UgRm9ybWF0CiAgLy8gICAod3d3LnczLm9yZy9HcmFwaGljcy9KUEVHL2pmaWYzLnBkZikKICAvLyAtIFRoZSBBZG9iZSBBcHBsaWNhdGlvbi1TcGVjaWZpYyBKUEVHIG1hcmtlcnMgaW4gdGhlIFN1cHBvcnRpbmcgdGhlIERDVCBGaWx0ZXJzCiAgLy8gICBpbiBQb3N0U2NyaXB0IExldmVsIDIsIFRlY2huaWNhbCBOb3RlICM1MTE2CiAgLy8gICAocGFydG5lcnMuYWRvYmUuY29tL3B1YmxpYy9kZXZlbG9wZXIvZW4vcHMvc2RrLzUxMTYuRENUX0ZpbHRlci5wZGYpCgoKICBjb25zdCBkY3RaaWdaYWcgPSBuZXcgSW50MzJBcnJheShbCiAgICAwLAogICAgMSwgOCwKICAgIDE2LCA5LCAyLAogICAgMywgMTAsIDE3LCAyNCwKICAgIDMyLCAyNSwgMTgsIDExLCA0LAogICAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLAogICAgNDgsIDQxLCAzNCwgMjcsIDIwLCAxMywgNiwKICAgIDcsIDE0LCAyMSwgMjgsIDM1LCA0MiwgNDksIDU2LAogICAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsCiAgICAyMywgMzAsIDM3LCA0NCwgNTEsIDU4LAogICAgNTksIDUyLCA0NSwgMzgsIDMxLAogICAgMzksIDQ2LCA1MywgNjAsCiAgICA2MSwgNTQsIDQ3LAogICAgNTUsIDYyLAogICAgNjMsCiAgXSk7CgogIGNvbnN0IGRjdENvczEgPSA0MDE3OyAvLyBjb3MocGkvMTYpCiAgY29uc3QgZGN0U2luMSA9IDc5OTsgLy8gc2luKHBpLzE2KQogIGNvbnN0IGRjdENvczMgPSAzNDA2OyAvLyBjb3MoMypwaS8xNikKICBjb25zdCBkY3RTaW4zID0gMjI3NjsgLy8gc2luKDMqcGkvMTYpCiAgY29uc3QgZGN0Q29zNiA9IDE1Njc7IC8vIGNvcyg2KnBpLzE2KQogIGNvbnN0IGRjdFNpbjYgPSAzNzg0OyAvLyBzaW4oNipwaS8xNikKICBjb25zdCBkY3RTcXJ0MiA9IDU3OTM7IC8vIHNxcnQoMikKICBjb25zdCBkY3RTcXJ0MWQyID0gMjg5NjsvLyBzcXJ0KDIpIC8gMgoKICBmdW5jdGlvbiBidWlsZEh1ZmZtYW5UYWJsZShjb2RlTGVuZ3RocywgdmFsdWVzKSB7CiAgICBsZXQgayA9IDA7CiAgICBjb25zdCBjb2RlID0gW107CiAgICBsZXQgbGVuZ3RoID0gMTY7CiAgICB3aGlsZSAobGVuZ3RoID4gMCAmJiAhY29kZUxlbmd0aHNbbGVuZ3RoIC0gMV0pIHsKICAgICAgLS1sZW5ndGg7CiAgICB9CiAgICBjb2RlLnB1c2goeyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pOwoKICAgIGxldCBwID0gY29kZVswXTsKICAgIGxldCBxOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHsKICAgICAgICBwID0gY29kZS5wb3AoKTsKICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gdmFsdWVzW2tdOwogICAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkgewogICAgICAgICAgcCA9IGNvZGUucG9wKCk7CiAgICAgICAgfQogICAgICAgIHAuaW5kZXgrKzsKICAgICAgICBjb2RlLnB1c2gocCk7CiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoIDw9IGkpIHsKICAgICAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pOwogICAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47CiAgICAgICAgICBwID0gcTsKICAgICAgICB9CiAgICAgICAgaysrOwogICAgICB9CiAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkgewogICAgICAgIC8vIHAgaGVyZSBwb2ludHMgdG8gbGFzdCBjb2RlCiAgICAgICAgY29kZS5wdXNoKHEgPSB7IGNoaWxkcmVuOiBbXSwgaW5kZXg6IDAgfSk7CiAgICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47CiAgICAgICAgcCA9IHE7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBjb2RlWzBdLmNoaWxkcmVuOwogIH0KCiAgZnVuY3Rpb24gZGVjb2RlU2NhbihkYXRhLCBpbml0aWFsT2Zmc2V0LAogICAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsCiAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCwKICAgIHN1Y2Nlc3NpdmVQcmV2LCBzdWNjZXNzaXZlKSB7CiAgICBjb25zdCB7IG1jdXNQZXJMaW5lLCBwcm9ncmVzc2l2ZSB9ID0gZnJhbWU7CgogICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpbml0aWFsT2Zmc2V0OwogICAgbGV0IG9mZnNldCA9IGluaXRpYWxPZmZzZXQ7CiAgICBsZXQgYml0c0RhdGEgPSAwOwogICAgbGV0IGJpdHNDb3VudCA9IDA7CiAgICBmdW5jdGlvbiByZWFkQml0KCkgewogICAgICBpZiAoYml0c0NvdW50ID4gMCkgewogICAgICAgIGJpdHNDb3VudC0tOwogICAgICAgIHJldHVybiAoYml0c0RhdGEgPj4gYml0c0NvdW50KSAmIDE7CiAgICAgIH0KICAgICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTsKICAgICAgaWYgKGJpdHNEYXRhID09PSAweEZGKSB7CiAgICAgICAgY29uc3QgbmV4dEJ5dGUgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICBpZiAobmV4dEJ5dGUpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrZXI6ICR7KChiaXRzRGF0YSA8PCA4KSB8IG5leHRCeXRlKS50b1N0cmluZygxNil9YCk7CiAgICAgICAgfQogICAgICAgIC8vIHVuc3R1ZmYgMAogICAgICB9CiAgICAgIGJpdHNDb3VudCA9IDc7CiAgICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNzsKICAgIH0KICAgIGZ1bmN0aW9uIGRlY29kZUh1ZmZtYW4odHJlZSkgewogICAgICBsZXQgbm9kZSA9IHRyZWU7CiAgICAgIGxldCBiaXQ7CiAgICAgIHdoaWxlICgoYml0ID0gcmVhZEJpdCgpKSAhPT0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduCiAgICAgICAgbm9kZSA9IG5vZGVbYml0XTsKICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7CiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGh1ZmZtYW4gc2VxdWVuY2UnKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICBmdW5jdGlvbiByZWNlaXZlKGluaXRpYWxMZW5ndGgpIHsKICAgICAgbGV0IGxlbmd0aCA9IGluaXRpYWxMZW5ndGg7CiAgICAgIGxldCBuID0gMDsKICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHsKICAgICAgICBjb25zdCBiaXQgPSByZWFkQml0KCk7CiAgICAgICAgaWYgKGJpdCA9PT0gbnVsbCkgewogICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsKICAgICAgICB9CiAgICAgICAgbiA9IChuIDw8IDEpIHwgYml0OwogICAgICAgIC0tbGVuZ3RoOwogICAgICB9CiAgICAgIHJldHVybiBuOwogICAgfQogICAgZnVuY3Rpb24gcmVjZWl2ZUFuZEV4dGVuZChsZW5ndGgpIHsKICAgICAgY29uc3QgbiA9IHJlY2VpdmUobGVuZ3RoKTsKICAgICAgaWYgKG4gPj0gMSA8PCAobGVuZ3RoIC0gMSkpIHsKICAgICAgICByZXR1cm4gbjsKICAgICAgfQogICAgICByZXR1cm4gbiArICgtMSA8PCBsZW5ndGgpICsgMTsKICAgIH0KICAgIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgenopIHsKICAgICAgY29uc3QgdCA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDKTsKICAgICAgY29uc3QgZGlmZiA9IHQgPT09IDAgPyAwIDogcmVjZWl2ZUFuZEV4dGVuZCh0KTsKICAgICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjsKICAgICAgenpbMF0gPSBjb21wb25lbnQucHJlZDsKICAgICAgbGV0IGsgPSAxOwogICAgICB3aGlsZSAoayA8IDY0KSB7CiAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7CiAgICAgICAgY29uc3QgcyA9IHJzICYgMTU7CiAgICAgICAgY29uc3QgciA9IHJzID4+IDQ7CiAgICAgICAgaWYgKHMgPT09IDApIHsKICAgICAgICAgIGlmIChyIDwgMTUpIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBrICs9IDE2OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBrICs9IHI7CiAgICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdOwogICAgICAgICAgenpbel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpOwogICAgICAgICAgaysrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gZGVjb2RlRENGaXJzdChjb21wb25lbnQsIHp6KSB7CiAgICAgIGNvbnN0IHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7CiAgICAgIGNvbnN0IGRpZmYgPSB0ID09PSAwID8gMCA6IChyZWNlaXZlQW5kRXh0ZW5kKHQpIDw8IHN1Y2Nlc3NpdmUpOwogICAgICBjb21wb25lbnQucHJlZCArPSBkaWZmOwogICAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkOwogICAgfQogICAgZnVuY3Rpb24gZGVjb2RlRENTdWNjZXNzaXZlKGNvbXBvbmVudCwgenopIHsKICAgICAgenpbMF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7CiAgICB9CiAgICBsZXQgZW9icnVuID0gMDsKICAgIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCB6eikgewogICAgICBpZiAoZW9icnVuID4gMCkgewogICAgICAgIGVvYnJ1bi0tOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBsZXQgayA9IHNwZWN0cmFsU3RhcnQ7CiAgICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDsKICAgICAgd2hpbGUgKGsgPD0gZSkgewogICAgICAgIGNvbnN0IHJzID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlQUMpOwogICAgICAgIGNvbnN0IHMgPSBycyAmIDE1OwogICAgICAgIGNvbnN0IHIgPSBycyA+PiA0OwogICAgICAgIGlmIChzID09PSAwKSB7CiAgICAgICAgICBpZiAociA8IDE1KSB7CiAgICAgICAgICAgIGVvYnJ1biA9IHJlY2VpdmUocikgKyAoMSA8PCByKSAtIDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgayArPSAxNjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgayArPSByOwogICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTsKICAgICAgICAgIHp6W3pdID0gcmVjZWl2ZUFuZEV4dGVuZChzKSAqICgxIDw8IHN1Y2Nlc3NpdmUpOwogICAgICAgICAgaysrOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgbGV0IHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDsKICAgIGxldCBzdWNjZXNzaXZlQUNOZXh0VmFsdWU7CiAgICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikgewogICAgICBsZXQgayA9IHNwZWN0cmFsU3RhcnQ7CiAgICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDsKICAgICAgbGV0IHIgPSAwOwogICAgICB3aGlsZSAoayA8PSBlKSB7CiAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTsKICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB6elt6XSA8IDAgPyAtMSA6IDE7CiAgICAgICAgc3dpdGNoIChzdWNjZXNzaXZlQUNTdGF0ZSkgewogICAgICAgICAgY2FzZSAwOiB7IC8vIGluaXRpYWwgc3RhdGUKICAgICAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7CiAgICAgICAgICAgIGNvbnN0IHMgPSBycyAmIDE1OwogICAgICAgICAgICByID0gcnMgPj4gNDsKICAgICAgICAgICAgaWYgKHMgPT09IDApIHsKICAgICAgICAgICAgICBpZiAociA8IDE1KSB7CiAgICAgICAgICAgICAgICBlb2JydW4gPSByZWNlaXZlKHIpICsgKDEgPDwgcik7CiAgICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHIgPSAxNjsKICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgaWYgKHMgIT09IDEpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBBQ24gZW5jb2RpbmcnKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTsKICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IHIgPyAyIDogMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZQogICAgICAgICAgfQogICAgICAgICAgY2FzZSAxOiAvLyBza2lwcGluZyByIHplcm8gaXRlbXMKICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgaWYgKHp6W3pdKSB7CiAgICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByLS07CiAgICAgICAgICAgICAgaWYgKHIgPT09IDApIHsKICAgICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDIgPyAzIDogMDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDM6IC8vIHNldCB2YWx1ZSBmb3IgYSB6ZXJvIGl0ZW0KICAgICAgICAgICAgaWYgKHp6W3pdKSB7CiAgICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB6elt6XSA9IHN1Y2Nlc3NpdmVBQ05leHRWYWx1ZSA8PCBzdWNjZXNzaXZlOwogICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgNDogLy8gZW9iCiAgICAgICAgICAgIGlmICh6elt6XSkgewogICAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGsrKzsKICAgICAgfQogICAgICBpZiAoc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDQpIHsKICAgICAgICBlb2JydW4tLTsKICAgICAgICBpZiAoZW9icnVuID09PSAwKSB7CiAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGdW5jdGlvbiwgbWN1LCByb3csIGNvbCkgewogICAgICBjb25zdCBtY3VSb3cgPSAobWN1IC8gbWN1c1BlckxpbmUpIHwgMDsKICAgICAgY29uc3QgbWN1Q29sID0gbWN1ICUgbWN1c1BlckxpbmU7CiAgICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdVJvdyAqIGNvbXBvbmVudC52KSArIHJvdzsKICAgICAgY29uc3QgYmxvY2tDb2wgPSAobWN1Q29sICogY29tcG9uZW50LmgpICsgY29sOwogICAgICBkZWNvZGVGdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7CiAgICB9CiAgICBmdW5jdGlvbiBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZ1bmN0aW9uLCBtY3UpIHsKICAgICAgY29uc3QgYmxvY2tSb3cgPSAobWN1IC8gY29tcG9uZW50LmJsb2Nrc1BlckxpbmUpIHwgMDsKICAgICAgY29uc3QgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTsKICAgICAgZGVjb2RlRnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pOwogICAgfQoKICAgIGNvbnN0IGNvbXBvbmVudHNMZW5ndGggPSBjb21wb25lbnRzLmxlbmd0aDsKICAgIGxldCBjb21wb25lbnQ7CiAgICBsZXQgaTsKICAgIGxldCBqOwogICAgbGV0IGs7CiAgICBsZXQgbjsKICAgIGxldCBkZWNvZGVGbjsKICAgIGlmIChwcm9ncmVzc2l2ZSkgewogICAgICBpZiAoc3BlY3RyYWxTdGFydCA9PT0gMCkgewogICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVEQ0ZpcnN0IDogZGVjb2RlRENTdWNjZXNzaXZlOwogICAgICB9IGVsc2UgewogICAgICAgIGRlY29kZUZuID0gc3VjY2Vzc2l2ZVByZXYgPT09IDAgPyBkZWNvZGVBQ0ZpcnN0IDogZGVjb2RlQUNTdWNjZXNzaXZlOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBkZWNvZGVGbiA9IGRlY29kZUJhc2VsaW5lOwogICAgfQoKICAgIGxldCBtY3UgPSAwOwogICAgbGV0IG1hcmtlcjsKICAgIGxldCBtY3VFeHBlY3RlZDsKICAgIGlmIChjb21wb25lbnRzTGVuZ3RoID09PSAxKSB7CiAgICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47CiAgICB9IGVsc2UgewogICAgICBtY3VFeHBlY3RlZCA9IG1jdXNQZXJMaW5lICogZnJhbWUubWN1c1BlckNvbHVtbjsKICAgIH0KCiAgICBjb25zdCB1c2VkUmVzZXRJbnRlcnZhbCA9IHJlc2V0SW50ZXJ2YWwgfHwgbWN1RXhwZWN0ZWQ7CgogICAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7CiAgICAgIC8vIHJlc2V0IGludGVydmFsIHN0dWZmCiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHsKICAgICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwOwogICAgICB9CiAgICAgIGVvYnJ1biA9IDA7CgogICAgICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkgewogICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07CiAgICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHsKICAgICAgICAgIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRm4sIG1jdSk7CiAgICAgICAgICBtY3UrKzsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHsKICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wb25lbnRzTGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTsKICAgICAgICAgICAgY29uc3QgeyBoLCB2IH0gPSBjb21wb25lbnQ7CiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB2OyBqKyspIHsKICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaDsgaysrKSB7CiAgICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIG1jdSsrOwoKICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgb3VyIGV4cGVjdGVkIE1DVSdzLCBzdG9wIGRlY29kaW5nCiAgICAgICAgICBpZiAobWN1ID09PSBtY3VFeHBlY3RlZCkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIC8vIGZpbmQgbWFya2VyCiAgICAgIGJpdHNDb3VudCA9IDA7CiAgICAgIG1hcmtlciA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdOwogICAgICBpZiAobWFya2VyIDwgMHhGRjAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZXIgd2FzIG5vdCBmb3VuZCcpOwogICAgICB9CgogICAgICBpZiAobWFya2VyID49IDB4RkZEMCAmJiBtYXJrZXIgPD0gMHhGRkQ3KSB7IC8vIFJTVHgKICAgICAgICBvZmZzZXQgKz0gMjsKICAgICAgfSBlbHNlIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBvZmZzZXQgLSBzdGFydE9mZnNldDsKICB9CgogIGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSB7CiAgICBjb25zdCBsaW5lcyA9IFtdOwogICAgY29uc3QgeyBibG9ja3NQZXJMaW5lLCBibG9ja3NQZXJDb2x1bW4gfSA9IGNvbXBvbmVudDsKICAgIGNvbnN0IHNhbXBsZXNQZXJMaW5lID0gYmxvY2tzUGVyTGluZSA8PCAzOwogICAgY29uc3QgUiA9IG5ldyBJbnQzMkFycmF5KDY0KTsKICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheSg2NCk7CgogICAgLy8gQSBwb3J0IG9mIHBvcHBsZXIncyBJRENUIG1ldGhvZCB3aGljaCBpbiB0dXJuIGlzIHRha2VuIGZyb206CiAgICAvLyAgIENocmlzdG9waCBMb2VmZmxlciwgQWRyaWFhbiBMaWd0ZW5iZXJnLCBHZW9yZ2UgUy4gTW9zY2h5dHosCiAgICAvLyAgICJQcmFjdGljYWwgRmFzdCAxLUQgRENUIEFsZ29yaXRobXMgd2l0aCAxMSBNdWx0aXBsaWNhdGlvbnMiLAogICAgLy8gICBJRUVFIEludGwuIENvbmYuIG9uIEFjb3VzdGljcywgU3BlZWNoICYgU2lnbmFsIFByb2Nlc3NpbmcsIDE5ODksCiAgICAvLyAgIDk4OC05OTEuCiAgICBmdW5jdGlvbiBxdWFudGl6ZUFuZEludmVyc2UoenosIGRhdGFPdXQsIGRhdGFJbikgewogICAgICBjb25zdCBxdCA9IGNvbXBvbmVudC5xdWFudGl6YXRpb25UYWJsZTsKICAgICAgbGV0IHYwOwogICAgICBsZXQgdjE7CiAgICAgIGxldCB2MjsKICAgICAgbGV0IHYzOwogICAgICBsZXQgdjQ7CiAgICAgIGxldCB2NTsKICAgICAgbGV0IHY2OwogICAgICBsZXQgdjc7CiAgICAgIGxldCB0OwogICAgICBjb25zdCBwID0gZGF0YUluOwogICAgICBsZXQgaTsKCiAgICAgIC8vIGRlcXVhbnQKICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHsKICAgICAgICBwW2ldID0genpbaV0gKiBxdFtpXTsKICAgICAgfQoKICAgICAgLy8gaW52ZXJzZSBEQ1Qgb24gcm93cwogICAgICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7CiAgICAgICAgY29uc3Qgcm93ID0gOCAqIGk7CgogICAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHMKICAgICAgICBpZiAocFsxICsgcm93XSA9PT0gMCAmJiBwWzIgKyByb3ddID09PSAwICYmIHBbMyArIHJvd10gPT09IDAKICAgICAgICAgICYmIHBbNCArIHJvd10gPT09IDAgJiYgcFs1ICsgcm93XSA9PT0gMCAmJiBwWzYgKyByb3ddID09PSAwCiAgICAgICAgICAmJiBwWzcgKyByb3ddID09PSAwKSB7CiAgICAgICAgICB0ID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgNTEyKSA+PiAxMDsKICAgICAgICAgIHBbMCArIHJvd10gPSB0OwogICAgICAgICAgcFsxICsgcm93XSA9IHQ7CiAgICAgICAgICBwWzIgKyByb3ddID0gdDsKICAgICAgICAgIHBbMyArIHJvd10gPSB0OwogICAgICAgICAgcFs0ICsgcm93XSA9IHQ7CiAgICAgICAgICBwWzUgKyByb3ddID0gdDsKICAgICAgICAgIHBbNiArIHJvd10gPSB0OwogICAgICAgICAgcFs3ICsgcm93XSA9IHQ7CiAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZQogICAgICAgIH0KCiAgICAgICAgLy8gc3RhZ2UgNAogICAgICAgIHYwID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgMTI4KSA+PiA4OwogICAgICAgIHYxID0gKChkY3RTcXJ0MiAqIHBbNCArIHJvd10pICsgMTI4KSA+PiA4OwogICAgICAgIHYyID0gcFsyICsgcm93XTsKICAgICAgICB2MyA9IHBbNiArIHJvd107CiAgICAgICAgdjQgPSAoKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSAtIHBbNyArIHJvd10pKSArIDEyOCkgPj4gODsKICAgICAgICB2NyA9ICgoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddICsgcFs3ICsgcm93XSkpICsgMTI4KSA+PiA4OwogICAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0OwogICAgICAgIHY2ID0gcFs1ICsgcm93XSA8PCA0OwoKICAgICAgICAvLyBzdGFnZSAzCiAgICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTsKICAgICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTsKICAgICAgICB2MSA9IHQ7CiAgICAgICAgdCA9ICgodjIgKiBkY3RTaW42KSArICh2MyAqIGRjdENvczYpICsgMTI4KSA+PiA4OwogICAgICAgIHYyID0gKCh2MiAqIGRjdENvczYpIC0gKHYzICogZGN0U2luNikgKyAxMjgpID4+IDg7CiAgICAgICAgdjMgPSB0OwogICAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7CiAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7CiAgICAgICAgdjYgPSB0OwogICAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7CiAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7CiAgICAgICAgdjcgPSB0OwoKICAgICAgICAvLyBzdGFnZSAyCiAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTsKICAgICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTsKICAgICAgICB2MyA9IHQ7CiAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTsKICAgICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTsKICAgICAgICB2MiA9IHQ7CiAgICAgICAgdCA9ICgodjQgKiBkY3RTaW4zKSArICh2NyAqIGRjdENvczMpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyOwogICAgICAgIHY3ID0gdDsKICAgICAgICB0ID0gKCh2NSAqIGRjdFNpbjEpICsgKHY2ICogZGN0Q29zMSkgKyAyMDQ4KSA+PiAxMjsKICAgICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjYgPSB0OwoKICAgICAgICAvLyBzdGFnZSAxCiAgICAgICAgcFswICsgcm93XSA9IHYwICsgdjc7CiAgICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7CiAgICAgICAgcFsxICsgcm93XSA9IHYxICsgdjY7CiAgICAgICAgcFs2ICsgcm93XSA9IHYxIC0gdjY7CiAgICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7CiAgICAgICAgcFs1ICsgcm93XSA9IHYyIC0gdjU7CiAgICAgICAgcFszICsgcm93XSA9IHYzICsgdjQ7CiAgICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7CiAgICAgIH0KCiAgICAgIC8vIGludmVyc2UgRENUIG9uIGNvbHVtbnMKICAgICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkgewogICAgICAgIGNvbnN0IGNvbCA9IGk7CgogICAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHMKICAgICAgICBpZiAocFsoMSAqIDgpICsgY29sXSA9PT0gMCAmJiBwWygyICogOCkgKyBjb2xdID09PSAwICYmIHBbKDMgKiA4KSArIGNvbF0gPT09IDAKICAgICAgICAgICYmIHBbKDQgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoNSAqIDgpICsgY29sXSA9PT0gMCAmJiBwWyg2ICogOCkgKyBjb2xdID09PSAwCiAgICAgICAgICAmJiBwWyg3ICogOCkgKyBjb2xdID09PSAwKSB7CiAgICAgICAgICB0ID0gKChkY3RTcXJ0MiAqIGRhdGFJbltpICsgMF0pICsgODE5MikgPj4gMTQ7CiAgICAgICAgICBwWygwICogOCkgKyBjb2xdID0gdDsKICAgICAgICAgIHBbKDEgKiA4KSArIGNvbF0gPSB0OwogICAgICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHQ7CiAgICAgICAgICBwWygzICogOCkgKyBjb2xdID0gdDsKICAgICAgICAgIHBbKDQgKiA4KSArIGNvbF0gPSB0OwogICAgICAgICAgcFsoNSAqIDgpICsgY29sXSA9IHQ7CiAgICAgICAgICBwWyg2ICogOCkgKyBjb2xdID0gdDsKICAgICAgICAgIHBbKDcgKiA4KSArIGNvbF0gPSB0OwogICAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWUKICAgICAgICB9CgogICAgICAgIC8vIHN0YWdlIDQKICAgICAgICB2MCA9ICgoZGN0U3FydDIgKiBwWygwICogOCkgKyBjb2xdKSArIDIwNDgpID4+IDEyOwogICAgICAgIHYxID0gKChkY3RTcXJ0MiAqIHBbKDQgKiA4KSArIGNvbF0pICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjIgPSBwWygyICogOCkgKyBjb2xdOwogICAgICAgIHYzID0gcFsoNiAqIDgpICsgY29sXTsKICAgICAgICB2NCA9ICgoZGN0U3FydDFkMiAqIChwWygxICogOCkgKyBjb2xdIC0gcFsoNyAqIDgpICsgY29sXSkpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjcgPSAoKGRjdFNxcnQxZDIgKiAocFsoMSAqIDgpICsgY29sXSArIHBbKDcgKiA4KSArIGNvbF0pKSArIDIwNDgpID4+IDEyOwogICAgICAgIHY1ID0gcFsoMyAqIDgpICsgY29sXTsKICAgICAgICB2NiA9IHBbKDUgKiA4KSArIGNvbF07CgogICAgICAgIC8vIHN0YWdlIDMKICAgICAgICB0ID0gKHYwIC0gdjEgKyAxKSA+PiAxOwogICAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxOwogICAgICAgIHYxID0gdDsKICAgICAgICB0ID0gKCh2MiAqIGRjdFNpbjYpICsgKHYzICogZGN0Q29zNikgKyAyMDQ4KSA+PiAxMjsKICAgICAgICB2MiA9ICgodjIgKiBkY3RDb3M2KSAtICh2MyAqIGRjdFNpbjYpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjMgPSB0OwogICAgICAgIHQgPSAodjQgLSB2NiArIDEpID4+IDE7CiAgICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7CiAgICAgICAgdjYgPSB0OwogICAgICAgIHQgPSAodjcgKyB2NSArIDEpID4+IDE7CiAgICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7CiAgICAgICAgdjcgPSB0OwoKICAgICAgICAvLyBzdGFnZSAyCiAgICAgICAgdCA9ICh2MCAtIHYzICsgMSkgPj4gMTsKICAgICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTsKICAgICAgICB2MyA9IHQ7CiAgICAgICAgdCA9ICh2MSAtIHYyICsgMSkgPj4gMTsKICAgICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTsKICAgICAgICB2MiA9IHQ7CiAgICAgICAgdCA9ICgodjQgKiBkY3RTaW4zKSArICh2NyAqIGRjdENvczMpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyOwogICAgICAgIHY3ID0gdDsKICAgICAgICB0ID0gKCh2NSAqIGRjdFNpbjEpICsgKHY2ICogZGN0Q29zMSkgKyAyMDQ4KSA+PiAxMjsKICAgICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7CiAgICAgICAgdjYgPSB0OwoKICAgICAgICAvLyBzdGFnZSAxCiAgICAgICAgcFsoMCAqIDgpICsgY29sXSA9IHYwICsgdjc7CiAgICAgICAgcFsoNyAqIDgpICsgY29sXSA9IHYwIC0gdjc7CiAgICAgICAgcFsoMSAqIDgpICsgY29sXSA9IHYxICsgdjY7CiAgICAgICAgcFsoNiAqIDgpICsgY29sXSA9IHYxIC0gdjY7CiAgICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHYyICsgdjU7CiAgICAgICAgcFsoNSAqIDgpICsgY29sXSA9IHYyIC0gdjU7CiAgICAgICAgcFsoMyAqIDgpICsgY29sXSA9IHYzICsgdjQ7CiAgICAgICAgcFsoNCAqIDgpICsgY29sXSA9IHYzIC0gdjQ7CiAgICAgIH0KCiAgICAgIC8vIGNvbnZlcnQgdG8gOC1iaXQgaW50ZWdlcnMKICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHsKICAgICAgICBjb25zdCBzYW1wbGUgPSAxMjggKyAoKHBbaV0gKyA4KSA+PiA0KTsKICAgICAgICBpZiAoc2FtcGxlIDwgMCkgewogICAgICAgICAgZGF0YU91dFtpXSA9IDA7CiAgICAgICAgfSBlbHNlIGlmIChzYW1wbGUgPiAwWEZGKSB7CiAgICAgICAgICBkYXRhT3V0W2ldID0gMHhGRjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZGF0YU91dFtpXSA9IHNhbXBsZTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICBmb3IgKGxldCBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7CiAgICAgIGNvbnN0IHNjYW5MaW5lID0gYmxvY2tSb3cgPDwgMzsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHsKICAgICAgICBsaW5lcy5wdXNoKG5ldyBVaW50OEFycmF5KHNhbXBsZXNQZXJMaW5lKSk7CiAgICAgIH0KICAgICAgZm9yIChsZXQgYmxvY2tDb2wgPSAwOyBibG9ja0NvbCA8IGJsb2Nrc1BlckxpbmU7IGJsb2NrQ29sKyspIHsKICAgICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdLCByLCBSKTsKCiAgICAgICAgbGV0IG9mZnNldCA9IDA7CiAgICAgICAgY29uc3Qgc2FtcGxlID0gYmxvY2tDb2wgPDwgMzsKICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDg7IGorKykgewogICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3NjYW5MaW5lICsgal07CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykgewogICAgICAgICAgICBsaW5lW3NhbXBsZSArIGldID0gcltvZmZzZXQrK107CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gbGluZXM7CiAgfQoKICBjbGFzcyBKcGVnU3RyZWFtUmVhZGVyIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLmpmaWYgPSBudWxsOwogICAgICB0aGlzLmFkb2JlID0gbnVsbDsKCiAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzID0gW107CiAgICAgIHRoaXMuaHVmZm1hblRhYmxlc0FDID0gW107CiAgICAgIHRoaXMuaHVmZm1hblRhYmxlc0RDID0gW107CiAgICAgIHRoaXMucmVzZXRGcmFtZXMoKTsKICAgIH0KCiAgICByZXNldEZyYW1lcygpIHsKICAgICAgdGhpcy5mcmFtZXMgPSBbXTsKICAgIH0KCiAgICBwYXJzZShkYXRhKSB7CiAgICAgIGxldCBvZmZzZXQgPSAwOwogICAgICAvLyBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTsKICAgICAgZnVuY3Rpb24gcmVhZFVpbnQxNigpIHsKICAgICAgICBjb25zdCB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdOwogICAgICAgIG9mZnNldCArPSAyOwogICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgfQogICAgICBmdW5jdGlvbiByZWFkRGF0YUJsb2NrKCkgewogICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRVaW50MTYoKTsKICAgICAgICBjb25zdCBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGggLSAyKTsKICAgICAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoOwogICAgICAgIHJldHVybiBhcnJheTsKICAgICAgfQogICAgICBmdW5jdGlvbiBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSkgewogICAgICAgIGxldCBtYXhIID0gMDsKICAgICAgICBsZXQgbWF4ViA9IDA7CiAgICAgICAgbGV0IGNvbXBvbmVudDsKICAgICAgICBsZXQgY29tcG9uZW50SWQ7CiAgICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7CiAgICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHsKICAgICAgICAgICAgY29tcG9uZW50ID0gZnJhbWUuY29tcG9uZW50c1tjb21wb25lbnRJZF07CiAgICAgICAgICAgIGlmIChtYXhIIDwgY29tcG9uZW50LmgpIHsKICAgICAgICAgICAgICBtYXhIID0gY29tcG9uZW50Lmg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKG1heFYgPCBjb21wb25lbnQudikgewogICAgICAgICAgICAgIG1heFYgPSBjb21wb25lbnQudjsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zdCBtY3VzUGVyTGluZSA9IE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDggLyBtYXhIKTsKICAgICAgICBjb25zdCBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBtYXhWKTsKICAgICAgICBmb3IgKGNvbXBvbmVudElkIGluIGZyYW1lLmNvbXBvbmVudHMpIHsKICAgICAgICAgIGlmIChmcmFtZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudElkKSkgewogICAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTsKICAgICAgICAgICAgY29uc3QgYmxvY2tzUGVyTGluZSA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4KSAqIGNvbXBvbmVudC5oIC8gbWF4SCk7CiAgICAgICAgICAgIGNvbnN0IGJsb2Nrc1BlckNvbHVtbiA9IE1hdGguY2VpbChNYXRoLmNlaWwoZnJhbWUuc2NhbkxpbmVzIC8gOCkgKiBjb21wb25lbnQudiAvIG1heFYpOwogICAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lRm9yTWN1ID0gbWN1c1BlckxpbmUgKiBjb21wb25lbnQuaDsKICAgICAgICAgICAgY29uc3QgYmxvY2tzUGVyQ29sdW1uRm9yTWN1ID0gbWN1c1BlckNvbHVtbiAqIGNvbXBvbmVudC52OwogICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NQZXJDb2x1bW5Gb3JNY3U7IGkrKykgewogICAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdOwogICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2tzUGVyTGluZUZvck1jdTsgaisrKSB7CiAgICAgICAgICAgICAgICByb3cucHVzaChuZXcgSW50MzJBcnJheSg2NCkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBibG9ja3MucHVzaChyb3cpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lID0gYmxvY2tzUGVyTGluZTsKICAgICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckNvbHVtbiA9IGJsb2Nrc1BlckNvbHVtbjsKICAgICAgICAgICAgY29tcG9uZW50LmJsb2NrcyA9IGJsb2NrczsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnJhbWUubWF4SCA9IG1heEg7CiAgICAgICAgZnJhbWUubWF4ViA9IG1heFY7CiAgICAgICAgZnJhbWUubWN1c1BlckxpbmUgPSBtY3VzUGVyTGluZTsKICAgICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjsKICAgICAgfQoKICAgICAgbGV0IGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7CiAgICAgIGlmIChmaWxlTWFya2VyICE9PSAweEZGRDgpIHsgLy8gU09JIChTdGFydCBvZiBJbWFnZSkKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NPSSBub3QgZm91bmQnKTsKICAgICAgfQoKICAgICAgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTsKICAgICAgd2hpbGUgKGZpbGVNYXJrZXIgIT09IDB4RkZEOSkgeyAvLyBFT0kgKEVuZCBvZiBpbWFnZSkKICAgICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHsKICAgICAgICAgIGNhc2UgMHhGRjAwOiBicmVhazsKICAgICAgICAgIGNhc2UgMHhGRkUwOiAvLyBBUFAwIChBcHBsaWNhdGlvbiBTcGVjaWZpYykKICAgICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxCiAgICAgICAgICBjYXNlIDB4RkZFMjogLy8gQVBQMgogICAgICAgICAgY2FzZSAweEZGRTM6IC8vIEFQUDMKICAgICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0CiAgICAgICAgICBjYXNlIDB4RkZFNTogLy8gQVBQNQogICAgICAgICAgY2FzZSAweEZGRTY6IC8vIEFQUDYKICAgICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3CiAgICAgICAgICBjYXNlIDB4RkZFODogLy8gQVBQOAogICAgICAgICAgY2FzZSAweEZGRTk6IC8vIEFQUDkKICAgICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMAogICAgICAgICAgY2FzZSAweEZGRUI6IC8vIEFQUDExCiAgICAgICAgICBjYXNlIDB4RkZFQzogLy8gQVBQMTIKICAgICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxMwogICAgICAgICAgY2FzZSAweEZGRUU6IC8vIEFQUDE0CiAgICAgICAgICBjYXNlIDB4RkZFRjogLy8gQVBQMTUKICAgICAgICAgIGNhc2UgMHhGRkZFOiB7IC8vIENPTSAoQ29tbWVudCkKICAgICAgICAgICAgY29uc3QgYXBwRGF0YSA9IHJlYWREYXRhQmxvY2soKTsKCiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRTApIHsKICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0QSAmJiBhcHBEYXRhWzFdID09PSAweDQ2ICYmIGFwcERhdGFbMl0gPT09IDB4NDkKICAgICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NDYgJiYgYXBwRGF0YVs0XSA9PT0gMCkgeyAvLyAnSkZJRlx4MDAnCiAgICAgICAgICAgICAgICB0aGlzLmpmaWYgPSB7CiAgICAgICAgICAgICAgICAgIHZlcnNpb246IHsgbWFqb3I6IGFwcERhdGFbNV0sIG1pbm9yOiBhcHBEYXRhWzZdIH0sCiAgICAgICAgICAgICAgICAgIGRlbnNpdHlVbml0czogYXBwRGF0YVs3XSwKICAgICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSwKICAgICAgICAgICAgICAgICAgeURlbnNpdHk6IChhcHBEYXRhWzEwXSA8PCA4KSB8IGFwcERhdGFbMTFdLAogICAgICAgICAgICAgICAgICB0aHVtYldpZHRoOiBhcHBEYXRhWzEyXSwKICAgICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLAogICAgICAgICAgICAgICAgICB0aHVtYkRhdGE6IGFwcERhdGEuc3ViYXJyYXkoMTQsIDE0ICsgKDMgKiBhcHBEYXRhWzEyXSAqIGFwcERhdGFbMTNdKSksCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBUT0RPIEFQUDEgLSBFeGlmCiAgICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHsKICAgICAgICAgICAgICBpZiAoYXBwRGF0YVswXSA9PT0gMHg0MSAmJiBhcHBEYXRhWzFdID09PSAweDY0ICYmIGFwcERhdGFbMl0gPT09IDB4NkYKICAgICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NjIgJiYgYXBwRGF0YVs0XSA9PT0gMHg2NSAmJiBhcHBEYXRhWzVdID09PSAwKSB7IC8vICdBZG9iZVx4MDAnCiAgICAgICAgICAgICAgICB0aGlzLmFkb2JlID0gewogICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLAogICAgICAgICAgICAgICAgICBmbGFnczA6IChhcHBEYXRhWzddIDw8IDgpIHwgYXBwRGF0YVs4XSwKICAgICAgICAgICAgICAgICAgZmxhZ3MxOiAoYXBwRGF0YVs5XSA8PCA4KSB8IGFwcERhdGFbMTBdLAogICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSwKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGNhc2UgMHhGRkRCOiB7IC8vIERRVCAoRGVmaW5lIFF1YW50aXphdGlvbiBUYWJsZXMpCiAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCA9IHJlYWRVaW50MTYoKTsKICAgICAgICAgICAgY29uc3QgcXVhbnRpemF0aW9uVGFibGVzRW5kID0gcXVhbnRpemF0aW9uVGFibGVzTGVuZ3RoICsgb2Zmc2V0IC0gMjsKICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHF1YW50aXphdGlvblRhYmxlc0VuZCkgewogICAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdOwogICAgICAgICAgICAgIGNvbnN0IHRhYmxlRGF0YSA9IG5ldyBJbnQzMkFycmF5KDY0KTsKICAgICAgICAgICAgICBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMCkgeyAvLyA4IGJpdCB2YWx1ZXMKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQ7IGorKykgewogICAgICAgICAgICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2pdOwogICAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGVsc2UgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDEpIHsgLy8gMTYgYml0CiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY0OyBqKyspIHsKICAgICAgICAgICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1tqXTsKICAgICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gcmVhZFVpbnQxNigpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RRVDogaW52YWxpZCB0YWJsZSBzcGVjJyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzW3F1YW50aXphdGlvblRhYmxlU3BlYyAmIDE1XSA9IHRhYmxlRGF0YTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVCkKICAgICAgICAgIGNhc2UgMHhGRkMxOiAvLyBTT0YxIChTdGFydCBvZiBGcmFtZSwgRXh0ZW5kZWQgRENUKQogICAgICAgICAgY2FzZSAweEZGQzI6IHsgLy8gU09GMiAoU3RhcnQgb2YgRnJhbWUsIFByb2dyZXNzaXZlIERDVCkKICAgICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoCiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gewogICAgICAgICAgICAgIGV4dGVuZGVkOiAoZmlsZU1hcmtlciA9PT0gMHhGRkMxKSwKICAgICAgICAgICAgICBwcm9ncmVzc2l2ZTogKGZpbGVNYXJrZXIgPT09IDB4RkZDMiksCiAgICAgICAgICAgICAgcHJlY2lzaW9uOiBkYXRhW29mZnNldCsrXSwKICAgICAgICAgICAgICBzY2FuTGluZXM6IHJlYWRVaW50MTYoKSwKICAgICAgICAgICAgICBzYW1wbGVzUGVyTGluZTogcmVhZFVpbnQxNigpLAogICAgICAgICAgICAgIGNvbXBvbmVudHM6IHt9LAogICAgICAgICAgICAgIGNvbXBvbmVudHNPcmRlcjogW10sCiAgICAgICAgICAgIH07CgogICAgICAgICAgICBjb25zdCBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgbGV0IGNvbXBvbmVudElkOwogICAgICAgICAgICAvLyBsZXQgbWF4SCA9IDA7CiAgICAgICAgICAgIC8vIGxldCBtYXhWID0gMDsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzQ291bnQ7IGkrKykgewogICAgICAgICAgICAgIGNvbXBvbmVudElkID0gZGF0YVtvZmZzZXRdOwogICAgICAgICAgICAgIGNvbnN0IGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7CiAgICAgICAgICAgICAgY29uc3QgdiA9IGRhdGFbb2Zmc2V0ICsgMV0gJiAxNTsKICAgICAgICAgICAgICBjb25zdCBxSWQgPSBkYXRhW29mZnNldCArIDJdOwogICAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlci5wdXNoKGNvbXBvbmVudElkKTsKICAgICAgICAgICAgICBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXSA9IHsKICAgICAgICAgICAgICAgIGgsCiAgICAgICAgICAgICAgICB2LAogICAgICAgICAgICAgICAgcXVhbnRpemF0aW9uSWR4OiBxSWQsCiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBvZmZzZXQgKz0gMzsKICAgICAgICAgICAgfQogICAgICAgICAgICBwcmVwYXJlQ29tcG9uZW50cyhmcmFtZSk7CiAgICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZnJhbWUpOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBjYXNlIDB4RkZDNDogeyAvLyBESFQgKERlZmluZSBIdWZmbWFuIFRhYmxlcykKICAgICAgICAgICAgY29uc3QgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBodWZmbWFuTGVuZ3RoOykgewogICAgICAgICAgICAgIGNvbnN0IGh1ZmZtYW5UYWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgICBjb25zdCBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTsKICAgICAgICAgICAgICBsZXQgY29kZUxlbmd0aFN1bSA9IDA7CiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgaisrLCBvZmZzZXQrKykgewogICAgICAgICAgICAgICAgY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF07CiAgICAgICAgICAgICAgICBjb2RlTGVuZ3RoU3VtICs9IGNvZGVMZW5ndGhzW2pdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjb25zdCBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7CiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2RlTGVuZ3RoU3VtOyBqKyssIG9mZnNldCsrKSB7CiAgICAgICAgICAgICAgICBodWZmbWFuVmFsdWVzW2pdID0gZGF0YVtvZmZzZXRdOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpICs9IDE3ICsgY29kZUxlbmd0aFN1bTsKCiAgICAgICAgICAgICAgaWYgKChodWZmbWFuVGFibGVTcGVjID4+IDQpID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aGlzLmh1ZmZtYW5UYWJsZXNEQ1todWZmbWFuVGFibGVTcGVjICYgMTVdID0gYnVpbGRIdWZmbWFuVGFibGUoCiAgICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLAogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzQUNbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKAogICAgICAgICAgICAgICAgICBjb2RlTGVuZ3RocywgaHVmZm1hblZhbHVlcywKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGNhc2UgMHhGRkREOiAvLyBEUkkgKERlZmluZSBSZXN0YXJ0IEludGVydmFsKQogICAgICAgICAgICByZWFkVWludDE2KCk7IC8vIHNraXAgZGF0YSBsZW5ndGgKICAgICAgICAgICAgdGhpcy5yZXNldEludGVydmFsID0gcmVhZFVpbnQxNigpOwogICAgICAgICAgICBicmVhazsKCiAgICAgICAgICBjYXNlIDB4RkZEQTogeyAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pCiAgICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBsZW5ndGgKICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JzQ291bnQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtdOwogICAgICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuZnJhbWVzWzBdOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9yc0NvdW50OyBpKyspIHsKICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2RhdGFbb2Zmc2V0KytdXTsKICAgICAgICAgICAgICBjb25zdCB0YWJsZVNwZWMgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgICBjb21wb25lbnQuaHVmZm1hblRhYmxlREMgPSB0aGlzLmh1ZmZtYW5UYWJsZXNEQ1t0YWJsZVNwZWMgPj4gNF07CiAgICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gdGhpcy5odWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdOwogICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3Qgc3BlY3RyYWxFbmQgPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2l2ZUFwcHJveGltYXRpb24gPSBkYXRhW29mZnNldCsrXTsKICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsCiAgICAgICAgICAgICAgZnJhbWUsIGNvbXBvbmVudHMsIHRoaXMucmVzZXRJbnRlcnZhbCwKICAgICAgICAgICAgICBzcGVjdHJhbFN0YXJ0LCBzcGVjdHJhbEVuZCwKICAgICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTsKICAgICAgICAgICAgb2Zmc2V0ICs9IHByb2Nlc3NlZDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgY2FzZSAweEZGRkY6IC8vIEZpbGwgYnl0ZXMKICAgICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0XSAhPT0gMHhGRikgeyAvLyBBdm9pZCBza2lwcGluZyBhIHZhbGlkIG1hcmtlci4KICAgICAgICAgICAgICBvZmZzZXQtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBicmVhazsKCiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICBpZiAoZGF0YVtvZmZzZXQgLSAzXSA9PT0gMHhGRgogICAgICAgICAgICAgICYmIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHsKICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBpbmNvcnJlY3QgZW5jb2RpbmcgLS0gbGFzdCAweEZGIGJ5dGUgb2YgdGhlIHByZXZpb3VzCiAgICAgICAgICAgICAgLy8gYmxvY2sgd2FzIGVhdGVuIGJ5IHRoZSBlbmNvZGVyCiAgICAgICAgICAgICAgb2Zmc2V0IC09IDM7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIEpQRUcgbWFya2VyICR7ZmlsZU1hcmtlci50b1N0cmluZygxNil9YCk7CiAgICAgICAgfQogICAgICAgIGZpbGVNYXJrZXIgPSByZWFkVWludDE2KCk7CiAgICAgIH0KICAgIH0KCiAgICBnZXRSZXN1bHQoKSB7CiAgICAgIGNvbnN0IHsgZnJhbWVzIH0gPSB0aGlzOwogICAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBmcmFtZXMgd2VyZSBkZWNvZGVkJyk7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID4gMSkgewogICAgICAgIGNvbnNvbGUud2FybignbW9yZSB0aGFuIG9uZSBmcmFtZSBpcyBub3Qgc3VwcG9ydGVkJyk7CiAgICAgIH0KCiAgICAgIC8vIHNldCBlYWNoIGZyYW1lJ3MgY29tcG9uZW50cyBxdWFudGl6YXRpb24gdGFibGUKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZyYW1lcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGNwID0gdGhpcy5mcmFtZXNbaV0uY29tcG9uZW50czsKICAgICAgICBmb3IgKGNvbnN0IGogb2YgT2JqZWN0LmtleXMoY3ApKSB7CiAgICAgICAgICBjcFtqXS5xdWFudGl6YXRpb25UYWJsZSA9IHRoaXMucXVhbnRpemF0aW9uVGFibGVzW2NwW2pdLnF1YW50aXphdGlvbklkeF07CiAgICAgICAgICBkZWxldGUgY3Bbal0ucXVhbnRpemF0aW9uSWR4OwogICAgICAgIH0KICAgICAgfQoKICAgICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbMF07CiAgICAgIGNvbnN0IHsgY29tcG9uZW50cywgY29tcG9uZW50c09yZGVyIH0gPSBmcmFtZTsKICAgICAgY29uc3Qgb3V0Q29tcG9uZW50cyA9IFtdOwogICAgICBjb25zdCB3aWR0aCA9IGZyYW1lLnNhbXBsZXNQZXJMaW5lOwogICAgICBjb25zdCBoZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNPcmRlci5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50c09yZGVyW2ldXTsKICAgICAgICBvdXRDb21wb25lbnRzLnB1c2goewogICAgICAgICAgbGluZXM6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSwKICAgICAgICAgIHNjYWxlWDogY29tcG9uZW50LmggLyBmcmFtZS5tYXhILAogICAgICAgICAgc2NhbGVZOiBjb21wb25lbnQudiAvIGZyYW1lLm1heFYsCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogb3V0Q29tcG9uZW50cy5sZW5ndGgpOwogICAgICBsZXQgb2kgPSAwOwogICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7CiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dENvbXBvbmVudHMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gb3V0Q29tcG9uZW50c1tpXTsKICAgICAgICAgICAgb3V0W29pXSA9IGNvbXBvbmVudC5saW5lc1swIHwgeSAqIGNvbXBvbmVudC5zY2FsZVldWzAgfCB4ICogY29tcG9uZW50LnNjYWxlWF07CiAgICAgICAgICAgICsrb2k7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBvdXQ7CiAgICB9CiAgfQoKICBjbGFzcyBKcGVnRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHsKICAgIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHsKICAgICAgc3VwZXIoKTsKICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgSnBlZ1N0cmVhbVJlYWRlcigpOwogICAgICBpZiAoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKSB7CiAgICAgICAgdGhpcy5yZWFkZXIucGFyc2UoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKTsKICAgICAgfQogICAgfQoKICAgIGRlY29kZUJsb2NrKGJ1ZmZlcikgewogICAgICB0aGlzLnJlYWRlci5yZXNldEZyYW1lcygpOwogICAgICB0aGlzLnJlYWRlci5wYXJzZShuZXcgVWludDhBcnJheShidWZmZXIpKTsKICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmdldFJlc3VsdCgpLmJ1ZmZlcjsKICAgIH0KICB9CgogIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBiYXNlZGlyLCBtb2R1bGUpIHsKICAJcmV0dXJuIG1vZHVsZSA9IHsKICAJCXBhdGg6IGJhc2VkaXIsCiAgCQlleHBvcnRzOiB7fSwKICAJCXJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7CiAgCQkJcmV0dXJuIGNvbW1vbmpzUmVxdWlyZShwYXRoLCAoYmFzZSA9PT0gdW5kZWZpbmVkIHx8IGJhc2UgPT09IG51bGwpID8gbW9kdWxlLnBhdGggOiBiYXNlKTsKICAJCX0KICAJfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzOwogIH0KCiAgZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHsKICAJdGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qcycpOwogIH0KCiAgdmFyIGNvbW1vbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHsKCgogIHZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJgogICAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYKICAgICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7CgogIGZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHsKICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpOwogIH0KCiAgZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHsKICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkgewogICAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpOwogICAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfQoKICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7CiAgICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkgewogICAgICAgICAgb2JqW3BdID0gc291cmNlW3BdOwogICAgICAgIH0KICAgICAgfQogICAgfQoKICAgIHJldHVybiBvYmo7CiAgfTsKCgogIC8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHkKICBleHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHsKICAgIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH0KICAgIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfQogICAgYnVmLmxlbmd0aCA9IHNpemU7CiAgICByZXR1cm4gYnVmOwogIH07CgoKICB2YXIgZm5UeXBlZCA9IHsKICAgIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHsKICAgICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7CiAgICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07CiAgICAgIH0KICAgIH0sCiAgICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuCiAgICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7CiAgICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDsKCiAgICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aAogICAgICBsZW4gPSAwOwogICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoOwogICAgICB9CgogICAgICAvLyBqb2luIGNodW5rcwogICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pOwogICAgICBwb3MgPSAwOwogICAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgIGNodW5rID0gY2h1bmtzW2ldOwogICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7CiAgICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICB9OwoKICB2YXIgZm5VbnR5cGVkID0gewogICAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2ZmcykgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldOwogICAgICB9CiAgICB9LAogICAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LgogICAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykgewogICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpOwogICAgfQogIH07CgoKICAvLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZwogIC8vCiAgZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikgewogICAgaWYgKG9uKSB7CiAgICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5OwogICAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7CiAgICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5OwogICAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTsKICAgIH0gZWxzZSB7CiAgICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTsKICAgICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5OwogICAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7CiAgICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7CiAgICB9CiAgfTsKCiAgZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7CiAgfSk7CgogIC8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi4KICAvLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC4KICAvLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuCgogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICBmdW5jdGlvbiBhZGxlcjMyKGFkbGVyLCBidWYsIGxlbiwgcG9zKSB7CiAgICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLAogICAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCwKICAgICAgICBuID0gMDsKCiAgICB3aGlsZSAobGVuICE9PSAwKSB7CiAgICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwCiAgICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuCiAgICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLgogICAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47CiAgICAgIGxlbiAtPSBuOwoKICAgICAgZG8gewogICAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7CiAgICAgICAgczIgPSAoczIgKyBzMSkgfDA7CiAgICAgIH0gd2hpbGUgKC0tbik7CgogICAgICBzMSAlPSA2NTUyMTsKICAgICAgczIgJT0gNjU1MjE7CiAgICB9CgogICAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwOwogIH0KCgogIHZhciBhZGxlcjMyXzEgPSBhZGxlcjMyOwoKICAvLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS4KICAvLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzCiAgLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy4KCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgogIC8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlCiAgZnVuY3Rpb24gbWFrZVRhYmxlKCkgewogICAgdmFyIGMsIHRhYmxlID0gW107CgogICAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykgewogICAgICBjID0gbjsKICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHsKICAgICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpOwogICAgICB9CiAgICAgIHRhYmxlW25dID0gYzsKICAgIH0KCiAgICByZXR1cm4gdGFibGU7CiAgfQoKICAvLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLgogIHZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpOwoKCiAgZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7CiAgICB2YXIgdCA9IGNyY1RhYmxlLAogICAgICAgIGVuZCA9IHBvcyArIGxlbjsKCiAgICBjcmMgXj0gLTE7CgogICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7CiAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdOwogICAgfQoKICAgIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwOwogIH0KCgogIHZhciBjcmMzMl8xID0gY3JjMzI7CgogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICAvLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanMKICB2YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi8KICB2YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi8KCiAgLyoKICAgICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nCiAgICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzCiAgICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC4KICAgICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yCiAgICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZQogICAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLgoKICAgICBFbnRyeSBhc3N1bXB0aW9uczoKCiAgICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU4KICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNgogICAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4CiAgICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dAogICAgICAgICAgc3RhdGUuYml0cyA8IDgKCiAgICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjoKCiAgICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXQKICAgICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrCiAgICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YQoKICAgICBOb3RlczoKCiAgICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlCiAgICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsCiAgICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy4KICAgICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZAogICAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuCgogICAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNTgKICAgICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KCkKICAgICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3IKICAgICAgICBvdXRwdXQgc3BhY2UuCiAgICovCiAgdmFyIGluZmZhc3QgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHsKICAgIHZhciBzdGF0ZTsKICAgIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovCiAgICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovCiAgICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi8KICAgIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovCiAgICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovCiAgLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1QKICAgIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi8KICAvLyNlbmRpZgogICAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqLwogICAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi8KICAgIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi8KICAgIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzCiAgICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovCiAgICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovCiAgICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovCiAgICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovCiAgICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqLwogICAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqLwogICAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovCiAgICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovCiAgICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi8KICAgIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqLwogICAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovCiAgICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovCiAgICB2YXIgZnJvbV9zb3VyY2U7CgoKICAgIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzCgogICAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi8KICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgIC8vaGVyZSA9IHN0YXRlLmhlcmU7CiAgICBfaW4gPSBzdHJtLm5leHRfaW47CiAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTsKICAgIF9vdXQgPSBzdHJtLm5leHRfb3V0OwogICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7CiAgICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpOwogICAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7CiAgLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1QKICAgIGRtYXggPSBzdGF0ZS5kbWF4OwogIC8vI2VuZGlmCiAgICB3c2l6ZSA9IHN0YXRlLndzaXplOwogICAgd2hhdmUgPSBzdGF0ZS53aGF2ZTsKICAgIHduZXh0ID0gc3RhdGUud25leHQ7CiAgICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdzsKICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7CiAgICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlOwogICAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7CiAgICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7CgoKICAgIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaAogICAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi8KCiAgICB0b3A6CiAgICBkbyB7CiAgICAgIGlmIChiaXRzIDwgMTUpIHsKICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgIGJpdHMgKz0gODsKICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgIGJpdHMgKz0gODsKICAgICAgfQoKICAgICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107CgogICAgICBkb2xlbjoKICAgICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvbgogICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovOwogICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICBiaXRzIC09IG9wOwogICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLzsKICAgICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi8KICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/CiAgICAgICAgICAvLyAgICAgICAgImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXG4iIDoKICAgICAgICAgIC8vICAgICAgICAiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxuIiwgaGVyZS52YWwpKTsKICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLzsKICAgICAgICB9CiAgICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovCiAgICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovOwogICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi8KICAgICAgICAgIGlmIChvcCkgewogICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7CiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgIH0KICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcbiIsIGxlbikpOwogICAgICAgICAgaWYgKGJpdHMgPCAxNSkgewogICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdOwoKICAgICAgICAgIGRvZGlzdDoKICAgICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb24KICAgICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87CiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDsKICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovOwoKICAgICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqLwogICAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovOwogICAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi8KICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7CiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkgewogICAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTsKICAvLyNpZmRlZiBJTkZMQVRFX1NUUklDVAogICAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkgewogICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snOwogICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgICB9CiAgLy8jZW5kaWYKICAgICAgICAgICAgICBob2xkID4+Pj0gb3A7CiAgICAgICAgICAgICAgYml0cyAtPSBvcDsKICAgICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcbiIsIGRpc3QpKTsKICAgICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi8KICAgICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovCiAgICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqLwogICAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHsKICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7CiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgICAgICAgICAgICBicmVhayB0b3A7CiAgICAgICAgICAgICAgICAgIH0KCiAgLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cywKICAvLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5CiAgLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSCiAgLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7CiAgLy8gICAgICAgICAgICAgICAgICBkbyB7CiAgLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDsKICAvLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTsKICAvLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDsKICAvLyAgICAgICAgICAgICAgICB9CiAgLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7CiAgLy8gICAgICAgICAgICAgICAgZG8gewogIC8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwOwogIC8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7CiAgLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7CiAgLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7CiAgLy8gICAgICAgICAgICAgICAgICBkbyB7CiAgLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7CiAgLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7CiAgLy8gICAgICAgICAgICAgICAgfQogIC8vI2VuZGlmCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4CiAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93OwogICAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovCiAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDsKICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqLwogICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107CiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqLwogICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0OwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovCiAgICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi8KICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7CiAgICAgICAgICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApOwogICAgICAgICAgICAgICAgICAgIGZyb20gPSAwOwogICAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqLwogICAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDsKICAgICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDsKICAgICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdOwogICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7CiAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqLwogICAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi8KICAgICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wOwogICAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovCiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wOwogICAgICAgICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTsKICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovCiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGxlbikgewogICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107CiAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqLwogICAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovCiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgIGxlbiAtPSAzOwogICAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7CiAgICAgICAgICAgICAgICBpZiAobGVuKSB7CiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107CiAgICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi8KICAgICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTsKICAgICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJzsKICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEOwogICAgICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSAiY29udGludWUiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovCiAgICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTsKICAgICAgICAgIGNvbnRpbnVlIGRvbGVuOwogICAgICAgIH0KICAgICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovCiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXG4iKSk7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTsKICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnOwogICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDsKICAgICAgICAgIGJyZWFrIHRvcDsKICAgICAgICB9CgogICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgImNvbnRpbnVlIgogICAgICB9CiAgICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpOwoKICAgIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqLwogICAgbGVuID0gYml0cyA+PiAzOwogICAgX2luIC09IGxlbjsKICAgIGJpdHMgLT0gbGVuIDw8IDM7CiAgICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTsKCiAgICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqLwogICAgc3RybS5uZXh0X2luID0gX2luOwogICAgc3RybS5uZXh0X291dCA9IF9vdXQ7CiAgICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7CiAgICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTsKICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICByZXR1cm47CiAgfTsKCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgoKCiAgdmFyIE1BWEJJVFMgPSAxNTsKICB2YXIgRU5PVUdIX0xFTlMgPSA4NTI7CiAgdmFyIEVOT1VHSF9ESVNUUyA9IDU5MjsKICAvL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTsKCiAgdmFyIENPREVTID0gMDsKICB2YXIgTEVOUyA9IDE7CiAgdmFyIERJU1RTID0gMjsKCiAgdmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqLwogICAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSwKICAgIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwCiAgXTsKCiAgdmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqLwogICAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsCiAgICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4CiAgXTsKCiAgdmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovCiAgICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsCiAgICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsCiAgICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwCiAgXTsKCiAgdmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovCiAgICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMiwKICAgIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LAogICAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NAogIF07CgogIHZhciBpbmZ0cmVlcyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cykKICB7CiAgICB2YXIgYml0cyA9IG9wdHMuYml0czsKICAgICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqLwoKICAgIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovCiAgICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi8KICAgIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqLwogICAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi8KICAgIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovCiAgICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovCiAgICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovCiAgICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqLwogICAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovCiAgICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi8KICAgIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi8KICAgIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqLwogICAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovCiAgICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi8KICAgIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovCiAgICB2YXIgYmFzZV9pbmRleCA9IDA7CiAgLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi8KICAgIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqLwogICAgdmFyIGNvdW50ID0gbmV3IGNvbW1vbi5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqLwogICAgdmFyIG9mZnMgPSBuZXcgY29tbW9uLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovCiAgICB2YXIgZXh0cmEgPSBudWxsOwogICAgdmFyIGV4dHJhX2luZGV4ID0gMDsKCiAgICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsKCiAgICAvKgogICAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGUKICAgICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGUKICAgICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZQogICAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyCiAgICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0cwogICAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyCiAgICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGgKICAgICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzCiAgICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZQogICAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzCiAgICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy4KCiAgICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW4KICAgICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLgogICAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0CiAgICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS4KCiAgICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLAogICAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZQogICAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZAogICAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieQogICAgIHRoZSBjYWxsZXIuCgogICAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmcKICAgICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnkKICAgICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZAogICAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZQogICAgIGRlY29kaW5nIHRhYmxlcy4KICAgICAqLwoKICAgIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqLwogICAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHsKICAgICAgY291bnRbbGVuXSA9IDA7CiAgICB9CiAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrOwogICAgfQoKICAgIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovCiAgICByb290ID0gYml0czsKICAgIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7CiAgICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9CiAgICB9CiAgICBpZiAocm9vdCA+IG1heCkgewogICAgICByb290ID0gbWF4OwogICAgfQogICAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi8KICAgICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovCiAgICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTsKICAgICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDsKICAgICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDsKCgogICAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7CiAgICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7CiAgICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOwogICAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwOwoKICAgICAgb3B0cy5iaXRzID0gMTsKICAgICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovCiAgICB9CiAgICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHsKICAgICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH0KICAgIH0KICAgIGlmIChyb290IDwgbWluKSB7CiAgICAgIHJvb3QgPSBtaW47CiAgICB9CgogICAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovCiAgICBsZWZ0ID0gMTsKICAgIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7CiAgICAgIGxlZnQgPDw9IDE7CiAgICAgIGxlZnQgLT0gY291bnRbbGVuXTsKICAgICAgaWYgKGxlZnQgPCAwKSB7CiAgICAgICAgcmV0dXJuIC0xOwogICAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi8KICAgIH0KICAgIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkgewogICAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovCiAgICB9CgogICAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi8KICAgIG9mZnNbMV0gPSAwOwogICAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykgewogICAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTsKICAgIH0KCiAgICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovCiAgICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykgewogICAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkgewogICAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTsKICAgICAgfQogICAgfQoKICAgIC8qCiAgICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nCiAgICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmYKICAgICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3AKICAgICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsCiAgICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0bwogICAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLgoKICAgICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzCiAgICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXgKICAgICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYQogICAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpcwogICAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC4KCiAgICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGUKICAgICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aAogICAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlCiAgICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLgoKICAgICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZQogICAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3QKICAgICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluCiAgICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaAogICAgIGZvciBtb3JlIGluZm9ybWF0aW9uLgoKICAgICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuCiAgICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpcwogICAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHMKICAgICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuCiAgICAgKi8KCiAgICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqLwogICAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsCiAgICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4CiAgICBpZiAodHlwZSA9PT0gQ09ERVMpIHsKICAgICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovCiAgICAgIGVuZCA9IDE5OwoKICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykgewogICAgICBiYXNlID0gbGJhc2U7CiAgICAgIGJhc2VfaW5kZXggLT0gMjU3OwogICAgICBleHRyYSA9IGxleHQ7CiAgICAgIGV4dHJhX2luZGV4IC09IDI1NzsKICAgICAgZW5kID0gMjU2OwoKICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqLwogICAgICBiYXNlID0gZGJhc2U7CiAgICAgIGV4dHJhID0gZGV4dDsKICAgICAgZW5kID0gLTE7CiAgICB9CgogICAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovCiAgICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqLwogICAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovCiAgICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi8KICAgIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqLwogICAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqLwogICAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi8KICAgIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovCiAgICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovCiAgICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqLwoKICAgIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqLwogICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHwKICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7CiAgICAgIHJldHVybiAxOwogICAgfQoKICAgIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi8KICAgIGZvciAoOzspIHsKICAgICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovCiAgICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7CiAgICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHsKICAgICAgICBoZXJlX29wID0gMDsKICAgICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTsKICAgICAgfQogICAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHsKICAgICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dOwogICAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTsKICAgICAgfQogICAgICBlbHNlIHsKICAgICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi8KICAgICAgICBoZXJlX3ZhbCA9IDA7CiAgICAgIH0KCiAgICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovCiAgICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTsKICAgICAgZmlsbCA9IDEgPDwgY3VycjsKICAgICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi8KICAgICAgZG8gewogICAgICAgIGZpbGwgLT0gaW5jcjsKICAgICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7CiAgICAgIH0gd2hpbGUgKGZpbGwgIT09IDApOwoKICAgICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi8KICAgICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpOwogICAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHsKICAgICAgICBpbmNyID4+PSAxOwogICAgICB9CiAgICAgIGlmIChpbmNyICE9PSAwKSB7CiAgICAgICAgaHVmZiAmPSBpbmNyIC0gMTsKICAgICAgICBodWZmICs9IGluY3I7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaHVmZiA9IDA7CiAgICAgIH0KCiAgICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqLwogICAgICBzeW0rKzsKICAgICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkgewogICAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfQogICAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07CiAgICAgIH0KCiAgICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqLwogICAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHsKICAgICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi8KICAgICAgICBpZiAoZHJvcCA9PT0gMCkgewogICAgICAgICAgZHJvcCA9IHJvb3Q7CiAgICAgICAgfQoKICAgICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovCiAgICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovCgogICAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqLwogICAgICAgIGN1cnIgPSBsZW4gLSBkcm9wOwogICAgICAgIGxlZnQgPSAxIDw8IGN1cnI7CiAgICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7CiAgICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTsKICAgICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH0KICAgICAgICAgIGN1cnIrKzsKICAgICAgICAgIGxlZnQgPDw9IDE7CiAgICAgICAgfQoKICAgICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovCiAgICAgICAgdXNlZCArPSAxIDw8IGN1cnI7CiAgICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHwKICAgICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkgewogICAgICAgICAgcmV0dXJuIDE7CiAgICAgICAgfQoKICAgICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqLwogICAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrOwogICAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7CiAgICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDsKICAgICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovCiAgICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwOwogICAgICB9CiAgICB9CgogICAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmUKICAgICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZQogICAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi8KICAgIGlmIChodWZmICE9PSAwKSB7CiAgICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqLwogICAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDsKICAgICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDsKICAgICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwOwogICAgfQoKICAgIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqLwogICAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7CiAgICBvcHRzLmJpdHMgPSByb290OwogICAgcmV0dXJuIDA7CiAgfTsKCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgoKCgoKCgogIHZhciBDT0RFUyQxID0gMDsKICB2YXIgTEVOUyQxID0gMTsKICB2YXIgRElTVFMkMSA9IDI7CgogIC8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovCiAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki8KCgogIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi8KICAvL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwOwogIC8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7CiAgLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjsKICAvL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzOwogIHZhciBaX0ZJTklTSCAgICAgICAgPSA0OwogIHZhciBaX0JMT0NLICAgICAgICAgPSA1OwogIHZhciBaX1RSRUVTICAgICAgICAgPSA2OwoKCiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlcwogICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy4KICAgKi8KICB2YXIgWl9PSyAgICAgICAgICAgID0gMDsKICB2YXIgWl9TVFJFQU1fRU5EICAgID0gMTsKICB2YXIgWl9ORUVEX0RJQ1QgICAgID0gMjsKICAvL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTsKICB2YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7CiAgdmFyIFpfREFUQV9FUlJPUiAgICA9IC0zOwogIHZhciBaX01FTV9FUlJPUiAgICAgPSAtNDsKICB2YXIgWl9CVUZfRVJST1IgICAgID0gLTU7CiAgLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7CgogIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqLwogIHZhciBaX0RFRkxBVEVEICA9IDg7CgoKICAvKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwogIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovCgoKICB2YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqLwogIHZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi8KICB2YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqLwogIHZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovCiAgdmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovCiAgdmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi8KICB2YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovCiAgdmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi8KICB2YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovCiAgdmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovCiAgdmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi8KICB2YXIgICAgICAgIFRZUEUkMSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi8KICB2YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovCiAgdmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi8KICB2YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqLwogIHZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovCiAgdmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovCiAgdmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovCiAgdmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovCiAgdmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovCiAgdmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi8KICB2YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi8KICB2YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqLwogIHZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovCiAgdmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqLwogIHZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqLwogIHZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovCiAgdmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqLwogIHZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi8KICB2YXIgICAgQkFEJDEgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqLwogIHZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi8KICB2YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqLwoKICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qLwoKCgogIHZhciBFTk9VR0hfTEVOUyQxID0gODUyOwogIHZhciBFTk9VR0hfRElTVFMkMSA9IDU5MjsKICAvL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7CgogIHZhciBNQVhfV0JJVFMgPSAxNTsKICAvKiAzMksgTFo3NyB3aW5kb3cgKi8KICB2YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTOwoKCiAgZnVuY3Rpb24genN3YXAzMihxKSB7CiAgICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICsKICAgICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgKwogICAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICsKICAgICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTsKICB9CgoKICBmdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7CiAgICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqLwogICAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovCiAgICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqLwogICAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqLwogICAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi8KICAgIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqLwogICAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovCiAgICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovCiAgICAvLyBUT0RPOiBtYXkgYmUge30KICAgIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovCgogICAgLyogc2xpZGluZyB3aW5kb3cgKi8KICAgIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqLwogICAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqLwogICAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi8KICAgIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi8KICAgIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqLwoKICAgIC8qIGJpdCBhY2N1bXVsYXRvciAqLwogICAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqLwogICAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluICJpbiIgKi8KCiAgICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqLwogICAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqLwogICAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqLwoKICAgIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqLwogICAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovCgogICAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi8KICAgIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqLwogICAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovCiAgICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqLwogICAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovCgogICAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqLwogICAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi8KICAgIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqLwogICAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi8KICAgIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqLwogICAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi8KCiAgICB0aGlzLmxlbnMgPSBuZXcgY29tbW9uLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi8KICAgIHRoaXMud29yayA9IG5ldyBjb21tb24uQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovCgogICAgLyoKICAgICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseQogICAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2RlcwogICAgKi8KICAgIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi8KICAgIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi8KICAgIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi8KICAgIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi8KICAgIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi8KICAgIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovCiAgfQoKICBmdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHsKICAgIHZhciBzdGF0ZTsKCiAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9CiAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7CiAgICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovCiAgICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovCiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTsKICAgIH0KICAgIHN0YXRlLm1vZGUgPSBIRUFEOwogICAgc3RhdGUubGFzdCA9IDA7CiAgICBzdGF0ZS5oYXZlZGljdCA9IDA7CiAgICBzdGF0ZS5kbWF4ID0gMzI3Njg7CiAgICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87CiAgICBzdGF0ZS5ob2xkID0gMDsKICAgIHN0YXRlLmJpdHMgPSAwOwogICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7CiAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IGNvbW1vbi5CdWYzMihFTk9VR0hfTEVOUyQxKTsKICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyBjb21tb24uQnVmMzIoRU5PVUdIX0RJU1RTJDEpOwoKICAgIHN0YXRlLnNhbmUgPSAxOwogICAgc3RhdGUuYmFjayA9IC0xOwogICAgLy9UcmFjZXYoKHN0ZGVyciwgImluZmxhdGU6IHJlc2V0XG4iKSk7CiAgICByZXR1cm4gWl9PSzsKICB9CgogIGZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7CiAgICB2YXIgc3RhdGU7CgogICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfQogICAgc3RhdGUgPSBzdHJtLnN0YXRlOwogICAgc3RhdGUud3NpemUgPSAwOwogICAgc3RhdGUud2hhdmUgPSAwOwogICAgc3RhdGUud25leHQgPSAwOwogICAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7CgogIH0KCiAgZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7CiAgICB2YXIgd3JhcDsKICAgIHZhciBzdGF0ZTsKCiAgICAvKiBnZXQgdGhlIHN0YXRlICovCiAgICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9CiAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CgogICAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqLwogICAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7CiAgICAgIHdyYXAgPSAwOwogICAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7CiAgICB9CiAgICBlbHNlIHsKICAgICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTsKICAgICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkgewogICAgICAgIHdpbmRvd0JpdHMgJj0gMTU7CiAgICAgIH0KICAgIH0KCiAgICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi8KICAgIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7CiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgIH0KICAgIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHsKICAgICAgc3RhdGUud2luZG93ID0gbnVsbDsKICAgIH0KCiAgICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovCiAgICBzdGF0ZS53cmFwID0gd3JhcDsKICAgIHN0YXRlLndiaXRzID0gd2luZG93Qml0czsKICAgIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7CiAgfQoKICBmdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykgewogICAgdmFyIHJldDsKICAgIHZhciBzdGF0ZTsKCiAgICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9CiAgICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi8KCiAgICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTsKCiAgICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7CiAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogYWxsb2NhdGVkXG4iKSk7CiAgICBzdHJtLnN0YXRlID0gc3RhdGU7CiAgICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLzsKICAgIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7CiAgICBpZiAocmV0ICE9PSBaX09LKSB7CiAgICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLzsKICAgIH0KICAgIHJldHVybiByZXQ7CiAgfQoKICBmdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7CiAgICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7CiAgfQoKCiAgLyoKICAgUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0bwogICBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguCiAgIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGUKICAgZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZAogICB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpbgogICBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmUKICAgdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpbgogICBtYXkgbm90IGJlIHRocmVhZC1zYWZlLgogICAqLwogIHZhciB2aXJnaW4gPSB0cnVlOwoKICB2YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZQoKICBmdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkgewogICAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi8KICAgIGlmICh2aXJnaW4pIHsKICAgICAgdmFyIHN5bTsKCiAgICAgIGxlbmZpeCA9IG5ldyBjb21tb24uQnVmMzIoNTEyKTsKICAgICAgZGlzdGZpeCA9IG5ldyBjb21tb24uQnVmMzIoMzIpOwoKICAgICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi8KICAgICAgc3ltID0gMDsKICAgICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH0KICAgICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH0KICAgICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH0KICAgICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH0KCiAgICAgIGluZnRyZWVzKExFTlMkMSwgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTsKCiAgICAgIC8qIGRpc3RhbmNlIHRhYmxlICovCiAgICAgIHN5bSA9IDA7CiAgICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH0KCiAgICAgIGluZnRyZWVzKERJU1RTJDEsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTsKCiAgICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovCiAgICAgIHZpcmdpbiA9IGZhbHNlOwogICAgfQoKICAgIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7CiAgICBzdGF0ZS5sZW5iaXRzID0gOTsKICAgIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDsKICAgIHN0YXRlLmRpc3RiaXRzID0gNTsKICB9CgoKICAvKgogICBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlCiAgIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWQKICAgd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpcwogICBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuCiAgIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5CiAgIGlzIGxvYWRlZC4KCiAgIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWQKICAgYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvdwogICB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZgogICBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuCiAgIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuCiAgICovCiAgZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7CiAgICB2YXIgZGlzdDsKICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CgogICAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqLwogICAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkgewogICAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7CiAgICAgIHN0YXRlLnduZXh0ID0gMDsKICAgICAgc3RhdGUud2hhdmUgPSAwOwoKICAgICAgc3RhdGUud2luZG93ID0gbmV3IGNvbW1vbi5CdWY4KHN0YXRlLndzaXplKTsKICAgIH0KCiAgICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi8KICAgIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7CiAgICAgIGNvbW1vbi5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTsKICAgICAgc3RhdGUud25leHQgPSAwOwogICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplOwogICAgfQogICAgZWxzZSB7CiAgICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0OwogICAgICBpZiAoZGlzdCA+IGNvcHkpIHsKICAgICAgICBkaXN0ID0gY29weTsKICAgICAgfQogICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7CiAgICAgIGNvbW1vbi5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpOwogICAgICBjb3B5IC09IGRpc3Q7CiAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpOwogICAgICAgIGNvbW1vbi5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7CiAgICAgICAgc3RhdGUud25leHQgPSBjb3B5OwogICAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7CiAgICAgIH0KICAgICAgZWxzZSB7CiAgICAgICAgc3RhdGUud25leHQgKz0gZGlzdDsKICAgICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfQogICAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIDA7CiAgfQoKICBmdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7CiAgICB2YXIgc3RhdGU7CiAgICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnMKICAgIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovCiAgICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi8KICAgIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqLwogICAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi8KICAgIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi8KICAgIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovCiAgICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovCiAgICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovCiAgICB2YXIgZnJvbV9zb3VyY2U7CiAgICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqLwogICAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkICJoZXJlIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKQogICAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovCiAgICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgImxhc3QiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpCiAgICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqLwogICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovCiAgICB2YXIgaGJ1ZiA9IG5ldyBjb21tb24uQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi8KICAgIHZhciBvcHRzOwoKICAgIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFMKCiAgICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi8KICAgICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07CgoKICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHwKICAgICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHsKICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgfQoKICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFJDEpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovCgoKICAgIC8vLS0tIExPQUQoKSAtLS0KICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7CiAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDsKICAgIG5leHQgPSBzdHJtLm5leHRfaW47CiAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICBoYXZlID0gc3RybS5hdmFpbF9pbjsKICAgIGhvbGQgPSBzdGF0ZS5ob2xkOwogICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAvLy0tLQoKICAgIF9pbiA9IGhhdmU7CiAgICBfb3V0ID0gbGVmdDsKICAgIHJldCA9IFpfT0s7CgogICAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvbgogICAgZm9yICg7OykgewogICAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHsKICAgICAgICBjYXNlIEhFQUQ6CiAgICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkgewogICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsKICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi8KICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovOwogICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTsKICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmOwogICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjsKICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTsKICAgICAgICAgICAgLy89PT0vLwoKICAgICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTsKICAgICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUzsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi8KICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqLwogICAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4OwogICAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7CiAgICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuOwogICAgICAgICAgfQogICAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47CiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xuIikpOwogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovOwogICAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEUkMTsKICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgLy89PT0vLwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBGTEFHUzoKICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDsKICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7CiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpOwogICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7CiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmOwogICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICB9CiAgICAgICAgICAvLz09PSBJTklUQklUUygpOwogICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgVElNRToKICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHsKICAgICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZCkKICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmOwogICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjsKICAgICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmOwogICAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7CiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7CiAgICAgICAgICAgIC8vPT09CiAgICAgICAgICB9CiAgICAgICAgICAvLz09PSBJTklUQklUUygpOwogICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLm1vZGUgPSBPUzsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIE9TOgogICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqLwogICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikgewogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgfQogICAgICAgICAgLy89PT0vLwogICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpOwogICAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHsKICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7CiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjsKICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7CiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIH0KICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgLy89PT0vLwogICAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgRVhMRU46CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHsKICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqLwogICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7CiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgewogICAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpOwogICAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjsKICAgICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjsKICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApOwogICAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgfQogICAgICAgICAgICAvLz09PSBJTklUQklUUygpOwogICAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgICAgYml0cyA9IDA7CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIH0KICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovOwogICAgICAgICAgfQogICAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgRVhUUkE6CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHsKICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9CiAgICAgICAgICAgIGlmIChjb3B5KSB7CiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7CiAgICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlcgogICAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbW1vbi5hcnJheVNldCgKICAgICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSwKICAgICAgICAgICAgICAgICAgaW5wdXQsCiAgICAgICAgICAgICAgICAgIG5leHQsCiAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXMKICAgICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2sKICAgICAgICAgICAgICAgICAgY29weSwKICAgICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi8KICAgICAgICAgICAgICAgICAgbGVuCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsCiAgICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID8KICAgICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHsKICAgICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBoYXZlIC09IGNvcHk7CiAgICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSAwOwogICAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBOQU1FOgogICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7CiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBjb3B5ID0gMDsKICAgICAgICAgICAgZG8gewogICAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz8KICAgICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTsKICAgICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqLwogICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJgogICAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7CiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKCiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkgewogICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGhhdmUgLT0gY29weTsKICAgICAgICAgICAgbmV4dCArPSBjb3B5OwogICAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgfQogICAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkgewogICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsOwogICAgICAgICAgfQogICAgICAgICAgc3RhdGUubGVuZ3RoID0gMDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgQ09NTUVOVDoKICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkgewogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgY29weSA9IDA7CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTsKICAgICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqLwogICAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJgogICAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7CiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTsKICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7CiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICB9CiAgICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7CiAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5tb2RlID0gSENSQzsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIEhDUkM6CiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHsKICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqLwogICAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7CiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7CiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7CiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgfQogICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHsKICAgICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpOwogICAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFJDE7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlIERJQ1RJRDoKICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7CiAgICAgICAgICAvLz09PSBJTklUQklUUygpOwogICAgICAgICAgaG9sZCA9IDA7CiAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLm1vZGUgPSBESUNUOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgRElDVDoKICAgICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkgewogICAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tCiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgLy8tLS0KICAgICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUOwogICAgICAgICAgfQogICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovOwogICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEUkMTsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIFRZUEUkMToKICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIFRZUEVETzoKICAgICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7CiAgICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8KICAgICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3OwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSzsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgfQogICAgICAgICAgLy89PT0vLwogICAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLzsKICAgICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vCiAgICAgICAgICBob2xkID4+Pj0gMTsKICAgICAgICAgIGJpdHMgLT0gMTsKICAgICAgICAgIC8vLS0tLy8KCiAgICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykgewogICAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi8KICAgICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXG4iLAogICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gIiAobGFzdCkiIDogIiIpKTsKICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqLwogICAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTsKICAgICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcbiIsCiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyAiIChsYXN0KSIgOiAiIikpOwogICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi8KICAgICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsKICAgICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi8KICAgICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xuIiwKICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/ICIgKGxhc3QpIiA6ICIiKSk7CiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJzsKICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7CiAgICAgICAgICB9CiAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IDI7CiAgICAgICAgICBiaXRzIC09IDI7CiAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlIFNUT1JFRDoKICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqLwogICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3OwogICAgICAgICAgYml0cyAtPSBiaXRzICYgNzsKICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7CiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxuIiwKICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTsKICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICBob2xkID0gMDsKICAgICAgICAgIGJpdHMgPSAwOwogICAgICAgICAgLy89PT0vLwogICAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfOwogICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgQ09QWV86CiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIENPUFk6CiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoOwogICAgICAgICAgaWYgKGNvcHkpIHsKICAgICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9CiAgICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfQogICAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS0KICAgICAgICAgICAgY29tbW9uLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgaGF2ZSAtPSBjb3B5OwogICAgICAgICAgICBuZXh0ICs9IGNvcHk7CiAgICAgICAgICAgIGxlZnQgLT0gY29weTsKICAgICAgICAgICAgcHV0ICs9IGNvcHk7CiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5OwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXG4iKSk7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBUQUJMRToKICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi8KICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHsKICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgIH0KICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7CiAgICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7CiAgICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IDU7CiAgICAgICAgICBiaXRzIC09IDU7CiAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7CiAgICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IDQ7CiAgICAgICAgICBiaXRzIC09IDQ7CiAgICAgICAgICAvLy0tLS8vCiAgLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5ECiAgICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAvLyNlbmRpZgogICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXG4iKSk7CiAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgTEVOTEVOUzoKICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHsKICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7CiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykgewogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7CiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vCiAgICAgICAgICAgIGhvbGQgPj4+PSAzOwogICAgICAgICAgICBiaXRzIC09IDM7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIH0KICAgICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHsKICAgICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLgogICAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7CiAgICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0OwogICAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlCiAgICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluOwogICAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7CgogICAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9OwogICAgICAgICAgcmV0ID0gaW5mdHJlZXMoQ09ERVMkMSwgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0czsKCiAgICAgICAgICBpZiAocmV0KSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXG4iKSk7CiAgICAgICAgICBzdGF0ZS5oYXZlID0gMDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUzsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIENPREVMRU5TOgogICAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHsKICAgICAgICAgICAgZm9yICg7OykgewogICAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi8KICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7CiAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmOwoKICAgICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfQogICAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy8KICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikgewogICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy8KICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7CiAgICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTsKICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyOwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkgewogICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JzsKICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdOwogICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTsKICAgICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMjsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMjsKICAgICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7CiAgICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTsKICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzOwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTsKICAgICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gMzsKICAgICAgICAgICAgICAgIGJpdHMgLT0gMzsKICAgICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTsKICAgICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3OwogICAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vCiAgICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgICBsZW4gPSAwOwogICAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7CiAgICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vLwogICAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7CiAgICAgICAgICAgICAgICBiaXRzIC09IDc7CiAgICAgICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkgewogICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7CiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkgewogICAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi8KICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQkMSkgeyBicmVhazsgfQoKICAgICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqLwogICAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHMKICAgICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmgKICAgICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi8KICAgICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5OwoKICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTsKICAgICAgICAgIHJldCA9IGluZnRyZWVzKExFTlMkMSwgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7CiAgICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLgogICAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7CiAgICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzOwogICAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7CgogICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjsKICAgICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7CiAgICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGUKICAgICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjsKICAgICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07CiAgICAgICAgICByZXQgPSBpbmZ0cmVlcyhESVNUUyQxLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpOwogICAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC4KICAgICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4OwogICAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7CiAgICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7CgogICAgICAgICAgaWYgKHJldCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXG4nKSk7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsKICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIExFTl86CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgTEVOOgogICAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkgewogICAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tCiAgICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDsKICAgICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7CiAgICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0czsKICAgICAgICAgICAgLy8tLS0KICAgICAgICAgICAgaW5mZmFzdChzdHJtLCBfb3V0KTsKICAgICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLQogICAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0OwogICAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDsKICAgICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0OwogICAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luOwogICAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7CiAgICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luOwogICAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDsKICAgICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7CiAgICAgICAgICAgIC8vLS0tCgogICAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSQxKSB7CiAgICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgc3RhdGUuYmFjayA9IDA7CiAgICAgICAgICBmb3IgKDs7KSB7CiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqLwogICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmOwogICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7CgogICAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH0KICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vLwogICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7CiAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgIGZvciAoOzspIHsKICAgICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArCiAgICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldOwogICAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0OwogICAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjsKICAgICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7CgogICAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9CiAgICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vLwogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy8KICAgICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0czsKICAgICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7CiAgICAgICAgICB9CiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vCiAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzOwogICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7CiAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0czsKICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsOwogICAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHsKICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID8KICAgICAgICAgICAgLy8gICAgICAgICJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xuIiA6CiAgICAgICAgICAgIC8vICAgICAgICAiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxuIiwgaGVyZS52YWwpKTsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IExJVDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7CiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcbiIpKTsKICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xOwogICAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRSQxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChoZXJlX29wICYgNjQpIHsKICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJzsKICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1OwogICAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIExFTkVYVDoKICAgICAgICAgIGlmIChzdGF0ZS5leHRyYSkgewogICAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7CiAgICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7CiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9CiAgICAgICAgICAgICAgaGF2ZS0tOwogICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICAgIGJpdHMgKz0gODsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLz09PS8vCiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovOwogICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy8KICAgICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhOwogICAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhOwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7CiAgICAgICAgICB9CiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XG4iLCBzdGF0ZS5sZW5ndGgpKTsKICAgICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgIHN0YXRlLm1vZGUgPSBESVNUOwogICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLwogICAgICAgIGNhc2UgRElTVDoKICAgICAgICAgIGZvciAoOzspIHsKICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqLwogICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmOwogICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7CgogICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfQogICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vCiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzOwogICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgIH0KICAgICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7CiAgICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0czsKICAgICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7CiAgICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7CiAgICAgICAgICAgIGZvciAoOzspIHsKICAgICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgKwogICAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTsKICAgICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDsKICAgICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7CiAgICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmOwoKICAgICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfQogICAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy8KICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICAgIC8vLS0tLy8KICAgICAgICAgICAgfQogICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vCiAgICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7CiAgICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzOwogICAgICAgICAgICAvLy0tLS8vCiAgICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzOwogICAgICAgICAgfQogICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vLwogICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0czsKICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzOwogICAgICAgICAgLy8tLS0vLwogICAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7CiAgICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7CiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDsKICAgICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIERJU1RFWFQ6CiAgICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHsKICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpOwogICAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7CiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikgewogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLzsKICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vCiAgICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTsKICAgICAgICAgICAgLy8tLS0vLwogICAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhOwogICAgICAgICAgfQogIC8vI2lmZGVmIElORkxBVEVfU1RSSUNUCiAgICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkgewogICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7CiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgLy8jZW5kaWYKICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCAiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxuIiwgc3RhdGUub2Zmc2V0KSk7CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBNQVRDSDoKICAgICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0OwogICAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovCiAgICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5OwogICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7CiAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHsKICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJzsKICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KICAvLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLAogIC8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHkKICAvLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlIKICAvLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCAiaW5mbGF0ZS5jIHRvbyBmYXJcbiIpKTsKICAvLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlOwogIC8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH0KICAvLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH0KICAvLyAgICAgICAgICBsZWZ0IC09IGNvcHk7CiAgLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgLy8gICAgICAgICAgZG8gewogIC8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7CiAgLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTsKICAvLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH0KICAvLyAgICAgICAgICBicmVhazsKICAvLyNlbmRpZgogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHsKICAgICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0OwogICAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9CiAgICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93OwogICAgICAgICAgfQogICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqLwogICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDsKICAgICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDsKICAgICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfQogICAgICAgICAgbGVmdCAtPSBjb3B5OwogICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7CiAgICAgICAgICBkbyB7CiAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdOwogICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTsKICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBMSVQ6CiAgICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7CiAgICAgICAgICBsZWZ0LS07CiAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSBDSEVDSzoKICAgICAgICAgIGlmIChzdGF0ZS53cmFwKSB7CiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsKICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikgewogICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfQogICAgICAgICAgICAgIGhhdmUtLTsKICAgICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWQKICAgICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0czsKICAgICAgICAgICAgICBiaXRzICs9IDg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICBfb3V0IC09IGxlZnQ7CiAgICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7CiAgICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7CiAgICAgICAgICAgIGlmIChfb3V0KSB7CiAgICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0KICAgICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovCiAgICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpOwoKICAgICAgICAgICAgfQogICAgICAgICAgICBfb3V0ID0gbGVmdDsKICAgICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b28KICAgICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7CiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcbiIpKTsKICAgICAgICAgIH0KICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgY2FzZSBMRU5HVEg6CiAgICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykgewogICAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7CiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHsKICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH0KICAgICAgICAgICAgICBoYXZlLS07CiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7CiAgICAgICAgICAgICAgYml0cyArPSA4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09Ly8KICAgICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7CiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7CiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRCQxOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7CiAgICAgICAgICAgIGhvbGQgPSAwOwogICAgICAgICAgICBiaXRzID0gMDsKICAgICAgICAgICAgLy89PT0vLwogICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXG4iKSk7CiAgICAgICAgICB9CiAgICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTsKICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi8KICAgICAgICBjYXNlIERPTkU6CiAgICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7CiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7CiAgICAgICAgY2FzZSBCQUQkMToKICAgICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjsKICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTsKICAgICAgICBjYXNlIE1FTToKICAgICAgICAgIHJldHVybiBaX01FTV9FUlJPUjsKICAgICAgICBjYXNlIFNZTkM6CiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovCiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjsKICAgICAgfQogICAgfQoKICAgIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yICJnb3RvIGluZl9sZWF2ZSIsIGVtdWxhdGVkIHZpYSAiYnJlYWsgaW5mX2xlYXZlIgoKICAgIC8qCiAgICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS4KICAgICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXIKICAgICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLgogICAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLgogICAgICovCgogICAgLy8tLS0gUkVTVE9SRSgpIC0tLQogICAgc3RybS5uZXh0X291dCA9IHB1dDsKICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDsKICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7CiAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTsKICAgIHN0YXRlLmhvbGQgPSBob2xkOwogICAgc3RhdGUuYml0cyA9IGJpdHM7CiAgICAvLy0tLQoKICAgIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCQxICYmCiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHsKICAgICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkgOwogICAgfQogICAgX2luIC09IHN0cm0uYXZhaWxfaW47CiAgICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0OwogICAgc3RybS50b3RhbF9pbiArPSBfaW47CiAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0OwogICAgc3RhdGUudG90YWwgKz0gX291dDsKICAgIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHsKICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqLwogICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7CiAgICB9CiAgICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgKwogICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUkMSA/IDEyOCA6IDApICsKICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7CiAgICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHsKICAgICAgcmV0ID0gWl9CVUZfRVJST1I7CiAgICB9CiAgICByZXR1cm4gcmV0OwogIH0KCiAgZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7CgogICAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHsKICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOwogICAgfQoKICAgIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7CiAgICBpZiAoc3RhdGUud2luZG93KSB7CiAgICAgIHN0YXRlLndpbmRvdyA9IG51bGw7CiAgICB9CiAgICBzdHJtLnN0YXRlID0gbnVsbDsKICAgIHJldHVybiBaX09LOwogIH0KCiAgZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7CiAgICB2YXIgc3RhdGU7CgogICAgLyogY2hlY2sgc3RhdGUgKi8KICAgIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH0KICAgIHN0YXRlID0gc3RybS5zdGF0ZTsKICAgIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfQoKICAgIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqLwogICAgc3RhdGUuaGVhZCA9IGhlYWQ7CiAgICBoZWFkLmRvbmUgPSBmYWxzZTsKICAgIHJldHVybiBaX09LOwogIH0KCiAgZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkgewogICAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDsKCiAgICB2YXIgc3RhdGU7CiAgICB2YXIgZGljdGlkOwogICAgdmFyIHJldDsKCiAgICAvKiBjaGVjayBzdGF0ZSAqLwogICAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9CiAgICBzdGF0ZSA9IHN0cm0uc3RhdGU7CgogICAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkgewogICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7CiAgICB9CgogICAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovCiAgICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkgewogICAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi8KICAgICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqLwogICAgICBkaWN0aWQgPSBhZGxlcjMyXzEoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTsKICAgICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHsKICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOwogICAgICB9CiAgICB9CiAgICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZQogICAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi8KICAgIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTsKICAgIGlmIChyZXQpIHsKICAgICAgc3RhdGUubW9kZSA9IE1FTTsKICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SOwogICAgfQogICAgc3RhdGUuaGF2ZWRpY3QgPSAxOwogICAgLy8gVHJhY2V2KChzdGRlcnIsICJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XG4iKSk7CiAgICByZXR1cm4gWl9PSzsKICB9CgogIHZhciBpbmZsYXRlUmVzZXRfMSA9IGluZmxhdGVSZXNldDsKICB2YXIgaW5mbGF0ZVJlc2V0Ml8xID0gaW5mbGF0ZVJlc2V0MjsKICB2YXIgaW5mbGF0ZVJlc2V0S2VlcF8xID0gaW5mbGF0ZVJlc2V0S2VlcDsKICB2YXIgaW5mbGF0ZUluaXRfMSA9IGluZmxhdGVJbml0OwogIHZhciBpbmZsYXRlSW5pdDJfMSA9IGluZmxhdGVJbml0MjsKICB2YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZTsKICB2YXIgaW5mbGF0ZUVuZF8xID0gaW5mbGF0ZUVuZDsKICB2YXIgaW5mbGF0ZUdldEhlYWRlcl8xID0gaW5mbGF0ZUdldEhlYWRlcjsKICB2YXIgaW5mbGF0ZVNldERpY3Rpb25hcnlfMSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5OwogIHZhciBpbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJzsKCiAgLyogTm90IGltcGxlbWVudGVkCiAgZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5OwogIGV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTsKICBleHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7CiAgZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7CiAgZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jOwogIGV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7CiAgZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTsKICAqLwoKICB2YXIgaW5mbGF0ZV8xID0gewogIAlpbmZsYXRlUmVzZXQ6IGluZmxhdGVSZXNldF8xLAogIAlpbmZsYXRlUmVzZXQyOiBpbmZsYXRlUmVzZXQyXzEsCiAgCWluZmxhdGVSZXNldEtlZXA6IGluZmxhdGVSZXNldEtlZXBfMSwKICAJaW5mbGF0ZUluaXQ6IGluZmxhdGVJbml0XzEsCiAgCWluZmxhdGVJbml0MjogaW5mbGF0ZUluaXQyXzEsCiAgCWluZmxhdGU6IGluZmxhdGVfMiwKICAJaW5mbGF0ZUVuZDogaW5mbGF0ZUVuZF8xLAogIAlpbmZsYXRlR2V0SGVhZGVyOiBpbmZsYXRlR2V0SGVhZGVyXzEsCiAgCWluZmxhdGVTZXREaWN0aW9uYXJ5OiBpbmZsYXRlU2V0RGljdGlvbmFyeV8xLAogIAlpbmZsYXRlSW5mbzogaW5mbGF0ZUluZm8KICB9OwoKICAvLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uCiAgLy8KICAvLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMgogIC8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmkKICAvLwogIHZhciBTVFJfQVBQTFlfT0sgPSB0cnVlOwogIHZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTsKCiAgdHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9CiAgdHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfQoKCiAgLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSkKICAvLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUywKICAvLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmYKICB2YXIgX3V0ZjhsZW4gPSBuZXcgY29tbW9uLkJ1ZjgoMjU2KTsKICBmb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7CiAgICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTsKICB9CiAgX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0CgoKICAvLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpCiAgdmFyIHN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7CiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDsKCiAgICAvLyBjb3VudCBiaW5hcnkgc2l6ZQogICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykgewogICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpOwogICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7CiAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpOwogICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHsKICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApOwogICAgICAgICAgbV9wb3MrKzsKICAgICAgICB9CiAgICAgIH0KICAgICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDsKICAgIH0KCiAgICAvLyBhbGxvY2F0ZSBidWZmZXIKICAgIGJ1ZiA9IG5ldyBjb21tb24uQnVmOChidWZfbGVuKTsKCiAgICAvLyBjb252ZXJ0CiAgICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7CiAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7CiAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHsKICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7CiAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkgewogICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7CiAgICAgICAgICBtX3BvcysrOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoYyA8IDB4ODApIHsKICAgICAgICAvKiBvbmUgYnl0ZSAqLwogICAgICAgIGJ1ZltpKytdID0gYzsKICAgICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHsKICAgICAgICAvKiB0d28gYnl0ZXMgKi8KICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7CiAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTsKICAgICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkgewogICAgICAgIC8qIHRocmVlIGJ5dGVzICovCiAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTsKICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpOwogICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLyogZm91ciBieXRlcyAqLwogICAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7CiAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7CiAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTsKICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIGJ1ZjsKICB9OwoKICAvLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpCiAgZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikgewogICAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuCiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sCiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguCiAgICBpZiAobGVuIDwgNjU1MzQpIHsKICAgICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkgewogICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvbW1vbi5zaHJpbmtCdWYoYnVmLCBsZW4pKTsKICAgICAgfQogICAgfQoKICAgIHZhciByZXN1bHQgPSAnJzsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHsKICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTsKICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQoKCiAgLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmcKICB2YXIgYnVmMmJpbnN0cmluZ18xID0gZnVuY3Rpb24gKGJ1ZikgewogICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTsKICB9OwoKCiAgLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSkKICB2YXIgYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHsKICAgIHZhciBidWYgPSBuZXcgY29tbW9uLkJ1Zjgoc3RyLmxlbmd0aCk7CiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgfQogICAgcmV0dXJuIGJ1ZjsKICB9OwoKCiAgLy8gY29udmVydCBhcnJheSB0byBzdHJpbmcKICB2YXIgYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkgewogICAgdmFyIGksIG91dCwgYywgY19sZW47CiAgICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7CgogICAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKQogICAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yCiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LgogICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpOwoKICAgIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7CiAgICAgIGMgPSBidWZbaSsrXTsKICAgICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaQogICAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH0KCiAgICAgIGNfbGVuID0gX3V0ZjhsZW5bY107CiAgICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2RlcwogICAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9CgogICAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGUKICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3OwogICAgICAvLyBqb2luIHRoZSByZXN0CiAgICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikgewogICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpOwogICAgICAgIGNfbGVuLS07CiAgICAgIH0KCiAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz8KICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9CgogICAgICBpZiAoYyA8IDB4MTAwMDApIHsKICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjOwogICAgICB9IGVsc2UgewogICAgICAgIGMgLT0gMHgxMDAwMDsKICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpOwogICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7CiAgfTsKCgogIC8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsCiAgLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZQogIC8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuCiAgLy8KICAvLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXkKICAvLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTsKICB2YXIgdXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkgewogICAgdmFyIHBvczsKCiAgICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDsKICAgIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH0KCiAgICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmQKICAgIHBvcyA9IG1heCAtIDE7CiAgICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH0KCiAgICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsCiAgICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS4KICAgIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH0KCiAgICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCwKICAgIC8vIHJldHVybiBtYXggdG9vLgogICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9CgogICAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4OwogIH07CgogIHZhciBzdHJpbmdzID0gewogIAlzdHJpbmcyYnVmOiBzdHJpbmcyYnVmLAogIAlidWYyYmluc3RyaW5nOiBidWYyYmluc3RyaW5nXzEsCiAgCWJpbnN0cmluZzJidWY6IGJpbnN0cmluZzJidWYsCiAgCWJ1ZjJzdHJpbmc6IGJ1ZjJzdHJpbmcsCiAgCXV0Zjhib3JkZXI6IHV0Zjhib3JkZXIKICB9OwoKICAvLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIKICAvLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpbgogIC8vCiAgLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQKICAvLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMKICAvLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLgogIC8vCiAgLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsCiAgLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdAogIC8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczoKICAvLwogIC8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90CiAgLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZQogIC8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlCiAgLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLgogIC8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlCiAgLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuCiAgLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4KCiAgdmFyIGNvbnN0YW50cyA9IHsKCiAgICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovCiAgICBaX05PX0ZMVVNIOiAgICAgICAgIDAsCiAgICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsCiAgICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsCiAgICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsCiAgICBaX0ZJTklTSDogICAgICAgICAgIDQsCiAgICBaX0JMT0NLOiAgICAgICAgICAgIDUsCiAgICBaX1RSRUVTOiAgICAgICAgICAgIDYsCgogICAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlcwogICAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuCiAgICAqLwogICAgWl9PSzogICAgICAgICAgICAgICAwLAogICAgWl9TVFJFQU1fRU5EOiAgICAgICAxLAogICAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLAogICAgWl9FUlJOTzogICAgICAgICAgIC0xLAogICAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLAogICAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLAogICAgLy9aX01FTV9FUlJPUjogICAgIC00LAogICAgWl9CVUZfRVJST1I6ICAgICAgIC01LAogICAgLy9aX1ZFUlNJT05fRVJST1I6IC02LAoKICAgIC8qIGNvbXByZXNzaW9uIGxldmVscyAqLwogICAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLAogICAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLAogICAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LAogICAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLAoKCiAgICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsCiAgICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsCiAgICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsCiAgICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsCiAgICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsCgogICAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqLwogICAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLAogICAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLAogICAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZCkKICAgIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMiwKCiAgICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi8KICAgIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOAogICAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlCiAgfTsKCiAgLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyCiAgLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW4KICAvLwogIC8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkCiAgLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzCiAgLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4KICAvLwogIC8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLAogIC8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQKICAvLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6CiAgLy8KICAvLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdAogIC8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUKICAvLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZQogIC8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4KICAvLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZQogIC8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLgogIC8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uCgogIHZhciBtZXNzYWdlcyA9IHsKICAgIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqLwogICAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovCiAgICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi8KICAgICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqLwogICAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovCiAgICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi8KICAgICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqLwogICAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovCiAgICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi8KICB9OwoKICAvLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXIKICAvLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpbgogIC8vCiAgLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQKICAvLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMKICAvLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLgogIC8vCiAgLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsCiAgLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdAogIC8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczoKICAvLwogIC8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90CiAgLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZQogIC8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlCiAgLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLgogIC8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlCiAgLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuCiAgLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4KCiAgZnVuY3Rpb24gWlN0cmVhbSgpIHsKICAgIC8qIG5leHQgaW5wdXQgYnl0ZSAqLwogICAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnMKICAgIHRoaXMubmV4dF9pbiA9IDA7CiAgICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovCiAgICB0aGlzLmF2YWlsX2luID0gMDsKICAgIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqLwogICAgdGhpcy50b3RhbF9pbiA9IDA7CiAgICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi8KICAgIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVycwogICAgdGhpcy5uZXh0X291dCA9IDA7CiAgICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi8KICAgIHRoaXMuYXZhaWxfb3V0ID0gMDsKICAgIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovCiAgICB0aGlzLnRvdGFsX291dCA9IDA7CiAgICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi8KICAgIHRoaXMubXNnID0gJycvKlpfTlVMTCovOwogICAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovCiAgICB0aGlzLnN0YXRlID0gbnVsbDsKICAgIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi8KICAgIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87CiAgICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqLwogICAgdGhpcy5hZGxlciA9IDA7CiAgfQoKICB2YXIgenN0cmVhbSA9IFpTdHJlYW07CgogIC8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlcgogIC8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luCiAgLy8KICAvLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZAogIC8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcwogIC8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuCiAgLy8KICAvLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwKICAvLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0CiAgLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOgogIC8vCiAgLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QKICAvLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlCiAgLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUKICAvLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuCiAgLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUKICAvLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4KICAvLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLgoKICBmdW5jdGlvbiBHWmhlYWRlcigpIHsKICAgIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi8KICAgIHRoaXMudGV4dCAgICAgICA9IDA7CiAgICAvKiBtb2RpZmljYXRpb24gdGltZSAqLwogICAgdGhpcy50aW1lICAgICAgID0gMDsKICAgIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovCiAgICB0aGlzLnhmbGFncyAgICAgPSAwOwogICAgLyogb3BlcmF0aW5nIHN5c3RlbSAqLwogICAgdGhpcy5vcyAgICAgICAgID0gMDsKICAgIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi8KICAgIHRoaXMuZXh0cmEgICAgICA9IG51bGw7CiAgICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi8KICAgIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLAogICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zCgogICAgLy8KICAgIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkKICAgIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlcwogICAgLy8KCiAgICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqLwogICAgLy8gdGhpcy5leHRyYV9tYXggID0gMDsKICAgIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi8KICAgIHRoaXMubmFtZSAgICAgICA9ICcnOwogICAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqLwogICAgLy8gdGhpcy5uYW1lX21heCAgID0gMDsKICAgIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovCiAgICB0aGlzLmNvbW1lbnQgICAgPSAnJzsKICAgIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi8KICAgIC8vIHRoaXMuY29tbV9tYXggICA9IDA7CiAgICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqLwogICAgdGhpcy5oY3JjICAgICAgID0gMDsKICAgIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi8KICAgIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlOwogIH0KCiAgdmFyIGd6aGVhZGVyID0gR1poZWFkZXI7CgogIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CgogIC8qKgogICAqIGNsYXNzIEluZmxhdGUKICAgKgogICAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWQKICAgKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV0KICAgKiBhbmQgW1tpbmZsYXRlUmF3XV0uCiAgICoqLwoKICAvKiBpbnRlcm5hbAogICAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5CiAgICoKICAgKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi4KICAgKiovCgogIC8qKgogICAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nCiAgICoKICAgKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV0KICAgKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rCiAgICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdQogICAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aAogICAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS4KICAgKiovCgogIC8qKgogICAqIEluZmxhdGUuZXJyIC0+IE51bWJlcgogICAqCiAgICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLgogICAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLgogICAqKi8KCiAgLyoqCiAgICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nCiAgICoKICAgKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMAogICAqKi8KCgogIC8qKgogICAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpCiAgICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy4KICAgKgogICAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvbgogICAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOgogICAqCiAgICogLSBgd2luZG93Qml0c2AKICAgKiAtIGBkaWN0aW9uYXJ5YAogICAqCiAgICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKQogICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLgogICAqCiAgICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6CiAgICoKICAgKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KQogICAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGUKICAgKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWQKICAgKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLAogICAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuCiAgICoKICAgKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWEKICAgKiB3cmFwcGVyIGhlYWRlci4KICAgKgogICAqICMjIyMjIEV4YW1wbGU6CiAgICoKICAgKiBgYGBqYXZhc2NyaXB0CiAgICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJykKICAgKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKQogICAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pOwogICAqCiAgICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTsKICAgKgogICAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTsKICAgKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVuawogICAqCiAgICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH0KICAgKgogICAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTsKICAgKiBgYGAKICAgKiovCiAgZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7CiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTsKCiAgICB0aGlzLm9wdGlvbnMgPSBjb21tb24uYXNzaWduKHsKICAgICAgY2h1bmtTaXplOiAxNjM4NCwKICAgICAgd2luZG93Qml0czogMCwKICAgICAgdG86ICcnCiAgICB9LCBvcHRpb25zIHx8IHt9KTsKCiAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zOwoKICAgIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LAogICAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC4KICAgIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHsKICAgICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7CiAgICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfQogICAgfQoKICAgIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGUKICAgIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmCiAgICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHsKICAgICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7CiAgICB9CgogICAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5CiAgICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGUKICAgIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7CiAgICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhCiAgICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGUKICAgICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkgewogICAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1OwogICAgICB9CiAgICB9CgogICAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKQogICAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2UKICAgIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHMKICAgIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhCgogICAgdGhpcy5zdHJtICAgPSBuZXcgenN0cmVhbSgpOwogICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7CgogICAgdmFyIHN0YXR1cyAgPSBpbmZsYXRlXzEuaW5mbGF0ZUluaXQyKAogICAgICB0aGlzLnN0cm0sCiAgICAgIG9wdC53aW5kb3dCaXRzCiAgICApOwoKICAgIGlmIChzdGF0dXMgIT09IGNvbnN0YW50cy5aX09LKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTsKICAgIH0KCiAgICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpOwoKICAgIGluZmxhdGVfMS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpOwoKICAgIC8vIFNldHVwIGRpY3Rpb25hcnkKICAgIGlmIChvcHQuZGljdGlvbmFyeSkgewogICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkCiAgICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpOwogICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7CiAgICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7CiAgICAgIH0KICAgICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseQogICAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTsKICAgICAgICBpZiAoc3RhdHVzICE9PSBjb25zdGFudHMuWl9PSykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KCiAgLyoqCiAgICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhbgogICAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhCiAgICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLgogICAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC4KICAgKgogICAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoCiAgICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlCiAgICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbAogICAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3UKICAgKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuCiAgICoKICAgKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuCiAgICoKICAgKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0CiAgICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5cwogICAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC4KICAgKgogICAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS4KICAgKgogICAqICMjIyMjIEV4YW1wbGUKICAgKgogICAqIGBgYGphdmFzY3JpcHQKICAgKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzCiAgICogLi4uCiAgICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmsKICAgKiBgYGAKICAgKiovCiAgSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7CiAgICB2YXIgc3RybSA9IHRoaXMuc3RybTsKICAgIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplOwogICAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTsKICAgIHZhciBzdGF0dXMsIF9tb2RlOwogICAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7CgogICAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsCiAgICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLgogICAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTsKCiAgICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH0KICAgIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGNvbnN0YW50cy5aX0ZJTklTSCA6IGNvbnN0YW50cy5aX05PX0ZMVVNIKTsKCiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkCiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7CiAgICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZQogICAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpOwogICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7CiAgICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTsKICAgIH0gZWxzZSB7CiAgICAgIHN0cm0uaW5wdXQgPSBkYXRhOwogICAgfQoKICAgIHN0cm0ubmV4dF9pbiA9IDA7CiAgICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7CgogICAgZG8gewogICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHsKICAgICAgICBzdHJtLm91dHB1dCA9IG5ldyBjb21tb24uQnVmOChjaHVua1NpemUpOwogICAgICAgIHN0cm0ubmV4dF9vdXQgPSAwOwogICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplOwogICAgICB9CgogICAgICBzdGF0dXMgPSBpbmZsYXRlXzEuaW5mbGF0ZShzdHJtLCBjb25zdGFudHMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi8KCiAgICAgIGlmIChzdGF0dXMgPT09IGNvbnN0YW50cy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7CiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7CiAgICAgIH0KCiAgICAgIGlmIChzdGF0dXMgPT09IGNvbnN0YW50cy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7CiAgICAgICAgc3RhdHVzID0gY29uc3RhbnRzLlpfT0s7CiAgICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlOwogICAgICB9CgogICAgICBpZiAoc3RhdHVzICE9PSBjb25zdGFudHMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gY29uc3RhbnRzLlpfT0spIHsKICAgICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7CiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAoc3RybS5uZXh0X291dCkgewogICAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGNvbnN0YW50cy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjb25zdGFudHMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGNvbnN0YW50cy5aX1NZTkNfRkxVU0gpKSkgewoKICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7CgogICAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTsKCiAgICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODsKICAgICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7CgogICAgICAgICAgICAvLyBtb3ZlIHRhaWwKICAgICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7CiAgICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDsKICAgICAgICAgICAgaWYgKHRhaWwpIHsgY29tbW9uLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH0KCiAgICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpOwoKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMub25EYXRhKGNvbW1vbi5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnMKICAgICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmUKICAgICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuCiAgICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LgogICAgICAvLwogICAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2gKICAgICAgLy8gbG9naWMuCiAgICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7CiAgICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7CiAgICAgIH0KCiAgICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gY29uc3RhbnRzLlpfU1RSRUFNX0VORCk7CgogICAgaWYgKHN0YXR1cyA9PT0gY29uc3RhbnRzLlpfU1RSRUFNX0VORCkgewogICAgICBfbW9kZSA9IGNvbnN0YW50cy5aX0ZJTklTSDsKICAgIH0KCiAgICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay4KICAgIGlmIChfbW9kZSA9PT0gY29uc3RhbnRzLlpfRklOSVNIKSB7CiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7CiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTsKICAgICAgdGhpcy5lbmRlZCA9IHRydWU7CiAgICAgIHJldHVybiBzdGF0dXMgPT09IGNvbnN0YW50cy5aX09LOwogICAgfQoKICAgIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guCiAgICBpZiAoX21vZGUgPT09IGNvbnN0YW50cy5aX1NZTkNfRkxVU0gpIHsKICAgICAgdGhpcy5vbkVuZChjb25zdGFudHMuWl9PSyk7CiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gMDsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIHRydWU7CiAgfTsKCgogIC8qKgogICAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkCiAgICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzCiAgICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVuawogICAqICAgd2lsbCBiZSBzdHJpbmcuCiAgICoKICAgKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZQogICAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuCiAgICoqLwogIEluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykgewogICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7CiAgfTsKCgogIC8qKgogICAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkCiAgICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLAogICAqICAgb3RoZXIgaWYgbm90LgogICAqCiAgICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpcwogICAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSCkKICAgKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcywKICAgKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLgogICAqKi8KICBJbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHsKICAgIC8vIE9uIHN1Y2Nlc3MgLSBqb2luCiAgICBpZiAoc3RhdHVzID09PSBjb25zdGFudHMuWl9PSykgewogICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykgewogICAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZAogICAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YQogICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7CiAgICAgIH0KICAgIH0KICAgIHRoaXMuY2h1bmtzID0gW107CiAgICB0aGlzLmVyciA9IHN0YXR1czsKICAgIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZzsKICB9OwoKCiAgLyoqCiAgICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nCiAgICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy4KICAgKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLgogICAqCiAgICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0CiAgICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGUKICAgKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuCiAgICoKICAgKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6CiAgICoKICAgKiAtIHdpbmRvd0JpdHMKICAgKgogICAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZCkKICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KICAgKgogICAqIFN1Z2FyIChvcHRpb25zKToKICAgKgogICAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnkKICAgKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS4KICAgKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWQKICAgKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLAogICAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuCiAgICoKICAgKgogICAqICMjIyMjIEV4YW1wbGU6CiAgICoKICAgKiBgYGBqYXZhc2NyaXB0CiAgICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJykKICAgKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSkKICAgKiAgICwgb3V0cHV0OwogICAqCiAgICogdHJ5IHsKICAgKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7CiAgICogfSBjYXRjaCAoZXJyKQogICAqICAgY29uc29sZS5sb2coZXJyKTsKICAgKiB9CiAgICogYGBgCiAgICoqLwogIGZ1bmN0aW9uIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucykgewogICAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7CgogICAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7CgogICAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOikKICAgIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2luZmxhdG9yLmVycl07IH0KCiAgICByZXR1cm4gaW5mbGF0b3IucmVzdWx0OwogIH0KICB2YXIgaW5mbGF0ZV8yJDEgPSBpbmZsYXRlJDE7CgogIGNsYXNzIERlZmxhdGVEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIgewogICAgZGVjb2RlQmxvY2soYnVmZmVyKSB7CiAgICAgIHJldHVybiBpbmZsYXRlXzIkMShuZXcgVWludDhBcnJheShidWZmZXIpKS5idWZmZXI7CiAgICB9CiAgfQoKICBjbGFzcyBQYWNrYml0c0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7CiAgICBkZWNvZGVCbG9jayhidWZmZXIpIHsKICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTsKICAgICAgY29uc3Qgb3V0ID0gW107CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyArK2kpIHsKICAgICAgICBsZXQgaGVhZGVyID0gZGF0YVZpZXcuZ2V0SW50OChpKTsKICAgICAgICBpZiAoaGVhZGVyIDwgMCkgewogICAgICAgICAgY29uc3QgbmV4dCA9IGRhdGFWaWV3LmdldFVpbnQ4KGkgKyAxKTsKICAgICAgICAgIGhlYWRlciA9IC1oZWFkZXI7CiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBoZWFkZXI7ICsraikgewogICAgICAgICAgICBvdXQucHVzaChuZXh0KTsKICAgICAgICAgIH0KICAgICAgICAgIGkgKz0gMTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaGVhZGVyOyArK2opIHsKICAgICAgICAgICAgb3V0LnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSArIGogKyAxKSk7CiAgICAgICAgICB9CiAgICAgICAgICBpICs9IGhlYWRlciArIDE7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShvdXQpLmJ1ZmZlcjsKICAgIH0KICB9CgogIGZ1bmN0aW9uIGdldERlY29kZXIoZmlsZURpcmVjdG9yeSkgewogICAgc3dpdGNoIChmaWxlRGlyZWN0b3J5LkNvbXByZXNzaW9uKSB7CiAgICAgIGNhc2UgdW5kZWZpbmVkOgogICAgICBjYXNlIDE6IC8vIG5vIGNvbXByZXNzaW9uCiAgICAgICAgcmV0dXJuIG5ldyBSYXdEZWNvZGVyKCk7CiAgICAgIGNhc2UgNTogLy8gTFpXCiAgICAgICAgcmV0dXJuIG5ldyBMWldEZWNvZGVyKGZpbGVEaXJlY3RvcnkpOwogICAgICBjYXNlIDY6IC8vIEpQRUcKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29sZCBzdHlsZSBKUEVHIGNvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7CiAgICAgIGNhc2UgNzogLy8gSlBFRwogICAgICAgIHJldHVybiBuZXcgSnBlZ0RlY29kZXIoZmlsZURpcmVjdG9yeSk7CiAgICAgIGNhc2UgODogLy8gRGVmbGF0ZSBhcyByZWNvZ25pemVkIGJ5IEFkb2JlCiAgICAgIGNhc2UgMzI5NDY6IC8vIERlZmxhdGUgR0RBTCBkZWZhdWx0CiAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlRGVjb2RlcigpOwogICAgICBjYXNlIDMyNzczOiAvLyBwYWNrYml0cwogICAgICAgIHJldHVybiBuZXcgUGFja2JpdHNEZWNvZGVyKCk7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiAke2ZpbGVEaXJlY3RvcnkuQ29tcHJlc3Npb259YCk7CiAgICB9CiAgfQoKICBmdW5jdGlvbiBnZXRUaWZmRGVjb2RlcihmaWxlRGlyZWN0b3J5KSB7CiAgICByZXR1cm4gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KTsKICB9CgogIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqLwoKICBhc3luYyBmdW5jdGlvbiBkZWNvZGUoc2VsZiwgZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7CiAgICBjb25zdCBkZWNvZGVyID0gZ2V0VGlmZkRlY29kZXIoZmlsZURpcmVjdG9yeSk7CiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpOwogICAgc2VsZi5wb3N0TWVzc2FnZShbcmVzdWx0XSwgW3Jlc3VsdF0pOwogIH0KCiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgewogICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZXZlbnQgPT4gewogICAgICBjb25zdCBbbmFtZSwgLi4uYXJnc10gPSBldmVudC5kYXRhOwogICAgICBzd2l0Y2ggKG5hbWUpIHsKICAgICAgICBjYXNlICdkZWNvZGUnOgogICAgICAgICAgZGVjb2RlKHNlbGYsIC4uLmFyZ3MpOwogICAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0pOwogIH0KCn0oKSk7Cgo=', 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidml2Lndvcmtlci5qcyIsInNvdXJjZXMiOlsid29ya2VyOi8vd2ViLXdvcmtlci9ub2RlX21vZHVsZXMvZ2VvdGlmZi9zcmMvcHJlZGljdG9yLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9ub2RlX21vZHVsZXMvZ2VvdGlmZi9zcmMvY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9nZW90aWZmL3NyYy9jb21wcmVzc2lvbi9yYXcuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9senctdGlmZi1kZWNvZGVyL2luZGV4Lm1qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL2NvbXByZXNzaW9uL2x6dy5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL2NvbXByZXNzaW9uL2pwZWcuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL2NvbXByZXNzaW9uL2RlZmxhdGUuanMiLCJ3b3JrZXI6Ly93ZWItd29ya2VyL25vZGVfbW9kdWxlcy9nZW90aWZmL3NyYy9jb21wcmVzc2lvbi9wYWNrYml0cy5qcyIsIndvcmtlcjovL3dlYi13b3JrZXIvbm9kZV9tb2R1bGVzL2dlb3RpZmYvc3JjL2NvbXByZXNzaW9uL2luZGV4LmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9zcmMvbG9hZGVycy9kZWNvZGVyLmpzIiwid29ya2VyOi8vd2ViLXdvcmtlci9zcmMvbG9hZGVycy92aXYud29ya2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuZnVuY3Rpb24gZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlKSB7XG4gIGxldCBsZW5ndGggPSByb3cubGVuZ3RoIC0gc3RyaWRlO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZG8ge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHJvd1tvZmZzZXQgKyBzdHJpZGVdICs9IHJvd1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgbGVuZ3RoIC09IHN0cmlkZTtcbiAgfSB3aGlsZSAobGVuZ3RoID4gMCk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjb3VudCA9IHJvdy5sZW5ndGg7XG4gIGNvbnN0IHdjID0gY291bnQgLyBieXRlc1BlclNhbXBsZTtcblxuICB3aGlsZSAoY291bnQgPiBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgLS1pKSB7XG4gICAgICByb3dbaW5kZXggKyBzdHJpZGVdICs9IHJvd1tpbmRleF07XG4gICAgICArK2luZGV4O1xuICAgIH1cbiAgICBjb3VudCAtPSBzdHJpZGU7XG4gIH1cblxuICBjb25zdCBjb3B5ID0gcm93LnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYnl0ZXNQZXJTYW1wbGU7ICsrYikge1xuICAgICAgcm93WyhieXRlc1BlclNhbXBsZSAqIGkpICsgYl0gPSBjb3B5WygoYnl0ZXNQZXJTYW1wbGUgLSBiIC0gMSkgKiB3YykgKyBpXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UHJlZGljdG9yKGJsb2NrLCBwcmVkaWN0b3IsIHdpZHRoLCBoZWlnaHQsIGJpdHNQZXJTYW1wbGUsXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCFwcmVkaWN0b3IgfHwgcHJlZGljdG9yID09PSAxKSB7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIG9ubHkgbXVsdGlwbGUgb2YgOCBiaXRzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICE9PSBiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZVswXSAvIDg7XG4gIGNvbnN0IHN0cmlkZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIgPyAxIDogYml0c1BlclNhbXBsZS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuICAgIC8vIExhc3Qgc3RyaXAgd2lsbCBiZSB0cnVuY2F0ZWQgaWYgaGVpZ2h0ICUgc3RyaXBIZWlnaHQgIT0gMFxuICAgIGlmIChpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSA+PSBibG9jay5ieXRlTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHJvdztcbiAgICBpZiAocHJlZGljdG9yID09PSAyKSB7IC8vIGhvcml6b250YWwgcHJlZGljdGlvblxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyA0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVkaWN0b3IgMiBub3QgYWxsb3dlZCB3aXRoICR7Yml0c1BlclNhbXBsZVswXX0gYml0cyBwZXIgc2FtcGxlLmApO1xuICAgICAgfVxuICAgICAgZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfSBlbHNlIGlmIChwcmVkaWN0b3IgPT09IDMpIHsgLy8gaG9yaXpvbnRhbCBmbG9hdGluZyBwb2ludFxuICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICk7XG4gICAgICBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9jaztcbn1cbiIsImltcG9ydCB7IGFwcGx5UHJlZGljdG9yIH0gZnJvbSAnLi4vcHJlZGljdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURlY29kZXIge1xuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IHRoaXMuZGVjb2RlQmxvY2soYnVmZmVyKTtcbiAgICBjb25zdCBwcmVkaWN0b3IgPSBmaWxlRGlyZWN0b3J5LlByZWRpY3RvciB8fCAxO1xuICAgIGlmIChwcmVkaWN0b3IgIT09IDEpIHtcbiAgICAgIGNvbnN0IGlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgICBjb25zdCB0aWxlV2lkdGggPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggOiBmaWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7XG4gICAgICBjb25zdCB0aWxlSGVpZ2h0ID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aCA6IChcbiAgICAgICAgZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAgfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhcHBseVByZWRpY3RvcihcbiAgICAgICAgZGVjb2RlZCwgcHJlZGljdG9yLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSxcbiAgICAgICAgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYXdEZWNvZGVyIGV4dGVuZHMgQmFzZURlY29kZXIge1xuICBkZWNvZGVCbG9jayhidWZmZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG4iLCJsZXQgQSxJPW51bGw7ZnVuY3Rpb24gZygpe3JldHVybiBudWxsIT09SSYmSS5idWZmZXI9PT1BLm1lbW9yeS5idWZmZXJ8fChJPW5ldyBVaW50OEFycmF5KEEubWVtb3J5LmJ1ZmZlcikpLEl9bGV0IEI9MDtsZXQgUT1udWxsO2Z1bmN0aW9uIEMoKXtyZXR1cm4gbnVsbCE9PVEmJlEuYnVmZmVyPT09QS5tZW1vcnkuYnVmZmVyfHwoUT1uZXcgSW50MzJBcnJheShBLm1lbW9yeS5idWZmZXIpKSxRfWFzeW5jIGZ1bmN0aW9uIEUoSSl7dm9pZCAwPT09SSYmKEk9XCJcIi5yZXBsYWNlKC9cXC5qcyQvLFwiX2JnLndhc21cIikpOyhcInN0cmluZ1wiPT10eXBlb2YgSXx8XCJmdW5jdGlvblwiPT10eXBlb2YgUmVxdWVzdCYmSSBpbnN0YW5jZW9mIFJlcXVlc3R8fFwiZnVuY3Rpb25cIj09dHlwZW9mIFVSTCYmSSBpbnN0YW5jZW9mIFVSTCkmJihJPWZldGNoKEkpKTtjb25zdHtpbnN0YW5jZTpnLG1vZHVsZTpCfT1hd2FpdCBhc3luYyBmdW5jdGlvbihBLEkpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFJlc3BvbnNlJiZBIGluc3RhbmNlb2YgUmVzcG9uc2Upe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKXRyeXtyZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQSxJKX1jYXRjaChJKXtpZihcImFwcGxpY2F0aW9uL3dhc21cIj09QS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSl0aHJvdyBJO2NvbnNvbGUud2FybihcImBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ2AgZmFpbGVkIGJlY2F1c2UgeW91ciBzZXJ2ZXIgZG9lcyBub3Qgc2VydmUgd2FzbSB3aXRoIGBhcHBsaWNhdGlvbi93YXNtYCBNSU1FIHR5cGUuIEZhbGxpbmcgYmFjayB0byBgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVgIHdoaWNoIGlzIHNsb3dlci4gT3JpZ2luYWwgZXJyb3I6XFxuXCIsSSl9Y29uc3QgZz1hd2FpdCBBLmFycmF5QnVmZmVyKCk7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGcsSSl9e2NvbnN0IGc9YXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQSxJKTtyZXR1cm4gZyBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lkluc3RhbmNlP3tpbnN0YW5jZTpnLG1vZHVsZTpBfTpnfX0oYXdhaXQgSSx7fSk7cmV0dXJuIEE9Zy5leHBvcnRzLEUuX193YmluZGdlbl93YXNtX21vZHVsZT1CLEF9dmFyIEQ9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVjb21wcmVzczpmdW5jdGlvbihJLFEpe3RyeXtjb25zdCBOPUEuX193YmluZGdlbl9leHBvcnRfMC52YWx1ZS0xNjtBLl9fd2JpbmRnZW5fZXhwb3J0XzAudmFsdWU9Tjt2YXIgRT1mdW5jdGlvbihBLEkpe2NvbnN0IFE9SSgxKkEubGVuZ3RoKTtyZXR1cm4gZygpLnNldChBLFEvMSksQj1BLmxlbmd0aCxRfShJLEEuX193YmluZGdlbl9tYWxsb2MpLEQ9QjtBLmRlY29tcHJlc3MoTixFLEQsUSk7dmFyIHc9QygpW04vNCswXSxpPUMoKVtOLzQrMV0sbz0oRz13LEY9aSxnKCkuc3ViYXJyYXkoRy8xLEcvMStGKSkuc2xpY2UoKTtyZXR1cm4gQS5fX3diaW5kZ2VuX2ZyZWUodywxKmkpLG99ZmluYWxseXtBLl9fd2JpbmRnZW5fZXhwb3J0XzAudmFsdWUrPTE2fXZhciBHLEZ9LGRlZmF1bHQ6RX0pO2NvbnN0IHc9WzYyLDAsMCwwLDYzLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwwLDAsMCwwLDAsMCwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MV07ZnVuY3Rpb24gaShBKXtyZXR1cm4gd1tBLTQzXX1jb25zdCBvPWZ1bmN0aW9uKEEpe2xldCBJLGc9QS5lbmRzV2l0aChcIj09XCIpPzI6QS5lbmRzV2l0aChcIj1cIik/MTowLEI9QS5sZW5ndGgsUT1uZXcgVWludDhBcnJheShCLzQqMyk7Zm9yKGxldCBnPTAsQz0wO2c8QjtnKz00LEMrPTMpST1pKEEuY2hhckNvZGVBdChnKSk8PDE4fGkoQS5jaGFyQ29kZUF0KGcrMSkpPDwxMnxpKEEuY2hhckNvZGVBdChnKzIpKTw8NnxpKEEuY2hhckNvZGVBdChnKzMpKSxRW0NdPUk+PjE2LFFbQysxXT1JPj44JjI1NSxRW0MrMl09MjU1Jkk7cmV0dXJuIFEuc3ViYXJyYXkoMCxRLmxlbmd0aC1nKX0oXCJBR0Z6YlFFQUFBQUJXUTVnQW45L0FYOWdBMzkvZndGL1lBSi9md0JnQVg4QVlBTi9mMzhBWUFGL0FYOWdCSDkvZjM4QVlBUi9mMzkvQVg5Z0JuOS9mMzkvZndCZ0FYOEJmbUFBQUdBRmYzOS9mMzhBWUFWL2YzOS9md0YvWUFKK2Z3Ri9BMmhuQlFnSUN3TUJBZ1VNQVFBQkFBSUFCUUFDQWdZTkJnTUNBQVlDQUFBRUJBSUVBZ1FHQUFZQkJnSUhBd1FFQkFBREF3TUZBd01FQkFRRUJBSUNBQWNBQkFBQ0F3RUNCd1VFQXdFRkFnSURBZ01DQWdNREJ3SUFBQVFCQUFvQUFBRUNBQU1GQ1FrREFnUUZBWEFCSnljRkF3RUFFUVlKQVg4QlFZQ0F3QUFMQjFNRkJtMWxiVzl5ZVFJQUNtUmxZMjl0Y0hKbGMzTUFKeE5mWDNkaWFXNWtaMlZ1WDJWNGNHOXlkRjh3QXdBUlgxOTNZbWx1WkdkbGJsOXRZV3hzYjJNQVNnOWZYM2RpYVc1a1oyVnVYMlp5WldVQVZRa3NBUUJCQVFzbVpTUTBBbUpoUWpRQlltRkNabVZaRER4alV4b2hVbVJkV2k0T1hGWmxZd3NjUUY0YlBtQUtzK1FCWjVncUFnaC9BWDRDUUFKQUFrQUNRQUpBSUFCQjlRRlBCRUFnQUVITi8zdFBEUVFnQUVFTGFpSUFRWGh4SVFWQjJLWEFBQ2dDQUNJSVJRMEJRUUFnQldzaEJnSkFBa0FDZjBFQUlBQkJDSFlpQUVVTkFCcEJIeUFGUWYvLy93ZExEUUFhSUFWQkJpQUFaeUlBYTBFZmNYWkJBWEVnQUVFQmRHdEJQbW9MSWdkQkFuUkI1S2ZBQUdvb0FnQWlBQVJBSUFWQkFFRVpJQWRCQVhaclFSOXhJQWRCSDBZYmRDRUNBMEFDUUNBQVFRUnFLQUlBUVhoeElnUWdCVWtOQUNBRUlBVnJJZ1FnQms4TkFDQUFJUU1nQkNJR0RRQkJBQ0VHREFNTElBQkJGR29vQWdBaUJDQUJJQVFnQUNBQ1FSMTJRUVJ4YWtFUWFpZ0NBQ0lBUnhzZ0FTQUVHeUVCSUFKQkFYUWhBaUFBRFFBTElBRUVRQ0FCSVFBTUFnc2dBdzBDQzBFQUlRTkJBaUFIUVI5eGRDSUFRUUFnQUd0eUlBaHhJZ0JGRFFNZ0FFRUFJQUJyY1doQkFuUkI1S2ZBQUdvb0FnQWlBRVVOQXdzRFFDQUFJQU1nQUVFRWFpZ0NBRUY0Y1NJQklBVlBJQUVnQldzaUFTQUdTWEVpQWhzaEF5QUJJQVlnQWhzaEJpQUFLQUlRSWdFRWZ5QUJCU0FBUVJScUtBSUFDeUlBRFFBTElBTkZEUUlMUWVTb3dBQW9BZ0FpQUNBRlQwRUFJQVlnQUNBRmEwOGJEUUVnQXlnQ0dDRUhBa0FDUUNBRElBTW9BZ3dpQVVZRVFDQURRUlJCRUNBRFFSUnFJZ0VvQWdBaUFodHFLQUlBSWdBTkFVRUFJUUVNQWdzZ0F5Z0NDQ0lBSUFFMkFnd2dBU0FBTmdJSURBRUxJQUVnQTBFUWFpQUNHeUVDQTBBZ0FpRUVJQUFpQVVFVWFpSUNLQUlBSWdCRkJFQWdBVUVRYWlFQ0lBRW9BaEFoQUFzZ0FBMEFDeUFFUVFBMkFnQUxBa0FnQjBVTkFBSkFJQU1nQXlnQ0hFRUNkRUhrcDhBQWFpSUFLQUlBUndSQUlBZEJFRUVVSUFjb0FoQWdBMFliYWlBQk5nSUFJQUZGRFFJTUFRc2dBQ0FCTmdJQUlBRU5BRUhZcGNBQVFkaWx3QUFvQWdCQmZpQURLQUljZDNFMkFnQU1BUXNnQVNBSE5nSVlJQU1vQWhBaUFBUkFJQUVnQURZQ0VDQUFJQUUyQWhnTElBTkJGR29vQWdBaUFFVU5BQ0FCUVJScUlBQTJBZ0FnQUNBQk5nSVlDd0pBSUFaQkVFOEVRQ0FESUFWQkEzSTJBZ1FnQXlBRmFpSUVJQVpCQVhJMkFnUWdCQ0FHYWlBR05nSUFJQVpCZ0FKUEJFQWdCRUlBTndJUUlBUUNmMEVBSUFaQkNIWWlBRVVOQUJwQkh5QUdRZi8vL3dkTERRQWFJQVpCQmlBQVp5SUFhMEVmY1haQkFYRWdBRUVCZEd0QlBtb0xJZ0EyQWh3Z0FFRUNkRUhrcDhBQWFpRUJBa0FDUUFKQUFrQkIyS1hBQUNnQ0FDSUNRUUVnQUVFZmNYUWlCWEVFUUNBQktBSUFJZ0pCQkdvb0FnQkJlSEVnQmtjTkFTQUNJUUFNQWd0QjJLWEFBQ0FDSUFWeU5nSUFJQUVnQkRZQ0FDQUVJQUUyQWhnTUF3c2dCa0VBUVJrZ0FFRUJkbXRCSDNFZ0FFRWZSaHQwSVFFRFFDQUNJQUZCSFhaQkJIRnFRUkJxSWdVb0FnQWlBRVVOQWlBQlFRRjBJUUVnQUNFQ0lBQkJCR29vQWdCQmVIRWdCa2NOQUFzTElBQW9BZ2dpQVNBRU5nSU1JQUFnQkRZQ0NDQUVRUUEyQWhnZ0JDQUFOZ0lNSUFRZ0FUWUNDQXdFQ3lBRklBUTJBZ0FnQkNBQ05nSVlDeUFFSUFRMkFnd2dCQ0FFTmdJSURBSUxJQVpCQTNZaUFVRURkRUhjcGNBQWFpRUFBbjlCMUtYQUFDZ0NBQ0lDUVFFZ0FYUWlBWEVFUUNBQUtBSUlEQUVMUWRTbHdBQWdBU0FDY2pZQ0FDQUFDeUVCSUFBZ0JEWUNDQ0FCSUFRMkFnd2dCQ0FBTmdJTUlBUWdBVFlDQ0F3QkN5QURJQVVnQm1vaUFFRURjallDQkNBQUlBTnFJZ0FnQUNnQ0JFRUJjallDQkFzZ0EwRUlhZzhMQWtBQ1FFSFVwY0FBS0FJQUlnSkJFQ0FBUVF0cVFYaHhJQUJCQzBrYklnVkJBM1lpQUhZaUFVRURjVVVFUUNBRlFlU293QUFvQWdCTkRRTWdBUTBCUWRpbHdBQW9BZ0FpQUVVTkF5QUFRUUFnQUd0eGFFRUNkRUhrcDhBQWFpZ0NBQ0lCUVFScUtBSUFRWGh4SUFWcklRWWdBU0VDQTBBZ0FTZ0NFQ0lBUlFSQUlBRkJGR29vQWdBaUFFVU5CQXNnQUVFRWFpZ0NBRUY0Y1NBRmF5SUJJQVlnQVNBR1NTSUJHeUVHSUFBZ0FpQUJHeUVDSUFBaEFRd0FDd0FMQWtBZ0FVRi9jMEVCY1NBQWFpSUFRUU4wUWRTbHdBQnFJZ1JCRUdvb0FnQWlBVUVJYWlJR0tBSUFJZ01nQkVFSWFpSUVSd1JBSUFNZ0JEWUNEQ0FFSUFNMkFnZ01BUXRCMUtYQUFDQUNRWDRnQUhkeE5nSUFDeUFCSUFCQkEzUWlBRUVEY2pZQ0JDQUFJQUZxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0ZDd0pBUVFJZ0FIUWlCa0VBSUFacmNpQUJJQUIwY1NJQVFRQWdBR3R4YUNJQlFRTjBRZFNsd0FCcUlnTkJFR29vQWdBaUFFRUlhaUlFS0FJQUlnWWdBMEVJYWlJRFJ3UkFJQVlnQXpZQ0RDQURJQVkyQWdnTUFRdEIxS1hBQUNBQ1FYNGdBWGR4TmdJQUN5QUFJQVZCQTNJMkFnUWdBQ0FGYWlJRElBRkJBM1FpQVNBRmF5SUNRUUZ5TmdJRUlBQWdBV29nQWpZQ0FFSGtxTUFBS0FJQUlnQUVRQ0FBUVFOMklnWkJBM1JCM0tYQUFHb2hBRUhzcU1BQUtBSUFJUUVDZjBIVXBjQUFLQUlBSWdWQkFTQUdRUjl4ZENJR2NRUkFJQUFvQWdnTUFRdEIxS1hBQUNBRklBWnlOZ0lBSUFBTElRWWdBQ0FCTmdJSUlBWWdBVFlDRENBQklBQTJBZ3dnQVNBR05nSUlDMEhzcU1BQUlBTTJBZ0JCNUtqQUFDQUNOZ0lBSUFRUEN5QUNLQUlZSVFjQ1FBSkFJQUlnQWlnQ0RDSUJSZ1JBSUFKQkZFRVFJQUpCRkdvaUFTZ0NBQ0lERzJvb0FnQWlBQTBCUVFBaEFRd0NDeUFDS0FJSUlnQWdBVFlDRENBQklBQTJBZ2dNQVFzZ0FTQUNRUkJxSUFNYklRTURRQ0FESVFRZ0FDSUJRUlJxSWdNb0FnQWlBRVVFUUNBQlFSQnFJUU1nQVNnQ0VDRUFDeUFBRFFBTElBUkJBRFlDQUFzZ0IwVU5BaUFDSUFJb0FoeEJBblJCNUtmQUFHb2lBQ2dDQUVjRVFDQUhRUkJCRkNBSEtBSVFJQUpHRzJvZ0FUWUNBQ0FCUlEwRERBSUxJQUFnQVRZQ0FDQUJEUUZCMktYQUFFSFlwY0FBS0FJQVFYNGdBaWdDSEhkeE5nSUFEQUlMQWtBQ1FBSkFBa0JCNUtqQUFDZ0NBQ0lBSUFWSkJFQkI2S2pBQUNnQ0FDSUFJQVZMRFFoQkFDRUdJQVZCcjRBRWFpSUFRUkIyUUFBaUFVRi9SZzBISUFGQkVIUWlCRVVOQjBIMHFNQUFJQUJCZ0lCOGNTSUhRZlNvd0FBb0FnQnFJZ0EyQWdCQitLakFBRUg0cU1BQUtBSUFJZ0VnQUNBQklBQkxHellDQUVId3FNQUFLQUlBSWdORkRRRkIvS2pBQUNFQUEwQWdBQ2dDQUNJQklBQW9BZ1FpQW1vZ0JFWU5BeUFBS0FJSUlnQU5BQXNNQXd0QjdLakFBQ2dDQUNFQkFuOGdBQ0FGYXlJQ1FROU5CRUJCN0tqQUFFRUFOZ0lBUWVTb3dBQkJBRFlDQUNBQklBQkJBM0kyQWdRZ0FDQUJhaUlDUVFScUlRQWdBaWdDQkVFQmNnd0JDMEhrcU1BQUlBSTJBZ0JCN0tqQUFDQUJJQVZxSWdZMkFnQWdCaUFDUVFGeU5nSUVJQUFnQVdvZ0FqWUNBQ0FCUVFScUlRQWdCVUVEY2dzaEFpQUFJQUkyQWdBZ0FVRUlhZzhMUVpDcHdBQW9BZ0FpQUVFQUlBQWdCRTBiUlFSQVFaQ3B3QUFnQkRZQ0FBdEJsS25BQUVIL0h6WUNBRUg4cU1BQUlBUTJBZ0JCaUtuQUFFRUFOZ0lBUVlDcHdBQWdCellDQUVIb3BjQUFRZHlsd0FBMkFnQkI4S1hBQUVIa3BjQUFOZ0lBUWVTbHdBQkIzS1hBQURZQ0FFSDRwY0FBUWV5bHdBQTJBZ0JCN0tYQUFFSGtwY0FBTmdJQVFZQ213QUJCOUtYQUFEWUNBRUgwcGNBQVFleWx3QUEyQWdCQmlLYkFBRUg4cGNBQU5nSUFRZnlsd0FCQjlLWEFBRFlDQUVHUXBzQUFRWVNtd0FBMkFnQkJoS2JBQUVIOHBjQUFOZ0lBUVppbXdBQkJqS2JBQURZQ0FFR01wc0FBUVlTbXdBQTJBZ0JCb0tiQUFFR1Vwc0FBTmdJQVFaU213QUJCaktiQUFEWUNBRUdvcHNBQVFaeW13QUEyQWdCQm5LYkFBRUdVcHNBQU5nSUFRYVNtd0FCQm5LYkFBRFlDQUVHd3BzQUFRYVNtd0FBMkFnQkJyS2JBQUVHa3BzQUFOZ0lBUWJpbXdBQkJyS2JBQURZQ0FFRzBwc0FBUWF5bXdBQTJBZ0JCd0tiQUFFRzBwc0FBTmdJQVFieW13QUJCdEtiQUFEWUNBRUhJcHNBQVFieW13QUEyQWdCQnhLYkFBRUc4cHNBQU5nSUFRZENtd0FCQnhLYkFBRFlDQUVITXBzQUFRY1Ntd0FBMkFnQkIyS2JBQUVITXBzQUFOZ0lBUWRTbXdBQkJ6S2JBQURZQ0FFSGdwc0FBUWRTbXdBQTJBZ0JCM0tiQUFFSFVwc0FBTmdJQVFlaW13QUJCM0tiQUFEWUNBRUh3cHNBQVFlU213QUEyQWdCQjVLYkFBRUhjcHNBQU5nSUFRZmltd0FCQjdLYkFBRFlDQUVIc3BzQUFRZVNtd0FBMkFnQkJnS2ZBQUVIMHBzQUFOZ0lBUWZTbXdBQkI3S2JBQURZQ0FFR0lwOEFBUWZ5bXdBQTJBZ0JCL0tiQUFFSDBwc0FBTmdJQVFaQ253QUJCaEtmQUFEWUNBRUdFcDhBQVFmeW13QUEyQWdCQm1LZkFBRUdNcDhBQU5nSUFRWXlud0FCQmhLZkFBRFlDQUVHZ3A4QUFRWlNud0FBMkFnQkJsS2ZBQUVHTXA4QUFOZ0lBUWFpbndBQkJuS2ZBQURZQ0FFR2NwOEFBUVpTbndBQTJBZ0JCc0tmQUFFR2twOEFBTmdJQVFhU253QUJCbktmQUFEWUNBRUc0cDhBQVFheW53QUEyQWdCQnJLZkFBRUdrcDhBQU5nSUFRY0Nud0FCQnRLZkFBRFlDQUVHMHA4QUFRYXlud0FBMkFnQkJ5S2ZBQUVHOHA4QUFOZ0lBUWJ5bndBQkJ0S2ZBQURZQ0FFSFFwOEFBUWNTbndBQTJBZ0JCeEtmQUFFRzhwOEFBTmdJQVFkaW53QUJCektmQUFEWUNBRUhNcDhBQVFjU253QUEyQWdCQjRLZkFBRUhVcDhBQU5nSUFRZFNud0FCQnpLZkFBRFlDQUVId3FNQUFJQVEyQWdCQjNLZkFBRUhVcDhBQU5nSUFRZWlvd0FBZ0IwRllhaUlBTmdJQUlBUWdBRUVCY2pZQ0JDQUFJQVJxUVNnMkFnUkJqS25BQUVHQWdJQUJOZ0lBREFJTElBQkJER29vQWdBRVFBd0JDeUFFSUFOTklBRWdBMHR5RFFBZ0FDQUNJQWRxTmdJRVFmQ293QUJCOEtqQUFDZ0NBQ0lBUVE5cVFYaHhJZ0ZCZUdvMkFnQkI2S2pBQUVIb3FNQUFLQUlBSUFkcUlnSWdBQ0FCYTJwQkNHb2lBellDQUNBQlFYeHFJQU5CQVhJMkFnQWdBQ0FDYWtFb05nSUVRWXlwd0FCQmdJQ0FBVFlDQUF3QkMwR1FxY0FBUVpDcHdBQW9BZ0FpQUNBRUlBQWdCRWtiTmdJQUlBUWdCMm9oQWtIOHFNQUFJUUFDUUFKQUEwQWdBaUFBS0FJQVJ3UkFJQUFvQWdnaUFBMEJEQUlMQ3lBQVFReHFLQUlBUlEwQkMwSDhxTUFBSVFBRFFBSkFJQUFvQWdBaUFTQURUUVJBSUFFZ0FDZ0NCR29pQWlBRFN3MEJDeUFBS0FJSUlRQU1BUXNMUWZDb3dBQWdCRFlDQUVIb3FNQUFJQWRCV0dvaUFEWUNBQ0FFSUFCQkFYSTJBZ1FnQUNBRWFrRW9OZ0lFUVl5cHdBQkJnSUNBQVRZQ0FDQURJQUpCWUdwQmVIRkJlR29pQUNBQUlBTkJFR3BKR3lJQlFSczJBZ1JCL0tqQUFDa0NBQ0VKSUFGQkVHcEJoS25BQUNrQ0FEY0NBQ0FCSUFrM0FnaEJpS25BQUVFQU5nSUFRWUNwd0FBZ0J6WUNBRUg4cU1BQUlBUTJBZ0JCaEtuQUFDQUJRUWhxTmdJQUlBRkJIR29oQUFOQUlBQkJCellDQUNBQ0lBQkJCR29pQUVzTkFBc2dBU0FEUmcwQklBRWdBU2dDQkVGK2NUWUNCQ0FESUFFZ0Eyc2lCRUVCY2pZQ0JDQUJJQVEyQWdBZ0JFR0FBazhFUUNBRFFnQTNBaEFnQTBFY2FnSi9RUUFnQkVFSWRpSUFSUTBBR2tFZklBUkIvLy8vQjBzTkFCb2dCRUVHSUFCbklnQnJRUjl4ZGtFQmNTQUFRUUYwYTBFK2Fnc2lBRFlDQUNBQVFRSjBRZVNud0FCcUlRRUNRQUpBQWtBQ1FFSFlwY0FBS0FJQUlnSkJBU0FBUVI5eGRDSUhjUVJBSUFFb0FnQWlBVUVFYWlnQ0FFRjRjU0FFUncwQklBRWhBQXdDQzBIWXBjQUFJQUlnQjNJMkFnQWdBU0FETmdJQURBTUxJQVJCQUVFWklBQkJBWFpyUVI5eElBQkJIMFliZENFQ0EwQWdBU0FDUVIxMlFRUnhha0VRYWlJSEtBSUFJZ0JGRFFJZ0FrRUJkQ0VDSUFBaEFTQUFRUVJxS0FJQVFYaHhJQVJIRFFBTEN5QUFLQUlJSWdFZ0F6WUNEQ0FBSUFNMkFnZ2dBMEVZYWtFQU5nSUFJQU1nQURZQ0RDQURJQUUyQWdnTUJBc2dCeUFETmdJQUN5QURRUmhxSUFFMkFnQWdBeUFETmdJTUlBTWdBellDQ0F3Q0N5QUVRUU4ySWdGQkEzUkIzS1hBQUdvaEFBSi9RZFNsd0FBb0FnQWlBa0VCSUFGMElnRnhCRUFnQUNnQ0NBd0JDMEhVcGNBQUlBRWdBbkkyQWdBZ0FBc2hBU0FBSUFNMkFnZ2dBU0FETmdJTUlBTWdBRFlDRENBRElBRTJBZ2dNQVFzZ0FDQUVOZ0lBSUFBZ0FDZ0NCQ0FIYWpZQ0JDQUVJQVZCQTNJMkFnUWdCQ0FGYWlFQUlBSWdCR3NnQldzaEJRSkFBa0FnQWtId3FNQUFLQUlBUndSQVFleW93QUFvQWdBZ0FrWU5BU0FDUVFScUtBSUFJZ0ZCQTNGQkFVWUVRQ0FDSUFGQmVIRWlBUkFSSUFFZ0JXb2hCU0FCSUFKcUlRSUxJQUlnQWlnQ0JFRitjVFlDQkNBQUlBVkJBWEkyQWdRZ0FDQUZhaUFGTmdJQUlBVkJnQUpQQkVBZ0FFSUFOd0lRSUFBQ2YwRUFJQVZCQ0hZaUFVVU5BQnBCSHlBRlFmLy8vd2RMRFFBYUlBVkJCaUFCWnlJQmEwRWZjWFpCQVhFZ0FVRUJkR3RCUG1vTElnRTJBaHdnQVVFQ2RFSGtwOEFBYWlFQ0FrQUNRQUpBQWtCQjJLWEFBQ2dDQUNJR1FRRWdBVUVmY1hRaUEzRUVRQ0FDS0FJQUlnSkJCR29vQWdCQmVIRWdCVWNOQVNBQ0lRWU1BZ3RCMktYQUFDQURJQVp5TmdJQUlBSWdBRFlDQUF3REN5QUZRUUJCR1NBQlFRRjJhMEVmY1NBQlFSOUdHM1FoQVFOQUlBSWdBVUVkZGtFRWNXcEJFR29pQXlnQ0FDSUdSUTBDSUFGQkFYUWhBU0FHSWdKQkJHb29BZ0JCZUhFZ0JVY05BQXNMSUFZb0FnZ2lBU0FBTmdJTUlBWWdBRFlDQ0NBQVFRQTJBaGdnQUNBR05nSU1JQUFnQVRZQ0NBd0ZDeUFESUFBMkFnQUxJQUFnQWpZQ0dDQUFJQUEyQWd3Z0FDQUFOZ0lJREFNTElBVkJBM1lpQWtFRGRFSGNwY0FBYWlFQkFuOUIxS1hBQUNnQ0FDSUdRUUVnQW5RaUFuRUVRQ0FCS0FJSURBRUxRZFNsd0FBZ0FpQUdjallDQUNBQkN5RUNJQUVnQURZQ0NDQUNJQUEyQWd3Z0FDQUJOZ0lNSUFBZ0FqWUNDQXdDQzBId3FNQUFJQUEyQWdCQjZLakFBRUhvcU1BQUtBSUFJQVZxSWdFMkFnQWdBQ0FCUVFGeU5nSUVEQUVMUWV5b3dBQWdBRFlDQUVIa3FNQUFRZVNvd0FBb0FnQWdCV29pQVRZQ0FDQUFJQUZCQVhJMkFnUWdBQ0FCYWlBQk5nSUFDeUFFUVFocUR3dEI2S2pBQUNnQ0FDSUFJQVZORFFJTUF3c2dBU0FITmdJWUlBSW9BaEFpQUFSQUlBRWdBRFlDRUNBQUlBRTJBaGdMSUFKQkZHb29BZ0FpQUVVTkFDQUJRUlJxSUFBMkFnQWdBQ0FCTmdJWUN3SkFJQVpCRUU4RVFDQUNJQVZCQTNJMkFnUWdBaUFGYWlJRElBWkJBWEkyQWdRZ0F5QUdhaUFHTmdJQVFlU293QUFvQWdBaUFBUkFJQUJCQTNZaUJFRURkRUhjcGNBQWFpRUFRZXlvd0FBb0FnQWhBUUovUWRTbHdBQW9BZ0FpQlVFQklBUkJIM0YwSWdSeEJFQWdBQ2dDQ0F3QkMwSFVwY0FBSUFRZ0JYSTJBZ0FnQUFzaEJDQUFJQUUyQWdnZ0JDQUJOZ0lNSUFFZ0FEWUNEQ0FCSUFRMkFnZ0xRZXlvd0FBZ0F6WUNBRUhrcU1BQUlBWTJBZ0FNQVFzZ0FpQUZJQVpxSWdCQkEzSTJBZ1FnQUNBQ2FpSUFJQUFvQWdSQkFYSTJBZ1FMSUFKQkNHb1BDeUFHRHd0QjZLakFBQ0FBSUFWcklnRTJBZ0JCOEtqQUFFSHdxTUFBS0FJQUlnQWdCV29pQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FGUVFOeU5nSUVJQUJCQ0dvTDRSQUNFbjhDZmlNQVFZQUJheUlHSkFBZ0JpQUROZ0lzSUFZZ0FqWUNLQUpBQW44Q1FBSkFBa0FDUUFKL0FrQWdBUzBBUjBVRVFDQUJLUU00SVJnZ0FVSUFOd000UVFFaERDQVlwMEgvL3dOeFFRRkhEUUVnR0VJd2lLY2hFU0FZUWhDSXB5RU5JQmhDSUlpbkRBSUxJQUJCQWpvQUNDQUFRZ0EzQWdBTUJ3c2dCa0VnYWlBQklBWkJLR29RS3lBR0x3RWdSUTBFUVFNaERDQUdMd0VpSWcwaUFpQUJMd0ZBVHcwRUlBSWdBUzhCUWtZTkFTQUJMd0ZFSUExQi8vOERjVVlOQWlBQlFSaHFLQUlBUlEwRUlBRkJLR29nQVVFUWFpSUhJQTBRSmhvZ0FTZ0NHQ0lDSUExQi8vOERjU0lLVFEwRElBY29BZ0FnQ2tFQ2RHb2lBaTBBQWlFUklBSXZBUUFMSVJNZ0JrRVlhaUFCUVNocUVFRWdCaWdDR0NFQ0FrQWdCaWdDSENJSElBVk5CRUFnQncwQlFRRWhFa0VCSVF3Z0JTRUhRUUVNQmdzZ0JVVUVRRUVCSVF4QkFDRUhRUUVNQmdzZ0JDQUNJQVVRU1JvZ0FVRXdhaUlDSUFJb0FnQWdCV28yQWdCQnI0WEFBQ0VFUVFBaERFRUFJUWRCQVF3RkN5QUVJQUlnQnhCSklBRkJNR29pQWlBQ0tBSUFJQWRxTmdJQUlBZHFJUVFnQlNBSGF5RUhRUUFoREVFQkRBUUxJQUVnQVMwQVJpSUhRUUZxSWdJNkFBb2dBVUVCSUFkQkQzRjBRUUpxT3dGQUlBRkJmeUFDUVE5eGRFRi9jenNCQ0NBQlFSQnFJQWNRRFVFQUlRMUJBQ0VNSUFVaEIwRUFEQU1MSUFGQkFUb0FSMEVDSVF3TUFRc2dDaUFDUWFDSXdBQVFOUUFMUVFBaERTQUZJUWRCQUFzaEFpQUdRVGhxUVFBMkFnQWdCa0lBTndNd0lBWkJ5QUJxUVFBMkFnQWdCa0lBTndOQUlBWkIvQUJxUVFBMkFnQWdCa0gwQUdwQkFEWUNBQ0FHUWV3QWFrRUFOZ0lBSUFaQjVBQnFRUUEyQWdBZ0JrSGNBR3BCQURZQ0FDQUdRWUNEd0FBMkFuZ2dCa0dBZzhBQU5nSndJQVpCZ0lQQUFEWUNhQ0FHUVlDRHdBQTJBbUFnQmtHQWc4QUFOZ0pZSUFaQkFEWUNWQ0FHUVlDRHdBQTJBbEFDUUFKL0FrQWdBa1VOQUNBQlFSQnFJUlFnQVVFb2FpRVZJQVpCeUFCcUlSY2dCa0UrYWlFV0FrQUNRQUpBQWtBQ1FBSkFBa0FEUUFKQUlBY05BQ0FHUVJCcUlCVVFRU0FHS0FJVVJRMEFRUUFoQnd3SUN5QUJJQVpCS0dvUUYwRUFJUXNnRnlFUVFRQWhEZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQURRQ0FCTFFBTElnSWdBUzBBQ2lJSVNRUkFJQTROQTBFQklBd2dFaHNoREF3UkN5QUJJQUlnQ0dzNkFBc2dCa0V3YWlBTGFpSUtJQUV2QVFnaUFpQUJLUU1BSUFpdGlTSVlwM0U3QVFBZ0FTQVlJQUt0UW4rRlFvQ0FmSVNETndNQUlBNEVRQ0FPUVg5cVFRVkxEUVFnQnlBTElCWnFMd0VBSWdKSkRRVWdFQ0FFTmdJQUlCQkJCR29nQWpZQ0FDQUhJQUpySVFjZ0FpQUVhaUVFQ3lBQkx3RkFJZ0lnRG1wQi8vOERjU0FCTHdFSUlBRXRBRWhyUWYvL0EzRkdEUUVnQ2k4QkFDSUtJQUpQRFFFZ0NpQUJMd0ZDUmcwQklBb2dBUzhCUkVZTkFTQUJLQUlrSWdJZ0NrME5CU0FISUFFb0Fod2dDa0VCZEdvdkFRQWlBa2tOQVNBT1FRRnFJUTRnQ3lBV2FrRUNhaUFDT3dFQUlCQkJDR29oRUNBTFFRSnFJZ3RCREVjTkFBdEJCaUVPUVFVaEVDQUdMd0U2SVFnTUJnc2dEa0VCYWlFT0N5QU9RUWRQRFFNZ0JrRXdhaUFPUVg5cUloQkJBWFJxTHdFQUlRZ2dFQTBFSUEwaENnd0ZDeUFPUVg5cVFRWkJzSVhBQUJBMUFBdEJnSVBBQUVFY1FZeUV3QUFRUndBTElBb2dBa0hBaGNBQUVEVUFDeUFPUVFaQjBJWEFBQkEyQUFzZ0JrSFFBR29oQWlBR1FUQnFJUXNEUUNBR1FRaHFJQlFnRkNBTEx3RUFJZ29nQWlnQ0FDQUNRUVJxS0FJQUVDa2dEUkFqSUFZdEFBb2hFU0FHTHdFSUlSTWdBU0FCTHdGQVFRRnFPd0ZBSUF0QkFtb2hDeUFDUVFocUlRSWdDaUVOSUJCQmYyb2lFQTBBQ3lBT1FRTjBJQVpxUVVCcklnSW9BZ1FoQ1NBQ1FRQTJBZ1FnQWlnQ0FDRVBJQUpCcjRYQUFEWUNBQXNnQ0NJTklBRXZBVUpHRFFFQ1FDQUJMd0ZFSUFoSEJFQWdDQ0FCTHdGQUlnSk5EUUZCQXlFTVFRQU1Dd3NnQVVFQk9nQkhRUUloREVFQURBb0xBa0FDZnlBSEFuOENRQUpBSUFJZ0NFY0VRQ0FCS0FJa0lnSWdDRXNOQVNBSUlBSkI4SVhBQUJBMUFBc2dBU2dDSkNJQ0lBcEIvLzhEY1NJSVRRMEhJQWNnQVNnQ0hDQUlRUUYwYWk4QkFFRUJha0gvL3dOeElnSlBEUUVnRHdSQUlBRW9BaXdpQWlBSlNRMEpJQUVvQWlnZ0R5QUpFRWthSUFFZ0NUWUNNQ0FCSUFrMkFqUUxRUUFoRHlBVkVESWhDMEVCREFNTElBY2dBU2dDSENBSVFRRjBhaThCQUNJQ1NRUkFRUUFoRHlBVklCUWdEUkFtSVF0QkFRd0RDeUFVSUEwZ0JDQUNFQ2toQ3lBQ0RBRUxJQTlGQkVBZ0FTZ0NMQ0lJSUFFb0FqUWlDVWtOQ0NBVktBSUFJUThMSUFsRkRRSWdDU0FDU3cwSUlBOHRBQUFoQ3lBRUlBOGdDUkJKSUFJZ0NVWU5DU0FKYWlBTE9nQUFJQUlMSWdscklRY2dDU0FFSWc5cUlRUkJBQXNnQVNnQ0dFSC9IMDBFUUNBR0lCUWdDeUFLRUNNZ0FTOEJRQ0VRSUFZdEFBSWhFU0FHTHdFQUlSTUNRQ0FCTFFBS0lnaEJDMHNOQUNBUUlBRXZBUWdpQ2lBQkxRQklhMEgvL3dOeFJ3MEFJQUVnQ0VFQmFqb0FDaUFCSUFwQkFYUkJBWEk3QVFnTElBRWdFRUVCYWpzQlFBdEJBQ0VTUlEwQkRBZ0xDMEVBUVFCQm9JYkFBQkExQUFzZ0FSQXpEQVlMSUFnZ0FrSGdoY0FBRURVQUN5QUpJQUpCZ0liQUFCQTJBQXNnQ1NBSVFaQ0d3QUFRTmdBTElBa2dBa0d3aHNBQUVEWUFDMEVBUVFCQndJYkFBQkExQUF0Q0FTRVpJQTlGRFFJZ0FTZ0NMQ0lDSUFsUEJFQWdBU2dDS0NBUElBa1FTUm9nQVNBSk5nSXdJQUVnQ1RZQ05Bd0RDeUFKSUFKQjBJYkFBQkEyQUF0QkFBc2hEVUVBSVJOQkFDRVJDeUFBSUFVZ0IyczJBZ1FnQUNBRElBWW9BaXdpQW1zMkFnQWdBRUVBSUF3Z0F5QUNTeHNnRENBTVFRRkdHem9BQ0NBQklBMnRRdi8vQTROQ0VJWWdHWVFnRTYxQy8vOERnMElnaG9RZ0VhMUMvd0dEUWpDR2hEY0RPQXNnQmtHQUFXb2tBQXZXRUFJUmZ3SitJd0JCZ0FGcklnWWtBQ0FHSUFNMkFpd2dCaUFDTmdJb0FrQUNmd0pBQWtBQ1FBSkFBbjhDUUNBQkxRQkhSUVJBSUFFcEF6Z2hGeUFCUWdBM0F6aEJBU0VNSUJlblFmLy9BM0ZCQVVjTkFTQVhRakNJcHlFUklCZENFSWluSVEwZ0YwSWdpS2NNQWdzZ0FFRUNPZ0FJSUFCQ0FEY0NBQXdIQ3lBR1FTQnFJQUVnQmtFb2FoQXRJQVl2QVNCRkRRUkJBeUVNSUFZdkFTSWlEU0lDSUFFdkFVQlBEUVFnQWlBQkx3RkNSZzBCSUFFdkFVUWdEVUgvL3dOeFJnMENJQUZCR0dvb0FnQkZEUVFnQVVFb2FpQUJRUkJxSWdjZ0RSQW1HaUFCS0FJWUlnSWdEVUgvL3dOeElnbE5EUU1nQnlnQ0FDQUpRUUowYWlJQ0xRQUNJUkVnQWk4QkFBc2hFaUFHUVJocUlBRkJLR29RUVNBR0tBSVlJUUlDUUNBR0tBSWNJZ2NnQlUwRVFDQUhEUUZCQVNFSVFRRWhEQ0FGSVFkQkFRd0dDeUFGUlFSQVFRRWhERUVBSVFkQkFRd0dDeUFFSUFJZ0JSQkpHaUFCUVRCcUlnSWdBaWdDQUNBRmFqWUNBRUd2aGNBQUlRUkJBQ0VNUVFBaEIwRUJEQVVMSUFRZ0FpQUhFRWtnQVVFd2FpSUNJQUlvQWdBZ0IybzJBZ0FnQjJvaEJDQUZJQWRySVFkQkFDRU1RUUVNQkFzZ0FTQUJMUUJHSWdkQkFXb2lBam9BQ2lBQlFRRWdCMEVQY1hSQkFtbzdBVUFnQVVGL0lBSkJEM0YwUVg5ek93RUlJQUZCRUdvZ0J4QU5RUUFoRFVFQUlRd2dCU0VIUVFBTUF3c2dBVUVCT2dCSFFRSWhEQXdCQ3lBSklBSkJvSWpBQUJBMUFBdEJBQ0VOSUFVaEIwRUFDeUVDSUFaQk9HcEJBRFlDQUNBR1FnQTNBekFnQmtISUFHcEJBRFlDQUNBR1FnQTNBMEFnQmtIOEFHcEJBRFlDQUNBR1FmUUFha0VBTmdJQUlBWkI3QUJxUVFBMkFnQWdCa0hrQUdwQkFEWUNBQ0FHUWR3QWFrRUFOZ0lBSUFaQmdJUEFBRFlDZUNBR1FZQ0R3QUEyQW5BZ0JrR0FnOEFBTmdKb0lBWkJnSVBBQURZQ1lDQUdRWUNEd0FBMkFsZ2dCa0VBTmdKVUlBWkJnSVBBQURZQ1VBSkFBbjhDUUNBQ1JRMEFJQUZCRUdvaEV5QUJRU2hxSVJRZ0JrSElBR29oRmlBR1FUNXFJUlVDUUFKQUFrQUNRQUpBQWtBQ1FBTkFBa0FnQncwQUlBWkJFR29nRkJCQklBWW9BaFJGRFFCQkFDRUhEQWdMSUFFZ0JrRW9haEFmUVFBaEN5QVdJUkJCQUNFT0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFOQUlBRXRBQXNpQWlBQkxRQUtJZ2xKQkVBZ0RnMERRUUVnRENBSUd5RU1EQkVMSUFFZ0FpQUphem9BQ3lBQklBRXBBd0FpRnlBSnJVSS9nNGczQXdBZ0JrRXdhaUFMYWlJSklBRXZBUWdnRjZkeE93RUFJQTRFUUNBT1FYOXFRUVZMRFFRZ0J5QUxJQlZxTHdFQUlnSkpEUVVnRUNBRU5nSUFJQkJCQkdvZ0FqWUNBQ0FISUFKcklRY2dBaUFFYWlFRUN5QUJMd0ZBSWdJZ0RtcEIvLzhEY1NBQkx3RUlJQUV0QUVoclFmLy9BM0ZHRFFFZ0NTOEJBQ0lKSUFKUERRRWdDU0FCTHdGQ1JnMEJJQWtnQVM4QlJFWU5BU0FCS0FJa0lnSWdDVTBOQlNBSElBRW9BaHdnQ1VFQmRHb3ZBUUFpQWtrTkFTQU9RUUZxSVE0Z0N5QVZha0VDYWlBQ093RUFJQkJCQ0dvaEVDQUxRUUpxSWd0QkRFY05BQXRCQmlFT1FRVWhFQ0FHTHdFNklRZ01CZ3NnRGtFQmFpRU9DeUFPUVFkUERRTWdCa0V3YWlBT1FYOXFJaEJCQVhScUx3RUFJUWdnRUEwRUlBMGhDUXdGQ3lBT1FYOXFRUVpCc0lYQUFCQTFBQXRCZ0lQQUFFRWNRWXlFd0FBUVJ3QUxJQWtnQWtIQWhjQUFFRFVBQ3lBT1FRWkIwSVhBQUJBMkFBc2dCa0hRQUdvaEFpQUdRVEJxSVFzRFFDQUdRUWhxSUJNZ0V5QUxMd0VBSWdrZ0FpZ0NBQ0FDUVFScUtBSUFFQ2tnRFJBaklBWXRBQW9oRVNBR0x3RUlJUklnQVNBQkx3RkFRUUZxT3dGQUlBdEJBbW9oQ3lBQ1FRaHFJUUlnQ1NFTklCQkJmMm9pRUEwQUN5QU9RUU4wSUFacVFVQnJJZ0lvQWdRaENpQUNRUUEyQWdRZ0FpZ0NBQ0VQSUFKQnI0WEFBRFlDQUFzZ0NDSU5JQUV2QVVKR0RRRUNRQ0FCTHdGRUlBaEhCRUFnQ0NBQkx3RkFJZ0pORFFGQkF5RU1RUUFNQ3dzZ0FVRUJPZ0JIUVFJaERFRUFEQW9MQWtBQ2Z5QUhBbjhDUUFKQUlBSWdDRWNFUUNBQktBSWtJZ0lnQ0VzTkFTQUlJQUpCOElYQUFCQTFBQXNnQVNnQ0pDSUNJQWxCLy84RGNTSUlUUTBISUFjZ0FTZ0NIQ0FJUVFGMGFpOEJBRUVCYWtILy93TnhJZ0pQRFFFZ0R3UkFJQUVvQWl3aUFpQUtTUTBKSUFFb0FpZ2dEeUFLRUVrYUlBRWdDallDTUNBQklBbzJBalFMUVFBaER5QVVFREloQzBFQkRBTUxJQWNnQVNnQ0hDQUlRUUYwYWk4QkFDSUNTUVJBUVFBaER5QVVJQk1nRFJBbUlRdEJBUXdEQ3lBVElBMGdCQ0FDRUNraEN5QUNEQUVMSUE5RkJFQWdBU2dDTENJSUlBRW9BalFpQ2trTkNDQVVLQUlBSVE4TElBcEZEUUlnQ2lBQ1N3MElJQTh0QUFBaEN5QUVJQThnQ2hCSklBSWdDa1lOQ1NBS2FpQUxPZ0FBSUFJTElncHJJUWNnQ2lBRUlnOXFJUVJCQUFzZ0FTZ0NHRUgvSDAwRVFDQUdJQk1nQ3lBSkVDTWdBUzhCUUNFUUlBWXRBQUloRVNBR0x3RUFJUklDUUNBQkxRQUtJZ2hCQzBzTkFDQVFJQUV2QVFnaUNTQUJMUUJJYTBILy93TnhSdzBBSUFFZ0NFRUJham9BQ2lBQklBbEJBWFJCQVhJN0FRZ0xJQUVnRUVFQmFqc0JRQXRCQUNFSVJRMEJEQWdMQzBFQVFRQkJvSWJBQUJBMUFBc2dBUkF6REFZTElBZ2dBa0hnaGNBQUVEVUFDeUFLSUFKQmdJYkFBQkEyQUFzZ0NpQUlRWkNHd0FBUU5nQUxJQW9nQWtHd2hzQUFFRFlBQzBFQVFRQkJ3SWJBQUJBMUFBdENBU0VZSUE5RkRRSWdBU2dDTENJQ0lBcFBCRUFnQVNnQ0tDQVBJQW9RU1JvZ0FTQUtOZ0l3SUFFZ0NqWUNOQXdEQ3lBS0lBSkIwSWJBQUJBMkFBdEJBQXNoRFVFQUlSSkJBQ0VSQ3lBQUlBVWdCMnMyQWdRZ0FDQURJQVlvQWl3aUFtczJBZ0FnQUVFQUlBd2dBeUFDU3hzZ0RDQU1RUUZHR3pvQUNDQUJJQTJ0UXYvL0E0TkNFSVlnR0lRZ0VxMUMvLzhEZzBJZ2hvUWdFYTFDL3dHRFFqQ0doRGNET0FzZ0JrR0FBV29rQUF1cUNBRUdmeU1BUWZBQWF5SUZKQUFnQlNBRE5nSU1JQVVnQWpZQ0NFRUJJUWNnQVNFR0FrQWdBVUdCQWtrTkFFRUFJQUZySVFsQmdBSWhDQU5BQWtBZ0NDQUJUdzBBUVFBaEJ5QUFJQWhxTEFBQVFiOS9UQTBBSUFnaEJnd0NDeUFJUVg5cUlRWkJBQ0VISUFoQkFVWU5BU0FJSUFscUlBWWhDRUVCUncwQUN3c2dCU0FHTmdJVUlBVWdBRFlDRUNBRlFRQkJCU0FIR3pZQ0hDQUZRYlNLd0FCQmhKSEFBQ0FIR3pZQ0dBSkFBbjhDUUFKQUlBSWdBVXNpQnlBRElBRkxja1VFUUNBQ0lBTkxEUUVDUUNBQ1JTQUJJQUpHY2tVRVFDQUJJQUpORFFFZ0FDQUNhaXdBQUVGQVNBMEJDeUFESVFJTElBVWdBallDSUNBQ1FRQWdBU0FDUnh0RkJFQWdBaUVIREFNTElBRkJBV29oQXdOQUFrQWdBaUFCVHcwQUlBQWdBbW9zQUFCQlFFZ05BQ0FDSVFjZ0JVRWthZ3dGQ3lBQ1FYOXFJUWNnQWtFQlJnMERJQUlnQTBZZ0J5RUNSUTBBQ3d3Q0N5QUZJQUlnQXlBSEd6WUNLQ0FGUWNRQWFrRUROZ0lBSUFWQjNBQnFRUmsyQWdBZ0JVSFVBR3BCR1RZQ0FDQUZRZ00zQWpRZ0JVR3NrY0FBTmdJd0lBVkJHRFlDVENBRklBVkJ5QUJxTmdKQUlBVWdCVUVZYWpZQ1dDQUZJQVZCRUdvMkFsQWdCU0FGUVNocU5nSklEQU1MSUFWQjVBQnFRUmsyQWdBZ0JVSGNBR3BCR1RZQ0FDQUZRZFFBYWtFWU5nSUFJQVZCeEFCcVFRUTJBZ0FnQlVJRU53STBJQVZCNkpIQUFEWUNNQ0FGUVJnMkFrd2dCU0FGUWNnQWFqWUNRQ0FGSUFWQkdHbzJBbUFnQlNBRlFSQnFOZ0pZSUFVZ0JVRU1hallDVUNBRklBVkJDR28yQWtnTUFnc2dCVUVrYWdzaENBSkFJQUVnQjBZTkFFRUJJUU1DUUFKQUFrQWdBQ0FIYWlJR0xBQUFJZ0pCZjB3RVFFRUFJUU1nQUNBQmFpSUJJUUFnQVNBR1FRRnFSd1JBSUFZdEFBRkJQM0VoQXlBR1FRSnFJUUFMSUFKQkgzRWhDU0FDUWY4QmNVSGZBVXNOQVNBRElBbEJCblJ5SVFJTUFnc2dCU0FDUWY4QmNUWUNKQ0FGUVNocUlRRU1BZ3RCQUNFS0lBRWhCaUFBSUFGSEJFQWdBQzBBQUVFL2NTRUtJQUJCQVdvaEJnc2dDaUFEUVFaMGNpRUFJQUpCL3dGeFFmQUJTUVJBSUFBZ0NVRU1kSEloQWd3QkMwRUFJUUlnQVNBR1J3Ui9JQVl0QUFCQlAzRUZRUUFMSUFsQkVuUkJnSUR3QUhFZ0FFRUdkSEp5SWdKQmdJREVBRVlOQWdzZ0JTQUNOZ0lrUVFFaEF5QUZRU2hxSVFFZ0FrR0FBVWtOQUVFQ0lRTWdBa0dBRUVrTkFFRURRUVFnQWtHQWdBUkpHeUVEQ3lBRklBYzJBaWdnQlNBRElBZHFOZ0lzSUFWQnhBQnFRUVUyQWdBZ0JVSHNBR3BCR1RZQ0FDQUZRZVFBYWtFWk5nSUFJQVZCM0FCcVFSbzJBZ0FnQlVIVUFHcEJHellDQUNBRlFnVTNBalFnQlVHOGtzQUFOZ0l3SUFVZ0FUWUNXQ0FGSUFnMkFsQWdCVUVZTmdKTUlBVWdCVUhJQUdvMkFrQWdCU0FGUVJocU5nSm9JQVVnQlVFUWFqWUNZQ0FGSUFWQklHbzJBa2dNQVF0QndJckFBRUVySUFRUVJ3QUxJQVZCTUdvZ0JCQlFBQXZjQ0FFRmZ5QUFRWGhxSWdFZ0FFRjhhaWdDQUNJRFFYaHhJZ0JxSVFJQ1FBSkFBa0FDUUNBRFFRRnhEUUFnQTBFRGNVVU5BU0FCS0FJQUlnTWdBR29oQUNBQklBTnJJZ0ZCN0tqQUFDZ0NBRVlFUUNBQ0tBSUVRUU54UVFOSERRRkI1S2pBQUNBQU5nSUFJQUlnQWlnQ0JFRitjVFlDQkNBQklBQkJBWEkyQWdRZ0FDQUJhaUFBTmdJQUR3c2dBU0FERUJFTEFrQWdBa0VFYWlJRUtBSUFJZ05CQW5FRVFDQUVJQU5CZm5FMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdCQ3dKQUlBSkI4S2pBQUNnQ0FFY0VRRUhzcU1BQUtBSUFJQUpHRFFFZ0FpQURRWGh4SWdJUUVTQUJJQUFnQW1vaUFFRUJjallDQkNBQUlBRnFJQUEyQWdBZ0FVSHNxTUFBS0FJQVJ3MENRZVNvd0FBZ0FEWUNBQThMUWZDb3dBQWdBVFlDQUVIb3FNQUFRZWlvd0FBb0FnQWdBR29pQURZQ0FDQUJJQUJCQVhJMkFnUkI3S2pBQUNnQ0FDQUJSZ1JBUWVTb3dBQkJBRFlDQUVIc3FNQUFRUUEyQWdBTFFZeXB3QUFvQWdBaUFpQUFUdzBDUWZDb3dBQW9BZ0FpQUVVTkFnSkFRZWlvd0FBb0FnQWlBMEVwU1EwQVFmeW93QUFoQVFOQUlBRW9BZ0FpQkNBQVRRUkFJQVFnQVNnQ0JHb2dBRXNOQWdzZ0FTZ0NDQ0lCRFFBTEMwR1VxY0FBQW45Qi94OUJoS25BQUNnQ0FDSUFSUTBBR2tFQUlRRURRQ0FCUVFGcUlRRWdBQ2dDQ0NJQURRQUxJQUZCL3g4Z0FVSC9IMHNiQ3pZQ0FDQURJQUpORFFKQmpLbkFBRUYvTmdJQUR3dEI3S2pBQUNBQk5nSUFRZVNvd0FCQjVLakFBQ2dDQUNBQWFpSUFOZ0lBSUFFZ0FFRUJjallDQkNBQUlBRnFJQUEyQWdBUEN5QUFRWUFDU1EwQklBRkNBRGNDRUNBQlFSeHFBbjlCQUNBQVFRaDJJZ0pGRFFBYVFSOGdBRUgvLy84SFN3MEFHaUFBUVFZZ0FtY2lBbXRCSDNGMlFRRnhJQUpCQVhSclFUNXFDeUlETmdJQUlBTkJBblJCNUtmQUFHb2hBZ0pBQWtBQ1FBSkFBa0JCMktYQUFDZ0NBQ0lFUVFFZ0EwRWZjWFFpQlhFRVFDQUNLQUlBSWdKQkJHb29BZ0JCZUhFZ0FFY05BU0FDSVFNTUFndEIyS1hBQUNBRUlBVnlOZ0lBSUFJZ0FUWUNBQXdEQ3lBQVFRQkJHU0FEUVFGMmEwRWZjU0FEUVI5R0czUWhCQU5BSUFJZ0JFRWRka0VFY1dwQkVHb2lCU2dDQUNJRFJRMENJQVJCQVhRaEJDQURJZ0pCQkdvb0FnQkJlSEVnQUVjTkFBc0xJQU1vQWdnaUFDQUJOZ0lNSUFNZ0FUWUNDQ0FCUVJocVFRQTJBZ0FnQVNBRE5nSU1JQUVnQURZQ0NBd0NDeUFGSUFFMkFnQUxJQUZCR0dvZ0FqWUNBQ0FCSUFFMkFnd2dBU0FCTmdJSUMwR1VxY0FBUVpTcHdBQW9BZ0JCZjJvaUFEWUNBQ0FBUlEwQ0N3OExJQUJCQTNZaUFrRURkRUhjcGNBQWFpRUFBbjlCMUtYQUFDZ0NBQ0lEUVFFZ0FuUWlBbkVFUUNBQUtBSUlEQUVMUWRTbHdBQWdBaUFEY2pZQ0FDQUFDeUVDSUFBZ0FUWUNDQ0FDSUFFMkFnd2dBU0FBTmdJTUlBRWdBallDQ0E4TFFZU3B3QUFvQWdBaUFFVUVRRUdVcWNBQVFmOGZOZ0lBRHd0QkFDRUJBMEFnQVVFQmFpRUJJQUFvQWdnaUFBMEFDMEdVcWNBQUlBRkIveDhnQVVIL0gwc2JOZ0lBQzlRR0FReC9JQUFvQWhBaEF3SkFBa0FDUUFKQUlBQW9BZ2dpRFVFQlJ3UkFJQU5CQVVZTkFTQUFLQUlZSUFFZ0FpQUFRUnhxS0FJQUtBSU1FUUVBSVFNTUF3c2dBMEVCUncwQkN3SkFJQUpGQkVCQkFDRUNEQUVMSUFFZ0Ftb2hCaUFBUVJScUtBSUFRUUZxSVFrZ0FTSURJUXNEUUNBRFFRRnFJUVFDUUFKL0lBTXNBQUFpQlVGL1RBUkFBbjhnQkNBR1JnUkFRUUFoQ0NBR0RBRUxJQU10QUFGQlAzRWhDQ0FEUVFKcUlnUUxJUU1nQlVFZmNTRUtJQWdnQ2tFR2RISWdCVUgvQVhFaURrSGZBVTBOQVJvQ2Z5QURJQVpHQkVCQkFDRU1JQVlNQVFzZ0F5MEFBRUUvY1NFTUlBTkJBV29pQkFzaEJTQU1JQWhCQm5SeUlRZ2dDQ0FLUVF4MGNpQU9RZkFCU1EwQkdnSi9JQVVnQmtZRVFDQUVJUU5CQUF3QkN5QUZRUUZxSVFNZ0JTMEFBRUUvY1FzZ0NrRVNkRUdBZ1BBQWNTQUlRUVowY25JaUJVR0FnTVFBUncwQ0RBUUxJQVZCL3dGeEN5RUZJQVFoQXdzZ0NVRi9haUlKQkVBZ0J5QUxheUFEYWlFSElBTWhDeUFESUFaSERRRU1BZ3NMSUFWQmdJREVBRVlOQUFKQUlBZEZJQUlnQjBaeVJRUkFRUUFoQXlBSElBSlBEUUVnQVNBSGFpd0FBRUZBU0EwQkN5QUJJUU1MSUFjZ0FpQURHeUVDSUFNZ0FTQURHeUVCQ3lBTlFRRkdEUUFNQWdzQ1FDQUNCRUJCQUNFRUlBSWhCU0FCSVFNRFFDQUVJQU10QUFCQndBRnhRWUFCUm1vaEJDQURRUUZxSVFNZ0JVRi9haUlGRFFBTElBSWdCR3NnQUNnQ0RDSUpUdzBEUVFBaEJDQUNJUVVnQVNFREEwQWdCQ0FETFFBQVFjQUJjVUdBQVVacUlRUWdBMEVCYWlFRElBVkJmMm9pQlEwQUN3d0JDMEVBSVFRZ0FDZ0NEQ0lKRFFBTUFndEJBQ0VESUFRZ0Ftc2dDV29pQkNFRkFrQUNRQUpBUVFBZ0FDMEFJQ0lHSUFaQkEwWWJRUU54UVFGckRnTUJBQUVDQ3lBRVFRRjJJUU1nQkVFQmFrRUJkaUVGREFFTFFRQWhCU0FFSVFNTElBTkJBV29oQXdKQUEwQWdBMEYvYWlJRFJRMEJJQUFvQWhnZ0FDZ0NCQ0FBS0FJY0tBSVFFUUFBUlEwQUMwRUJEd3NnQUNnQ0JDRUVRUUVoQXlBQUtBSVlJQUVnQWlBQUtBSWNLQUlNRVFFQURRQWdCVUVCYWlFRElBQW9BaHdoQVNBQUtBSVlJUUFEUUNBRFFYOXFJZ05GQkVCQkFBOExJQUFnQkNBQktBSVFFUUFBUlEwQUMwRUJEd3NnQXc4TElBQW9BaGdnQVNBQ0lBQkJIR29vQWdBb0Fnd1JBUUFMdlFZQkJIOGdBQ0FCYWlFQ0FrQUNRQUpBQWtBQ1FDQUFRUVJxS0FJQUlnTkJBWEVOQUNBRFFRTnhSUTBCSUFBb0FnQWlBeUFCYWlFQklBQWdBMnNpQUVIc3FNQUFLQUlBUmdSQUlBSW9BZ1JCQTNGQkEwY05BVUhrcU1BQUlBRTJBZ0FnQWlBQ0tBSUVRWDV4TmdJRUlBQWdBVUVCY2pZQ0JDQUNJQUUyQWdBUEN5QUFJQU1RRVFzQ1FDQUNRUVJxS0FJQUlnTkJBbkVFUUNBQ1FRUnFJQU5CZm5FMkFnQWdBQ0FCUVFGeU5nSUVJQUFnQVdvZ0FUWUNBQXdCQ3dKQUlBSkI4S2pBQUNnQ0FFY0VRRUhzcU1BQUtBSUFJQUpHRFFFZ0FpQURRWGh4SWdJUUVTQUFJQUVnQW1vaUFVRUJjallDQkNBQUlBRnFJQUUyQWdBZ0FFSHNxTUFBS0FJQVJ3MENRZVNvd0FBZ0FUWUNBQThMUWZDb3dBQWdBRFlDQUVIb3FNQUFRZWlvd0FBb0FnQWdBV29pQVRZQ0FDQUFJQUZCQVhJMkFnUWdBRUhzcU1BQUtBSUFSdzBDUWVTb3dBQkJBRFlDQUVIc3FNQUFRUUEyQWdBUEMwSHNxTUFBSUFBMkFnQkI1S2pBQUVIa3FNQUFLQUlBSUFGcUlnRTJBZ0FnQUNBQlFRRnlOZ0lFSUFBZ0FXb2dBVFlDQUE4TElBRkJnQUpKRFFNZ0FFSUFOd0lRSUFCQkhHb0NmMEVBSUFGQkNIWWlBa1VOQUJwQkh5QUJRZi8vL3dkTERRQWFJQUZCQmlBQ1p5SUNhMEVmY1haQkFYRWdBa0VCZEd0QlBtb0xJZ00yQWdBZ0EwRUNkRUhrcDhBQWFpRUNBa0FDUUVIWXBjQUFLQUlBSWdSQkFTQURRUjl4ZENJRmNRUkFJQUlvQWdBaUFrRUVhaWdDQUVGNGNTQUJSdzBCSUFJaEF3d0NDMEhZcGNBQUlBUWdCWEkyQWdBZ0FpQUFOZ0lBREFRTElBRkJBRUVaSUFOQkFYWnJRUjl4SUFOQkgwWWJkQ0VFQTBBZ0FpQUVRUjEyUVFSeGFrRVFhaUlGS0FJQUlnTkZEUU1nQkVFQmRDRUVJQU1pQWtFRWFpZ0NBRUY0Y1NBQlJ3MEFDd3NnQXlnQ0NDSUJJQUEyQWd3Z0F5QUFOZ0lJSUFCQkdHcEJBRFlDQUNBQUlBTTJBZ3dnQUNBQk5nSUlDdzhMSUFVZ0FEWUNBQXNnQUVFWWFpQUNOZ0lBSUFBZ0FEWUNEQ0FBSUFBMkFnZ1BDeUFCUVFOMklnSkJBM1JCM0tYQUFHb2hBUUovUWRTbHdBQW9BZ0FpQTBFQklBSjBJZ0p4QkVBZ0FTZ0NDQXdCQzBIVXBjQUFJQUlnQTNJMkFnQWdBUXNoQWlBQklBQTJBZ2dnQWlBQU5nSU1JQUFnQVRZQ0RDQUFJQUkyQWdnTHJnWUJCMzhDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQUVHQWdBUlBCRUFnQUVHQWdBaEpEUUVnQUVHMTJYTnFRYlhiSzBrZ0FFSGlpM1JxUWVJTFNYSWdBRUdmcUhScVFaOFlTU0FBUWQ3aWRHcEJEa2x5Y2lBQVFmNy8vd0J4UVo3d0NrWWdBRUdpc25WcVFTSkpjaUFBUWN1UmRXcEJDMGx5Y2cwSUlBQkI4SU00U1E4TElBQkJnUDREY1VFSWRpRUdRYXlUd0FBaEFTQUFRZjhCY1NFSEEwQWdBVUVDYWlFRklBSWdBUzBBQVNJRWFpRURJQVlnQVMwQUFDSUJSd1JBSUFFZ0Jrc05DQ0FESVFJZ0JTSUJRZjZUd0FCSERRRU1DQXNnQXlBQ1NRMENJQU5Cb2dKTERRTWdBa0grazhBQWFpRUJBa0FEUUNBRVJRMEJJQVJCZjJvaEJDQUJMUUFBSUFGQkFXb2hBU0FIUncwQUMwRUFJUVFNQ1FzZ0F5RUNJQVVpQVVIK2s4QUFSdzBBQ3d3R0N5QUFRWUQrQTNGQkNIWWhCa0hWbU1BQUlRRWdBRUgvQVhFaEJ3TkFJQUZCQW1vaEJTQUNJQUV0QUFFaUJHb2hBeUFHSUFFdEFBQWlBVWNFUUNBQklBWkxEUVlnQXlFQ0lBVWlBVUdobWNBQVJ3MEJEQVlMSUFNZ0Fra05BeUFEUWE4QlN3MEVJQUpCb1puQUFHb2hBUUpBQTBBZ0JFVU5BU0FFUVg5cUlRUWdBUzBBQUNBQlFRRnFJUUVnQjBjTkFBdEJBQ0VFREFnTElBTWhBaUFGSWdGQm9abkFBRWNOQUFzTUJBc2dBaUFEUVl5VHdBQVFOd0FMSUFOQm9nSkJqSlBBQUJBMkFBc2dBaUFEUVl5VHdBQVFOd0FMSUFOQnJ3RkJqSlBBQUJBMkFBc2dBRUgvL3dOeElRTkIwSnJBQUNFQlFRRWhCQU5BQWtBZ0FVRUJhaUVBQW44Z0FDQUJMUUFBSWdKQkdIUkJHSFVpQlVFQVRnMEFHaUFBUWZPZHdBQkdEUUVnQVMwQUFTQUZRZjhBY1VFSWRISWhBaUFCUVFKcUN5RUJJQU1nQW1zaUEwRUFTQTBESUFSQkFYTWhCQ0FCUWZPZHdBQkhEUUVNQXdzTFFjQ0t3QUJCSzBHY2s4QUFFRWNBQ3lBQVFmLy9BM0VoQTBHZ2xzQUFJUUZCQVNFRUEwQWdBVUVCYWlFQUFuOGdBQ0FCTFFBQUlnSkJHSFJCR0hVaUJVRUFUZzBBR2lBQVFkV1l3QUJHRFFNZ0FTMEFBU0FGUWY4QWNVRUlkSEloQWlBQlFRSnFDeUVCSUFNZ0Ftc2lBMEVBU0EwQklBUkJBWE1oQkNBQlFkV1l3QUJIRFFBTEN5QUVRUUZ4RHd0QndJckFBRUVyUVp5VHdBQVFSd0FMMFFVQkIzOUJLMEdBZ01RQUlBQW9BZ0FpQ1VFQmNTSUZHeUVLSUFRZ0JXb2hDQUpBSUFsQkJIRkZCRUJCQUNFQkRBRUxJQUlFUUNBQ0lRWWdBU0VGQTBBZ0J5QUZMUUFBUWNBQmNVR0FBVVpxSVFjZ0JVRUJhaUVGSUFaQmYyb2lCZzBBQ3dzZ0FpQUlhaUFIYXlFSUMwRUJJUVVDUUNBQUtBSUlRUUZIQkVBZ0FDQUtJQUVnQWhCRkRRRWdBQ2dDR0NBRElBUWdBRUVjYWlnQ0FDZ0NEQkVCQUNFRkRBRUxJQUJCREdvb0FnQWlCaUFJVFFSQUlBQWdDaUFCSUFJUVJRMEJJQUFvQWhnZ0F5QUVJQUJCSEdvb0FnQW9BZ3dSQVFBUEN3SkFBa0FDUUFKQUlBbEJDSEVFUUNBQUtBSUVJUWtnQUVFd05nSUVJQUF0QUNBaEN5QUFRUUU2QUNBZ0FDQUtJQUVnQWhCRkRRVkJBQ0VGSUFZZ0NHc2lBU0VDUVFFZ0FDMEFJQ0lHSUFaQkEwWWJRUU54UVFGckRnTUNBUUlEQzBFQUlRVWdCaUFJYXlJR0lRZ0NRQUpBQWtCQkFTQUFMUUFnSWdjZ0IwRURSaHRCQTNGQkFXc09Bd0VBQVFJTElBWkJBWFloQlNBR1FRRnFRUUYySVFnTUFRdEJBQ0VJSUFZaEJRc2dCVUVCYWlFRkEwQWdCVUYvYWlJRlJRMEVJQUFvQWhnZ0FDZ0NCQ0FBS0FJY0tBSVFFUUFBUlEwQUMwRUJEd3NnQVVFQmRpRUZJQUZCQVdwQkFYWWhBZ3dCQzBFQUlRSWdBU0VGQ3lBRlFRRnFJUVVDUUFOQUlBVkJmMm9pQlVVTkFTQUFLQUlZSUFBb0FnUWdBQ2dDSENnQ0VCRUFBRVVOQUF0QkFROExJQUFvQWdRaEFVRUJJUVVnQUNnQ0dDQURJQVFnQUNnQ0hDZ0NEQkVCQUEwQklBSkJBV29oQnlBQUtBSWNJUUlnQUNnQ0dDRURBMEFnQjBGL2FpSUhCRUFnQXlBQklBSW9BaEFSQUFCRkRRRU1Bd3NMSUFBZ0N6b0FJQ0FBSUFrMkFnUkJBQThMSUFBb0FnUWhCa0VCSVFVZ0FDQUtJQUVnQWhCRkRRQWdBQ2dDR0NBRElBUWdBQ2dDSENnQ0RCRUJBQTBBSUFoQkFXb2hCeUFBS0FJY0lRRWdBQ2dDR0NFQUEwQWdCMEYvYWlJSFJRUkFRUUFQQ3lBQUlBWWdBU2dDRUJFQUFFVU5BQXNMSUFVTDlBVUJDbjhqQUVFd2F5SURKQUFnQTBFa2FpQUJOZ0lBSUFOQkF6b0FLQ0FEUW9DQWdJQ0FCRGNEQ0NBRElBQTJBaUFnQTBFQU5nSVlJQU5CQURZQ0VBSi9Ba0FDUUFKQUlBSW9BZ2dpQkFSQUlBSW9BZ0FoQmlBQ0tBSUVJZ2dnQWtFTWFpZ0NBQ0lGSUFVZ0NFc2JJZ1ZGRFFFZ0FDQUdLQUlBSUFZb0FnUWdBU2dDREJFQkFBMERJQVpCREdvaEFDQUNLQUlVSVFjZ0FpZ0NFQ0VLSUFVaENRTkFJQU1nQkVFY2FpMEFBRG9BS0NBRElBUkJCR29wQWdCQ0lJazNBd2dnQkVFWWFpZ0NBQ0VDUVFBaEMwRUFJUUVDUUFKQUFrQWdCRUVVYWlnQ0FFRUJhdzRDQUFJQkN5QUNJQWRQQkVBZ0FpQUhRZmlPd0FBUU5RQUxJQUpCQTNRZ0Ntb2lEQ2dDQkVFY1J3MEJJQXdvQWdBb0FnQWhBZ3RCQVNFQkN5QURJQUkyQWhRZ0F5QUJOZ0lRSUFSQkVHb29BZ0FoQWdKQUFrQUNRQ0FFUVF4cUtBSUFRUUZyRGdJQUFnRUxJQUlnQjA4RVFDQUNJQWRCK0k3QUFCQTFBQXNnQWtFRGRDQUthaUlCS0FJRVFSeEhEUUVnQVNnQ0FDZ0NBQ0VDQzBFQklRc0xJQU1nQWpZQ0hDQURJQXMyQWhnZ0JDZ0NBQ0lCSUFkSkJFQWdDaUFCUVFOMGFpSUJLQUlBSUFOQkNHb2dBU2dDQkJFQUFBMEZJQWxCZjJvaUNVVU5CQ0FFUVNCcUlRUWdBRUY4YWlFQklBQW9BZ0FoQWlBQVFRaHFJUUFnQXlnQ0lDQUJLQUlBSUFJZ0F5Z0NKQ2dDREJFQkFFVU5BUXdGQ3dzZ0FTQUhRZWlPd0FBUU5RQUxJQUlvQWdBaEJpQUNLQUlFSWdnZ0FrRVVhaWdDQUNJRklBVWdDRXNiSWdWRkRRQWdBaWdDRUNFRUlBQWdCaWdDQUNBR0tBSUVJQUVvQWd3UkFRQU5BaUFHUVF4cUlRQWdCU0VDQTBBZ0JDZ0NBQ0FEUVFocUlBUkJCR29vQWdBUkFBQU5BeUFDUVg5cUlnSkZEUUlnQkVFSWFpRUVJQUJCZkdvaEFTQUFLQUlBSVFrZ0FFRUlhaUVBSUFNb0FpQWdBU2dDQUNBSklBTW9BaVFvQWd3UkFRQkZEUUFMREFJTFFRQWhCUXNnQ0NBRlN3UkFJQU1vQWlBZ0JpQUZRUU4wYWlJQUtBSUFJQUFvQWdRZ0F5Z0NKQ2dDREJFQkFBMEJDMEVBREFFTFFRRUxJQU5CTUdva0FBdU5CUUVIZndKQUlBRkJ6UDk3U3cwQVFSQWdBVUVMYWtGNGNTQUJRUXRKR3lFQ0lBQkJmR29pQlNnQ0FDSUdRWGh4SVFNQ1FBSkFBa0FDUUFKQUFrQWdCa0VEY1FSQUlBQkJlR29pQnlBRGFpRUlJQU1nQWs4TkFVSHdxTUFBS0FJQUlBaEdEUUpCN0tqQUFDZ0NBQ0FJUmcwRElBaEJCR29vQWdBaUJrRUNjUTBHSUFaQmVIRWlCaUFEYWlJRElBSlBEUVFNQmdzZ0FrR0FBa2tnQXlBQ1FRUnlTWElnQXlBQ2EwR0JnQWhQY2cwRkRBUUxJQU1nQW1zaUFVRVFTUTBESUFVZ0FpQUdRUUZ4Y2tFQ2NqWUNBQ0FDSUFkcUlnUWdBVUVEY2pZQ0JDQUlJQWdvQWdSQkFYSTJBZ1FnQkNBQkVBWU1Bd3RCNktqQUFDZ0NBQ0FEYWlJRElBSk5EUU1nQlNBQ0lBWkJBWEZ5UVFKeU5nSUFJQUlnQjJvaUFTQURJQUpySWdSQkFYSTJBZ1JCNktqQUFDQUVOZ0lBUWZDb3dBQWdBVFlDQUF3Q0MwSGtxTUFBS0FJQUlBTnFJZ01nQWtrTkFnSkFJQU1nQW1zaUFVRVBUUVJBSUFVZ0JrRUJjU0FEY2tFQ2NqWUNBQ0FESUFkcUlnRWdBU2dDQkVFQmNqWUNCRUVBSVFFTUFRc2dCU0FDSUFaQkFYRnlRUUp5TmdJQUlBSWdCMm9pQkNBQlFRRnlOZ0lFSUFNZ0Iyb2lBaUFCTmdJQUlBSWdBaWdDQkVGK2NUWUNCQXRCN0tqQUFDQUVOZ0lBUWVTb3dBQWdBVFlDQUF3QkN5QUlJQVlRRVNBRElBSnJJZ0ZCRUU4RVFDQUZJQUlnQlNnQ0FFRUJjWEpCQW5JMkFnQWdBaUFIYWlJRUlBRkJBM0kyQWdRZ0F5QUhhaUlDSUFJb0FnUkJBWEkyQWdRZ0JDQUJFQVlNQVFzZ0JTQURJQVVvQWdCQkFYRnlRUUp5TmdJQUlBTWdCMm9pQVNBQktBSUVRUUZ5TmdJRUN5QUFJUVFNQVFzZ0FSQUFJZ0pGRFFBZ0FpQUFJQUZCZkVGNElBVW9BZ0FpQkVFRGNSc2dCRUY0Y1dvaUJDQUVJQUZMR3hCSklBQVFCQThMSUFRTG5BUUJCMzhqQUVFd2F5SURKQUFDZjBFQUlBSkZEUUFhSUFOQktHb2hDQUpBQWtBQ1FBTkFJQUFvQWdndEFBQUVRQ0FBS0FJQVFZeU13QUJCQkNBQUtBSUVLQUlNRVFFQURRUUxJQU5CQ2pZQ0tDQURRb3FBZ0lBUU53TWdJQU1nQWpZQ0hDQURRUUEyQWhnZ0F5QUNOZ0lVSUFNZ0FUWUNFQ0FEUVFocVFRb2dBU0FDRUJNQ2Z3SkFBa0FnQXlnQ0NFRUJSZ1JBSUFNb0Fnd2hCQU5BSUFNZ0JDQURLQUlZYWtFQmFpSUVOZ0lZQWtBZ0JDQURLQUlrSWdWSkJFQWdBeWdDRkNFSERBRUxJQU1vQWhRaUJ5QUVTUTBBSUFWQkJVOE5CeUFFSUFWcklnWWdBeWdDRUdvaUNTQUlSZzBFSUFrZ0NDQUZFRU5GRFFRTElBTW9BaHdpQmlBRVNTQUhJQVpKY2cwQ0lBTWdBeUFGYWtFbmFpMEFBQ0FES0FJUUlBUnFJQVlnQkdzUUV5QURLQUlFSVFRZ0F5Z0NBRUVCUmcwQUN3c2dBeUFES0FJY05nSVlDeUFBS0FJSVFRQTZBQUFnQWd3QkN5QUFLQUlJUVFFNkFBQWdCa0VCYWdzaEJDQUFLQUlFSVFVZ0FDZ0NBQ0VIQWtBQ1FDQUVSU0FDSUFSR2NrVUVRQ0FDSUFSTEJFQWdBU0FFYWlJR0xBQUFRYjkvU2cwQ0N5QUJJQUpCQUNBRVFaQ013QUFRQXdBTElBY2dBU0FFSUFVb0Fnd1JBUUFOQlF3QkN5QUhJQUVnQkNBRktBSU1FUUVBRFFRZ0Jpd0FBRUcvZjB3TkF3c2dBU0FFYWlFQklBSWdCR3NpQWcwQUMwRUFEQU1MSUFWQkJFSDBrTUFBRURZQUN5QUJJQUlnQkNBQ1FhQ013QUFRQXdBTFFRRUxJQU5CTUdva0FBdTNBd0VFZnlNQVFSQnJJZ0lrQUNBQUtBSUFJUUFDUUFKQUFrQUNmd0pBQWtBZ0FVR0FBVThFUUNBQ1FRQTJBZ3dnQVVHQUVFa05BU0FDUVF4cUlRUWdBVUdBZ0FSSkJFQWdBaUFCUVQ5eFFZQUJjam9BRGlBQ0lBRkJESFpCNEFGeU9nQU1JQUlnQVVFR2RrRS9jVUdBQVhJNkFBMUJBeUVCREFZTElBSWdBVUUvY1VHQUFYSTZBQThnQWlBQlFSSjJRZkFCY2pvQURDQUNJQUZCQm5aQlAzRkJnQUZ5T2dBT0lBSWdBVUVNZGtFL2NVR0FBWEk2QUExQkJDRUJEQVVMSUFBb0FnZ2lCQ0FBUVFScUtBSUFSd1JBSUFBb0FnQWhCUXdFQ3dKQUlBUkJBV29pQXlBRVNRMEFJQVJCQVhRaUJTQURJQVVnQTBzYklnTkJDQ0FEUVFoTEd5RURJQVFFUUNBRFFRQklEUUVnQUNnQ0FDSUZSUTBESUFVZ0JFRUJJQU1RVkF3RUN5QURRUUJPRFFJTEVGc0FDeUFDSUFGQlAzRkJnQUZ5T2dBTklBSWdBVUVHZGtIQUFYSTZBQXdnQWtFTWFpRUVRUUloQVF3REN5QURRUUVRVndzaUJRUkFJQUFnQlRZQ0FDQUFRUVJxSUFNMkFnQWdBQ2dDQ0NFRURBRUxJQU5CQVJCZkFBc2dCQ0FGYWlBQk9nQUFJQUFnQUNnQ0NFRUJhallDQ0F3QkN5QUFJQVFnQVJBZ0N5QUNRUkJxSkFCQkFBdTBBd0VFZnlBQVFRQTJBZ2dnQUVFVWFrRUFOZ0lBSUFGQkQzRWhCQ0FBUVF4cUlRSkJBQ0VCQTBBZ0FDZ0NCQ0FCUmdSQUlBQWdBUkE2SUFBb0FnZ2hBUXNnQUNnQ0FDQUJRUUowYWlJQklBTTZBQUlnQVVFQU93RUFJQUFnQUNnQ0NFRUJhallDQ0NBQUtBSVVJZ0VnQUNnQ0VFWUVRQ0FDSUFFUU95QUFLQUlVSVFFTElBQW9BZ3dnQVVFQmRHcEJBVHNCQUNBQUlBQW9BaFJCQVdvMkFoUWdBQ2dDQ0NFQklBTkJBV29pQlNFRElBVkIvLzhEY1NBRWRrVU5BQXNnQUNnQ0JDQUJSZ1JBSUFBZ0FSQTZJQUFvQWdnaEFRc2dBQ2dDQUNBQlFRSjBhaUlCUVFBNkFBSWdBVUVBT3dFQUlBQWdBQ2dDQ0VFQmFqWUNDQ0FBS0FJVUlnRWdBQ2dDRUVZRVFDQUNJQUVRT3lBQUtBSVVJUUVMSUFBb0Fnd2dBVUVCZEdwQkFEc0JBQ0FBSUFBb0FoUkJBV28yQWhRZ0FDZ0NDQ0lCSUFBb0FnUkdCRUFnQUNBQkVEb2dBQ2dDQ0NFQkN5QUFLQUlBSUFGQkFuUnFJZ0ZCQURvQUFpQUJRUUE3QVFBZ0FDQUFLQUlJUVFGcU5nSUlJQUFvQWhRaUFTQUFLQUlRUmdSQUlBSWdBUkE3SUFBb0FoUWhBUXNnQUNnQ0RDQUJRUUYwYWtFQU93RUFJQUFnQUNnQ0ZFRUJhallDRkF2MkF3SURmd0YrSUFFb0FoaEJKeUFCUVJ4cUtBSUFLQUlRRVFBQVJRUkFRZlFBSVFOQkFpRUNBa0FDUUFKQUFrQUNRQUpBSUFBb0FnQWlBRUYzYWc0ZkJRRURBd0FEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdRREF3TURCQUlMUWZJQUlRTU1CQXRCN2dBaEF3d0RDeUFBUWR3QVJnMEJDd0ovQW40Z0FFRUJjbWRCQW5aQkIzT3RRb0NBZ0lEUUFJUWdBQkFQRFFBYVFRRWdBQkFIRFFFYUlBQkJBWEpuUVFKMlFRZHpyVUtBZ0lDQTBBQ0VDeUVGUVFNTElRSWdBQ0VEREFFTElBQWhBd3NEUUNBQ0lRUkIzQUFoQUVFQklRSUNRQUorQWtBQ1FBSkFBa0FnQkVFQmF3NERBUVVBQWdzQ1FBSkFBa0FDUUNBRlFpQ0lwMEgvQVhGQkFXc09CUU1DQVFBR0JRdEI5UUFoQUNBRlF2Ly8vLytQWUlOQ2dJQ0FnRENFREFZTFFmc0FJUUFnQlVMLy8vLy9qMkNEUW9DQWdJQWdoQXdGQzBFd1FkY0FJQU1nQmFjaUJFRUNkRUVjY1haQkQzRWlBRUVLU1JzZ0FHb2hBQ0FGUW45OFF2Ly8vLzhQZ3lBRlFvQ0FnSUJ3ZzRRZ0JBMEVHaUFGUXYvLy8vK1BZSU5DZ0lDQWdCQ0VEQVFMUWYwQUlRQWdCVUwvLy8vL2oyQ0REQU1MUVFBaEFpQURJUUFNQXdzZ0FTZ0NHRUVuSUFFb0Fod29BaEFSQUFBUEN5QUZRdi8vLy8rUFlJTkNnSUNBZ01BQWhBc2hCVUVESVFJTElBRW9BaGdnQUNBQktBSWNLQUlRRVFBQVJRMEFDd3RCQVF1Z0F3RUZmd0pBQWtCQkFFRVBJQUJCcEpvRVNSc2lBU0FCUVFocUlnRWdBVUVDZEVIY25zQUFhaWdDQUVFTGRDQUFRUXQwSWdKTEd5SUJJQUZCQkdvaUFTQUJRUUowUWR5ZXdBQnFLQUlBUVF0MElBSkxHeUlCSUFGQkFtb2lBU0FCUVFKMFFkeWV3QUJxS0FJQVFRdDBJQUpMR3lJQklBRkJBV29pQVNBQlFRSjBRZHlld0FCcUtBSUFRUXQwSUFKTEd5SURRUUowUWR5ZXdBQnFLQUlBUVF0MElnRWdBa1lnQVNBQ1NXb2dBMm9pQWtFZVRRUkFRYkVGSVFRZ0FrRWVSd1JBSUFKQkFuUkI0SjdBQUdvb0FnQkJGWFloQkF0QkFDRUJJQUpCZjJvaUF5QUNUUVJBSUFOQkgwOE5BeUFEUVFKMFFkeWV3QUJxS0FJQVFmLy8vd0J4SVFFTEFrQWdCQ0FDUVFKMFFkeWV3QUJxS0FJQVFSVjJJZ05CQVdwR0RRQWdBQ0FCYXlFQ0lBTkJzUVVnQTBHeEJVc2JJUVVnQkVGL2FpRUJRUUFoQUFOQUlBTWdCVVlOQXlBQUlBTkIySi9BQUdvdEFBQnFJZ0FnQWtzTkFTQUJJQU5CQVdvaUEwY05BQXNnQVNFREN5QURRUUZ4RHdzZ0FrRWZRWnlld0FBUU5RQUxJQVZCc1FWQnJKN0FBQkExQUFzZ0EwRWZRYnlld0FBUU5RQUw2QUlCQlg4Q1FFSE4vM3NnQUVFUUlBQkJFRXNiSWdCcklBRk5EUUFnQUVFUUlBRkJDMnBCZUhFZ0FVRUxTUnNpQkdwQkRHb1FBQ0lDUlEwQUlBSkJlR29oQVFKQUlBQkJmMm9pQXlBQ2NVVUVRQ0FCSVFBTUFRc2dBa0Y4YWlJRktBSUFJZ1pCZUhFZ0FpQURha0VBSUFCcmNVRjRhaUlDSUFBZ0Ftb2dBaUFCYTBFUVN4c2lBQ0FCYXlJQ2F5RURJQVpCQTNFRVFDQUFJQU1nQUNnQ0JFRUJjWEpCQW5JMkFnUWdBQ0FEYWlJRElBTW9BZ1JCQVhJMkFnUWdCU0FDSUFVb0FnQkJBWEZ5UVFKeU5nSUFJQUFnQUNnQ0JFRUJjallDQkNBQklBSVFCZ3dCQ3lBQktBSUFJUUVnQUNBRE5nSUVJQUFnQVNBQ2FqWUNBQXNDUUNBQVFRUnFLQUlBSWdGQkEzRkZEUUFnQVVGNGNTSUNJQVJCRUdwTkRRQWdBRUVFYWlBRUlBRkJBWEZ5UVFKeU5nSUFJQUFnQkdvaUFTQUNJQVJySWdSQkEzSTJBZ1FnQUNBQ2FpSUNJQUlvQWdSQkFYSTJBZ1FnQVNBRUVBWUxJQUJCQ0dvaEF3c2dBd3VGQXdFRWZ3SkFBa0FnQVVHQUFrOEVRQ0FBUVJocUtBSUFJUVFDUUFKQUlBQWdBQ2dDRENJQ1JnUkFJQUJCRkVFUUlBQkJGR29pQWlnQ0FDSURHMm9vQWdBaUFRMEJRUUFoQWd3Q0N5QUFLQUlJSWdFZ0FqWUNEQ0FDSUFFMkFnZ01BUXNnQWlBQVFSQnFJQU1iSVFNRFFDQURJUVVnQVNJQ1FSUnFJZ01vQWdBaUFVVUVRQ0FDUVJCcUlRTWdBaWdDRUNFQkN5QUJEUUFMSUFWQkFEWUNBQXNnQkVVTkFpQUFJQUJCSEdvb0FnQkJBblJCNUtmQUFHb2lBU2dDQUVjRVFDQUVRUkJCRkNBRUtBSVFJQUJHRzJvZ0FqWUNBQ0FDUlEwRERBSUxJQUVnQWpZQ0FDQUNEUUZCMktYQUFFSFlwY0FBS0FJQVFYNGdBQ2dDSEhkeE5nSUFEd3NnQUVFTWFpZ0NBQ0lDSUFCQkNHb29BZ0FpQUVjRVFDQUFJQUkyQWd3Z0FpQUFOZ0lJRHd0QjFLWEFBRUhVcGNBQUtBSUFRWDRnQVVFRGRuZHhOZ0lBREFFTElBSWdCRFlDR0NBQUtBSVFJZ0VFUUNBQ0lBRTJBaEFnQVNBQ05nSVlDeUFBUVJScUtBSUFJZ0JGRFFBZ0FrRVVhaUFBTmdJQUlBQWdBallDR0FzTG93TUNCSDhDZmlNQVFVQnFJZ0lrQUVFQklRUUNRQ0FBTFFBRURRQWdBQzBBQlNFRklBQW9BZ0FpQXkwQUFFRUVjVVVFUUNBREtBSVlRYldNd0FCQnQ0ekFBQ0FGRzBFQ1FRTWdCUnNnQTBFY2FpZ0NBQ2dDREJFQkFBMEJJQUFvQWdBaUF5Z0NHRUdTcGNBQVFRY2dBMEVjYWlnQ0FDZ0NEQkVCQUEwQklBQW9BZ0FpQXlnQ0dFSHJpc0FBUVFJZ0EwRWNhaWdDQUNnQ0RCRUJBQTBCSUFFZ0FDZ0NBRUhZbnNBQUtBSUFFUUFBSVFRTUFRc2dCVVVFUUNBREtBSVlRYkNNd0FCQkF5QURRUnhxS0FJQUtBSU1FUUVBRFFFZ0FDZ0NBQ0VEQ3lBQ1FRRTZBQmNnQWtFMGFrSDBpOEFBTmdJQUlBSWdBeWtDR0RjRENDQUNJQUpCRjJvMkFoQWdBeWtDQ0NFR0lBTXBBaEFoQnlBQ0lBTXRBQ0E2QURnZ0FpQUhOd01vSUFJZ0JqY0RJQ0FDSUFNcEFnQTNBeGdnQWlBQ1FRaHFOZ0l3SUFKQkNHcEJrcVhBQUVFSEVBc05BQ0FDUVFocVFldUt3QUJCQWhBTERRQWdBU0FDUVJocVFkaWV3QUFvQWdBUkFBQU5BQ0FDS0FJd1FiT013QUJCQWlBQ0tBSTBLQUlNRVFFQUlRUUxJQUJCQVRvQUJTQUFJQVE2QUFRZ0FrRkFheVFBQzhRQ0FRVi9Ba0FDUUFKQUFrQkJBQ0FDYTBFRGNTSUVSUTBBSUFNZ0JDQUVJQU5MR3lJRVJRMEFJQUZCL3dGeElRVURRQ0FDSUFacUxRQUFJQVZHRFFJZ0JDQUdRUUZxSWdaSERRQUxJQVFoQlFzZ0EwRUlTUTBCSUFVZ0EwRjRhaUlJU3cwQklBRkIvd0Z4UVlHQ2hBaHNJUWNEUUNBQ0lBVnFJZ1pCQkdvb0FnQWdCM01pQkVGL2N5QUVRZi85KzNkcWNTQUdLQUlBSUFkeklnUkJmM01nQkVILy9mdDNhbkZ5UVlDQmdvUjRjVVVFUUNBRlFRaHFJZ1VnQ0UwTkFRc0xJQVVnQTAwTkFTQUZJQU5CckkvQUFCQTRBQXRCQVNFRURBRUxRUUFoQmtFQUlRUWdBeUFGUndSQUlBSWdCV29oQWlBRElBVnJJUU1nQVVIL0FYRWhBUUpBQTBBZ0FpQUdhaTBBQUNBQlJnMEJJQU1nQmtFQmFpSUdSdzBBQ3lBRElBVnFJUVlNQWd0QkFTRUVDeUFGSUFacUlRWUxJQUFnQmpZQ0JDQUFJQVEyQWdBTHZnSUNCWDhCZmlNQVFUQnJJZ1FrQUVFbklRSUNRQ0FBUXBET0FGUUVRQ0FBSVFjTUFRc0RRQ0FFUVFscUlBSnFJZ05CZkdvZ0FDQUFRcERPQUlBaUIwS1F6Z0IrZmFjaUJVSC8vd054UWVRQWJpSUdRUUYwUWVxTXdBQnFMd0FBT3dBQUlBTkJmbW9nQlNBR1FlUUFiR3RCLy84RGNVRUJkRUhxak1BQWFpOEFBRHNBQUNBQ1FYeHFJUUlnQUVML3dkY3ZWaUFISVFBTkFBc0xJQWVuSWdOQjR3QktCRUFnQWtGK2FpSUNJQVJCQ1dwcUlBZW5JZ01nQTBILy93TnhRZVFBYmlJRFFlUUFiR3RCLy84RGNVRUJkRUhxak1BQWFpOEFBRHNBQUFzQ1FDQURRUXBPQkVBZ0FrRithaUlDSUFSQkNXcHFJQU5CQVhSQjZvekFBR292QUFBN0FBQU1BUXNnQWtGL2FpSUNJQVJCQ1dwcUlBTkJNR282QUFBTElBRkJ0SXJBQUVFQUlBUkJDV29nQW1wQkp5QUNheEFJSUFSQk1Hb2tBQXVqQWdJRWZ3RitJd0JCUUdvaUJDUUFBa0FDUUFKQUlBSWdBMm9pQXlBQ1R3UkFJQUVvQWdRaEJTQUVRUmhxUW9HQWdJQVFOd01BSUFRb0Fod2lBa0YvYWlJR0lBUW9BaGhxUVFBZ0Ftc2lCM0d0SUFWQkFYUWlCU0FESUFVZ0Ewc2JJZ05CQ0NBRFFRaExHNjErSWdoQ0lJaW5JQUpGY2cwQklBSnBRUUZHQkVBZ0NLY2dCbW9nQjNFaEF3d0RDeUFFUVRCcUVEQUFDeUFFUVFocUlBTkJBQkJZSUFBZ0JDa0RDRGNDQkVFQklRSU1BZ3RCQUNFQ0N5QUVRVEJxSUFFUVN5QUVRU0JxSUFNZ0FpQUVRVEJxRUNWQkFTRUNJQVJCS0dvb0FnQWhBeUFFS0FJa0lRVWdCQ2dDSUVFQlJ3UkFJQUVnQlNBREVGaEJBQ0VDREFFTElBUkJFR29nQlNBREVGZ2dBQ0FFS1FNUU53SUVDeUFBSUFJMkFnQWdCRUZBYXlRQUM2NENBUWgvSXdCQk1Hc2lBU1FBUVlBZ0lRSWdBVUVZYWhBdklBRW9BaHdoQkNBQktBSVlJUVVnQVVFUWFoQXhJQUVvQWhRaEJpQUJLQUlRSVFjZ0FVRUlha0dBSUVFQkVEOGdBVUdBSURZQ0tDQUJJQUVvQWd3aUNEWUNKQ0FCSUFFb0FnZ2lBellDSUNBSVFZRWdUd1JBSUFGQklHcEJnQ0FRUkNBQktBSWdJUU1nQVNnQ0tDRUNDeUFBUVFBN0FFY2dBRUVBT3dFNElBQWdBellDS0NBQUlBVTJBaEFnQUVFSU9nQkdJQUJCQURvQUN5QUFRZ0EzQXdBZ0FFRXdha0lBTndNQUlBQkJMR29nQWpZQ0FDQUFRU1JxUVFBMkFnQWdBRUVnYWlBR05nSUFJQUJCSEdvZ0J6WUNBQ0FBUVJocVFRQTJBZ0FnQUVFVWFpQUVOZ0lBSUFCQkNUb0FDaUFBUVlBQ093RkNJQUJCZ1FJN0FVUWdBRUdDQWpzQlFDQUFRZjhET3dFSUlBRkJNR29rQUF2SEFnSUZmd0YrSXdCQkVHc2lBeVFBSUFBdEFBc2hBaUFEUWdBM0F3Z2dBU2dDQUNFRkFrQUNRQ0FBQW44Z0FTZ0NCQ0lFUWNBQUlBSnJJZ1pCK0FGeFFRTjJJZ0pKQkVBZ0JFRUpUdzBDSUFOQkNHb2dCU0FFRUVrYUlBRkJBRFlDQkNBQlFhK0Z3QUEyQWdBZ0JFRURkQXdCQ3lBR1FmOEJjVUhJQUU4TkFpQURRUWhxSUFVZ0FoQkpHaUFCSUFRZ0FtczJBZ1FnQVNBQ0lBVnFOZ0lBSUFaQitBRnhDeUFBTFFBTElnRnFPZ0FMSUFBZ0FDa0RBQ0FES1FNSUlnZENPSVlnQjBJb2hrS0FnSUNBZ0lEQS93Q0RoQ0FIUWhpR1FvQ0FnSUNBNEQrRElBZENDSVpDZ0lDQWdQQWZnNFNFSUFkQ0NJaENnSUNBK0ErRElBZENHSWhDZ0lEOEI0T0VJQWRDS0loQ2dQNERneUFIUWppSWhJU0VJQUZCUDNHdGlJUTNBd0FnQTBFUWFpUUFEd3NnQkVFSVFmQ0d3QUFRTmdBTElBSkJDRUhnaHNBQUVEWUFDNm9DQVFOL0l3QkJnQUZySWdRa0FBSkFBa0FDZndKQUlBRW9BZ0FpQTBFUWNVVUVRQ0FBS0FJQUlRSWdBMEVnY1EwQklBS3RJQUVRRkF3Q0N5QUFLQUlBSVFKQkFDRUFBMEFnQUNBRWFrSC9BR29nQWtFUGNTSURRVEJ5SUFOQjF3QnFJQU5CQ2trYk9nQUFJQUJCZjJvaEFDQUNRUVIySWdJTkFBc2dBRUdBQVdvaUFrR0JBVThOQWlBQlFlaU13QUJCQWlBQUlBUnFRWUFCYWtFQUlBQnJFQWdNQVF0QkFDRUFBMEFnQUNBRWFrSC9BR29nQWtFUGNTSURRVEJ5SUFOQk4yb2dBMEVLU1JzNkFBQWdBRUYvYWlFQUlBSkJCSFlpQWcwQUN5QUFRWUFCYWlJQ1FZRUJUdzBDSUFGQjZJekFBRUVDSUFBZ0JHcEJnQUZxUVFBZ0FHc1FDQXNnQkVHQUFXb2tBQThMSUFKQmdBRkIySXpBQUJBNEFBc2dBa0dBQVVIWWpNQUFFRGdBQzZvQ0FnWi9BWDRqQUVFd2F5SUVKQUFnQkVFUWFoQXFJQVFnQkNrREVEY0RHQ0FFUVFocUlBTkJBQkEvSUFRcEF3Z2hDaUFBUVFBMkFnZ2dBQ0FLTndJQUFrQURRQ0FISUFKUElBVWdBMDl5UlFSQUlBQWdCVUdBSUJBNUlBQWdBQ2dDQkJCT0lBQW9BZ0FoQ0NBQUtBSUlJZ1lnQlVrTkFpQUVRU0JxSUFSQkdHb2lDU2dDQUNBQklBZHFJQUlnQjJzZ0JTQUlhaUFHSUFWcklBa29BZ1FvQWd3UkNBQWdCQ2dDSUNFSUlBUW9BaVFnQldvaEJpQUFLQUlJSWdVZ0JrOEVRQ0FBS0FJQUdpQUFJQVkyQWdnZ0JpRUZDeUFISUFocUlRY2dCQzBBS0VFQ1J3MEJDd3NnQkNnQ0dDQUVLQUljS0FJQUVRTUFJQVFvQWh3aUFDZ0NDQm9nQkNnQ0dDRUJJQUFvQWdRRVFDQUJFQVFMSUFSQk1Hb2tBQThMSUFVZ0JrSE1nY0FBRURnQUM3RUNBUVIvSXdCQlFHb2lBaVFBSUFFb0FnUWlBMFVFUUNBQlFRUnFJUU1nQVNnQ0FDRUVJQUpCQURZQ0lDQUNRZ0UzQXhnZ0FpQUNRUmhxTmdJa0lBSkJPR29nQkVFUWFpa0NBRGNEQUNBQ1FUQnFJQVJCQ0dvcEFnQTNBd0FnQWlBRUtRSUFOd01vSUFKQkpHcEJ3SWpBQUNBQ1FTaHFFQWthSUFKQkVHb2lCQ0FDS0FJZ05nSUFJQUlnQWlrREdEY0RDQUpBSUFFb0FnUWlCVVVOQUNBQlFRaHFLQUlBUlEwQUlBVVFCQXNnQXlBQ0tRTUlOd0lBSUFOQkNHb2dCQ2dDQURZQ0FDQURLQUlBSVFNTElBRkJBVFlDQkNBQlFReHFLQUlBSVFRZ0FVRUlhaUlCS0FJQUlRVWdBVUlBTndJQVFReEJCQkJYSWdGRkJFQkJERUVFRUY4QUN5QUJJQVEyQWdnZ0FTQUZOZ0lFSUFFZ0F6WUNBQ0FBUWVTSndBQTJBZ1FnQUNBQk5nSUFJQUpCUUdza0FBdjhBUUVDZnlNQVFSQnJJZ0lrQUNBQUtBSUFJQUpCQURZQ0RBSi9Ba0FDUUNBQlFZQUJUd1JBSUFGQmdCQkpEUUVnQWtFTWFpRUFJQUZCZ0lBRVR3MENJQUlnQVVFL2NVR0FBWEk2QUE0Z0FpQUJRUXgyUWVBQmNqb0FEQ0FDSUFGQkJuWkJQM0ZCZ0FGeU9nQU5RUU1NQXdzZ0FpQUJPZ0FNSUFKQkRHb2hBRUVCREFJTElBSWdBVUUvY1VHQUFYSTZBQTBnQWlBQlFRWjJRY0FCY2pvQURDQUNRUXhxSVFCQkFnd0JDeUFDSUFGQlAzRkJnQUZ5T2dBUElBSWdBVUVTZGtId0FYSTZBQXdnQWlBQlFRWjJRVDl4UVlBQmNqb0FEaUFDSUFGQkRIWkJQM0ZCZ0FGeU9nQU5RUVFMSVFFZ0FDQUJFQXNnQWtFUWFpUUFDL2tCQVFKL0l3QkJFR3NpQWlRQUlBSkJBRFlDREFKL0FrQUNRQ0FCUVlBQlR3UkFJQUZCZ0JCSkRRRWdBa0VNYWlFRElBRkJnSUFFVHcwQ0lBSWdBVUUvY1VHQUFYSTZBQTRnQWlBQlFReDJRZUFCY2pvQURDQUNJQUZCQm5aQlAzRkJnQUZ5T2dBTlFRTU1Bd3NnQWlBQk9nQU1JQUpCREdvaEEwRUJEQUlMSUFJZ0FVRS9jVUdBQVhJNkFBMGdBaUFCUVFaMlFjQUJjam9BRENBQ1FReHFJUU5CQWd3QkN5QUNJQUZCUDNGQmdBRnlPZ0FQSUFJZ0FVRVNka0h3QVhJNkFBd2dBaUFCUVFaMlFUOXhRWUFCY2pvQURpQUNJQUZCREhaQlAzRkJnQUZ5T2dBTlFRUUxJUUVnQUNBRElBRVFDeUFDUVJCcUpBQUwvQUVCQTM4akFFRWdheUlFSkFBQ1FDQUNRUUZxSWdNZ0FrOEVRQ0FCS0FJRUlnSkJBWFFpQlNBRElBVWdBMHNiSWdOQkJDQURRUVJMR3lJRFFmLy8vLzhEY1NBRFJrRUJkQ0VGSUFOQkFuUWhBd0pBSUFJRVFDQUVRUmhxUVFJMkFnQWdCQ0FDUVFKME5nSVVJQVFnQVNnQ0FEWUNFQXdCQ3lBRVFRQTJBaEFMSUFRZ0F5QUZJQVJCRUdvUUpVRUJJUUlnQkVFSWFpZ0NBQ0VESUFRb0FnUWhCU0FFS0FJQVFRRkhCRUFnQVNBRk5nSUFJQUVnQTBFQ2RqWUNCRUVBSVFJTUFnc2dBQ0FGTmdJRUlBQkJDR29nQXpZQ0FBd0JDeUFBSUFNMkFnUWdBRUVJYWtFQU5nSUFRUUVoQWdzZ0FDQUNOZ0lBSUFSQklHb2tBQXZ3QVFFRWZ5TUFRU0JySWdRa0FBSkFJQUpCQVdvaUF5QUNUd1JBSUFFb0FnUWlCVUVCZENJQ0lBTWdBaUFEU3hzaUEwRUVJQU5CQkVzYklnTWdBMm9pQmlBRFQwRUJkQ0VEQWtBZ0JRUkFJQVJCR0dwQkFqWUNBQ0FFSUFJMkFoUWdCQ0FCS0FJQU5nSVFEQUVMSUFSQkFEWUNFQXNnQkNBR0lBTWdCRUVRYWhBbFFRRWhBaUFFUVFocUtBSUFJUU1nQkNnQ0JDRUZJQVFvQWdCQkFVY0VRQ0FCSUFVMkFnQWdBU0FEUVFGMk5nSUVRUUFoQWd3Q0N5QUFJQVUyQWdRZ0FFRUlhaUFETmdJQURBRUxJQUFnQXpZQ0JDQUFRUWhxUVFBMkFnQkJBU0VDQ3lBQUlBSTJBZ0FnQkVFZ2FpUUFDK2dCQVFWL0l3QkJFR3NpQXlRQUlBQXRBQXNoQWlBRFFnQTNBd2dnQVNnQ0FDRUZBa0FDUUNBQUFuOGdBU2dDQkNJRVFjQUFJQUpySWdaQitBRnhRUU4ySWdKSkJFQWdCRUVKVHcwQ0lBTkJDR29nQlNBRUVFa2FJQUZCQURZQ0JDQUJRYStGd0FBMkFnQWdCRUVEZEF3QkN5QUdRZjhCY1VISUFFOE5BaUFEUVFocUlBVWdBaEJKR2lBQklBUWdBbXMyQWdRZ0FTQUNJQVZxTmdJQUlBWkIrQUZ4Q3lBQUxRQUxJZ0ZxT2dBTElBQWdBQ2tEQUNBREtRTUlJQUZCUDNHdGhvUTNBd0FnQTBFUWFpUUFEd3NnQkVFSVFaQ0h3QUFRTmdBTElBSkJDRUdBaDhBQUVEWUFDODhCQVFOL0FrQWdBRUVFYWlnQ0FDSUVJQUJCQ0dvb0FnQWlBMnNnQWs4RVFDQUFLQUlBSVFRTUFRc0Nmd0pBQWtBZ0FpQURhaUlGSUFOSkRRQWdCRUVCZENJRElBVWdBeUFGU3hzaUEwRUlJQU5CQ0VzYklRTWdCQVJBSUFOQkFFZ05BU0FBS0FJQUlnVkZEUUlnQlNBRVFRRWdBeEJVREFNTElBTkJBRTROQVFzUVd3QUxJQU5CQVJCWEN5SUVCRUFnQUNBRU5nSUFJQUJCQkdvZ0F6WUNBQ0FBUVFocUtBSUFJUU1NQVFzZ0EwRUJFRjhBQ3lBRElBUnFJQUVnQWhCSkdpQUFRUWhxSUFJZ0EybzJBZ0FMM0FFQkJIOGpBRUZBYWlJQ0pBQWdBVUVFYWlFRUlBRW9BZ1JGQkVBZ0FTZ0NBQ0VESUFKQkFEWUNJQ0FDUWdFM0F4Z2dBaUFDUVJocU5nSWtJQUpCT0dvZ0EwRVFhaWtDQURjREFDQUNRVEJxSUFOQkNHb3BBZ0EzQXdBZ0FpQURLUUlBTndNb0lBSkJKR3BCd0lqQUFDQUNRU2hxRUFrYUlBSkJFR29pQXlBQ0tBSWdOZ0lBSUFJZ0Fpa0RHRGNEQ0FKQUlBRW9BZ1FpQlVVTkFDQUJRUWhxS0FJQVJRMEFJQVVRQkFzZ0JDQUNLUU1JTndJQUlBUkJDR29nQXlnQ0FEWUNBQXNnQUVIa2ljQUFOZ0lFSUFBZ0JEWUNBQ0FDUVVCckpBQUxuZ0lCQW44akFFRWdheUlESkFCQkFTRUVRZENsd0FCQjBLWEFBQ2dDQUVFQmFqWUNBQUpBQWtBQ1FFR1lxY0FBS0FJQVFRRkhCRUJCbUtuQUFFS0JnSUNBRURjREFBd0JDMEdjcWNBQVFaeXB3QUFvQWdCQkFXb2lCRFlDQUNBRVFRSkxEUUVMSUFNZ0FqWUNIQ0FESUFFMkFoZ2dBMEhZaU1BQU5nSVVJQU5CMklqQUFEWUNFRUhFcGNBQUtBSUFJZ0ZCZjB3TkFFSEVwY0FBSUFGQkFXb2lBVFlDQUVIRXBjQUFRY3lsd0FBb0FnQWlBZ1IvUWNpbHdBQW9BZ0FnQTBFSWFpQUFRZUNKd0FBb0FnQVJBZ0FnQXlBREtRTUlOd01RSUFOQkVHb2dBaWdDREJFQ0FFSEVwY0FBS0FJQUJTQUJDMEYvYWpZQ0FDQUVRUUZORFFFTEFBc2pBRUVRYXlJQkpBQWdBVUhRaWNBQU5nSU1JQUVnQURZQ0NBQUx6QUVCQW44Z0FVRVVhaWdDQUNJRklBTkIvLzhEY1NJRVN3UkFJQUVvQWd3Z0JFRUJkR292QVFBaEJTQUJLQUlJSWdRZ0FTZ0NCRVlFUUNBQklBUVFPaUFCS0FJSUlRUUxJQUVvQWdBZ0JFRUNkR29pQkNBQ09nQUNJQVFnQXpzQkFDQUJJQUVvQWdoQkFXbzJBZ2dnQVNnQ0ZDSUVJQUZCRUdvb0FnQkdCRUFnQVVFTWFpQUVFRHNnQVNnQ0ZDRUVDeUFCS0FJTUlBUkJBWFJxSUFWQkFXbzdBUUFnQVNBQktBSVVRUUZxTmdJVUlBQWdBam9BQWlBQUlBTTdBUUFQQ3lBRUlBVkJzSWpBQUJBMUFBdkpBUUVDZnlNQVFSQnJJZ0lrQUNBQktBSVlRWW1sd0FCQkNTQUJRUnhxS0FJQUtBSU1FUUVBSVFNZ0FrRUFPZ0FGSUFJZ0F6b0FCQ0FDSUFFMkFnQWdBaUFBTmdJTUlBSWdBa0VNYWhBU0lBSXRBQVFoQVNBQ0xRQUZCRUFnQVVIL0FYRWhBQ0FDQW45QkFTQUFEUUFhSUFJb0FnQWlBRUVjYWlnQ0FDZ0NEQ0VCSUFBb0FoZ2hBeUFBTFFBQVFRUnhSUVJBSUFOQnU0ekFBRUVDSUFFUkFRQU1BUXNnQTBHNmpNQUFRUUVnQVJFQkFBc2lBVG9BQkFzZ0FrRVFhaVFBSUFGQi93RnhRUUJIQzdZQkFRSi9Ba0FDZnlBQ1JRUkFJQUVoQkVFQUlRRkJBUXdCQ3lBQlFRQklCRUJCQVNFRFFRQWhBUXdDQ3dKQUFrQUNRQ0FES0FJQUlnVkZCRUFnQVVVTkFTQUJJQUlRVnlJRURRSU1Bd3NnQTBFSWFpZ0NBQ0VFSUFNb0FnUWlBd1JBSUFVZ0F5QUVJQUVRVkNJRVJRMEREQUlMSUFGRkRRRWdBU0FFRUZjaUJFVU5BZ3dCQ3lBQ0lRUUxRUUFNQVFzZ0FTRUVJQUloQVVFQkN5RURJQUFnQkRZQ0JBc2dBQ0FETmdJQUlBQkJDR29nQVRZQ0FBdWZBUUVEZnlBQVFnQTNBZ2dDUUNBQlFSUnFLQUlBSWdRZ0FrSC8vd054SWdOTEJFQWdBU2dDRENBRFFRRjBhaThCQUNFRElBQW9BZ1FoQkNBQVFRQTJBZ1FnQUNnQ0FDRUZJQUJCQVRZQ0FDQUVJQU5KRFFFZ0FTQUNJQVVnQXhBcElBQW9BZ1FFUUNBQUtBSUFFQVFMSUFBZ0F6WUNEQ0FBSUFRMkFnUWdBQ0FGTmdJQUR3c2dBeUFFUWRDSHdBQVFOUUFMSUFNZ0JFSGdoOEFBRURZQUM0Y0JBUUovSXdCQk1Hc2lCQ1FBSUFSQklHb2lCU0FDTmdJSUlBVWdBallDQkNBRklBRTJBZ0FnQkVFSWFpQUVRU0JxRUV3Z0JFRVFhaUFFS0FJSUlnRWdCQ2dDRENJQ0lBTVFHU0FDQkVBZ0FSQUVDeUFFUVNocUlBUkJHR29vQWdBMkFnQWdCQ0FFS1FNUU53TWdJQVFnQkVFZ2FoQk1JQUFnQkNrREFEY0RBQ0FFUVRCcUpBQUxnZ0VCQm44akFFRVFheUlESkFBZ0FDQUFLQUlJSUFFUU9TQUFLQUlBSVFVZ0FDZ0NDQ0VDSUFOQkNHcEJBU0FCRUZnZ0FpQUZhaUVFSUFNb0Fnd2lCaUFES0FJSUlnZExCRUFnQkNBR0lBZHJFRkVnQlNBQ0lBWnFJQWRySWdKcUlRUUxJQUFnQVFSL0lBUkJBRG9BQUNBQ1FRRnFCU0FDQ3pZQ0NDQURRUkJxSkFBTGpnRUJBMzhnQUNnQ0NDSUVJQUZCLy84RGNTSUZTd1JBSUFNRVFDQUFLQUlBSVFRZ0FrRi9haUVGSUFFaEFBTkFJQVFnQUVILy93TnhRUUowYWlJR0x3RUFJUUFnQXlBRmFpQUdMUUFDT2dBQUlBQWdBU0FBSUFGQi8vOERjVWtiSVFBZ0EwRi9haUlERFFBTElBSXRBQUFQQzBFQVFRQkJnSWpBQUJBMUFBc2dCVUVCYWlBRVFmQ0h3QUFRTmdBTFdBRURmeU1BUWRBQWF5SUJKQUFnQVJBV1FkQUFRUWdRVnlJQ0JFQWdBaUFCUWRBQUVFa2FRYmlFd0FBaEF5QUNRUUU2QUVnZ0FFRzRoTUFBTmdJRUlBQWdBallDQUNBQlFkQUFhaVFBRHd0QjBBQkJDQkJmQUF1QUFRSUNmd0YrSUFFdEFBc2lCQ0FCTFFBS0lnTkpCRUFnQVNBQ0VCY2dBUzBBQ3lFRUlBRXRBQW9oQXdzZ0JDQURRZjhCY1VrRWYwRUFCU0FCSUFRZ0EyczZBQXNnQVNBQktRTUFJQU90aVNJRklBRXZBUWdpQWExQ2Y0VkNnSUI4aElNM0F3QWdBU0FGcDNFaEEwRUJDeUVCSUFBZ0F6c0JBaUFBSUFFN0FRQUxlZ0VEZnlBQktBSUVJZ01nQWs4RVFBSkFJQU5GRFFBZ0FTZ0NBQ0VFQWtBZ0FnUkFJQVFnQTBFQklBSVFWQ0lERFFFZ0FDQUNOZ0lFSUFCQkNHcEJBVFlDQUVFQklRVU1BZ3RCQVNFRElBUVFCQXNnQVNBQ05nSUVJQUVnQXpZQ0FBc2dBQ0FGTmdJQUR3dEJ5NExBQUVFa1FmQ0N3QUFRUndBTGRRSUNmd0YrSUFFdEFBc2lCQ0FCTFFBS0lnTkpCRUFnQVNBQ0VCOGdBUzBBQ3lFRUlBRXRBQW9oQXdzZ0JDQURRZjhCY1VrRWYwRUFCU0FCSUFRZ0EyczZBQXNnQVNBQktRTUFJZ1VnQTYxQ1A0T0lOd01BSUFFdkFRZ2dCYWR4SVFOQkFRc2hBU0FBSUFNN0FRSWdBQ0FCT3dFQUMzUUJBMzhqQUVFZ2F5SUNKQUFDUUNBQUlBRVFHRVVFUUNBQlFSeHFLQUlBSVFNZ0FTZ0NHQ0FDUVJ4cVFRQTJBZ0FnQWtHMGlzQUFOZ0lZSUFKQ0FUY0NEQ0FDUWJpS3dBQTJBZ2dnQXlBQ1FRaHFFQWxGRFFFTElBSkJJR29rQUVFQkR3c2dBRUVFYWlBQkVCZ2dBa0VnYWlRQUN6QUJBWDhDUUFKQVFZQ0FBVUVDRUZjaUFRMEJEQUFMUVlDQUFVRUNFRjhBQ3lBQUlBRTJBZ0FnQUVHQUlEWUNCQXVHQVFFQmZ5TUFRVUJxSWdFa0FDQUJRU3MyQWd3Z0FVR0VnY0FBTmdJSUlBRkJzSUhBQURZQ0ZDQUJJQUEyQWhBZ0FVRXNha0VDTmdJQUlBRkJQR3BCSFRZQ0FDQUJRZ0kzQWh3Z0FVSHdpc0FBTmdJWUlBRkJHVFlDTkNBQklBRkJNR28yQWlnZ0FTQUJRUkJxTmdJNElBRWdBVUVJYWpZQ01DQUJRUmhxUWZTQXdBQVFVQUFMTUFFQmZ3SkFBa0JCZ01BQVFRSVFWeUlCRFFFTUFBdEJnTUFBUVFJUVh3QUxJQUFnQVRZQ0FDQUFRWUFnTmdJRUMzc0JBbjhDUUFKQUlBQW9BZ1FpQVFSQUlBQW9BZ3dpQWlBQlR3MEJJQUFvQWdBaUFTQUNhaUFCTFFBQU9nQUFJQUJCQURZQ0NDQUFJQUFvQWd4QkFXbzJBZ3dnQUNnQ0JFVU5BaUFBS0FJQUxRQUFEd3RCQUVFQVFhQ0h3QUFRTlFBTElBSWdBVUd3aDhBQUVEVUFDMEVBUVFCQndJZkFBQkExQUF0b0FRSi9JQUFnQUMwQVJpSUJRUUZxSWdJNkFBb2dBRUVCSUFGQkQzRjBRUUpxSWdFN0FVQWdBRUYvSUFKQkQzRjBRWDl6T3dFSUlBQkJHR29vQWdBZ0FVSC8vd054SWdGUEJFQWdBQ0FCTmdJWUN5QUFRU1JxS0FJQUlBRlBCRUFnQUNBQk5nSWtDd3RRQVFGL0lBQkJGR29vQWdBaUFVVWdBVUVDZEVWeVJRUkFJQUFvQWhBUUJBc2dBRUVnYWlnQ0FDSUJSU0FCUVFGMFJYSkZCRUFnQUNnQ0hCQUVDeUFBUVN4cUtBSUFCRUFnQUNnQ0tCQUVDd3RzQVFGL0l3QkJNR3NpQXlRQUlBTWdBVFlDQkNBRElBQTJBZ0FnQTBFY2FrRUNOZ0lBSUFOQkxHcEJHRFlDQUNBRFFnSTNBZ3dnQTBIRWk4QUFOZ0lJSUFOQkdEWUNKQ0FESUFOQklHbzJBaGdnQXlBRE5nSW9JQU1nQTBFRWFqWUNJQ0FEUVFocUlBSVFVQUFMYkFFQmZ5TUFRVEJySWdNa0FDQURJQUUyQWdRZ0F5QUFOZ0lBSUFOQkhHcEJBallDQUNBRFFTeHFRUmcyQWdBZ0EwSUNOd0lNSUFOQmtKREFBRFlDQ0NBRFFSZzJBaVFnQXlBRFFTQnFOZ0lZSUFNZ0EwRUVhallDS0NBRElBTTJBaUFnQTBFSWFpQUNFRkFBQzJ3QkFYOGpBRUV3YXlJREpBQWdBeUFCTmdJRUlBTWdBRFlDQUNBRFFSeHFRUUkyQWdBZ0EwRXNha0VZTmdJQUlBTkNBamNDRENBRFFjU1F3QUEyQWdnZ0EwRVlOZ0lrSUFNZ0EwRWdhallDR0NBRElBTkJCR28yQWlnZ0F5QUROZ0lnSUFOQkNHb2dBaEJRQUF0c0FRRi9Jd0JCTUdzaUF5UUFJQU1nQVRZQ0JDQURJQUEyQWdBZ0EwRWNha0VDTmdJQUlBTkJMR3BCR0RZQ0FDQURRZ0kzQWd3Z0EwSHdqOEFBTmdJSUlBTkJHRFlDSkNBRElBTkJJR28yQWhnZ0F5QURRUVJxTmdJb0lBTWdBellDSUNBRFFRaHFJQUlRVUFBTFhBRUJmeU1BUVJCcklnTWtBQUpBSUFBb0FnUWdBV3NnQWs4RVFDQURRUUEyQWdBTUFRc2dBeUFBSUFFZ0FoQVZJQU1vQWdCQkFVY05BQ0FEUVFocUtBSUFJZ0FFUUNBREtBSUVJQUFRWHdBTEVGc0FDeUFEUVJCcUpBQUxXZ0VCZnlNQVFSQnJJZ0lrQUFKQUlBQW9BZ1FnQVd0QkFVOEVRQ0FDUVFBMkFnQU1BUXNnQWlBQUlBRVFIU0FDS0FJQVFRRkhEUUFnQWtFSWFpZ0NBQ0lBQkVBZ0FpZ0NCQ0FBRUY4QUN4QmJBQXNnQWtFUWFpUUFDMW9CQVg4akFFRVFheUlDSkFBQ1FDQUFLQUlFSUFGclFRRlBCRUFnQWtFQU5nSUFEQUVMSUFJZ0FDQUJFQjRnQWlnQ0FFRUJSdzBBSUFKQkNHb29BZ0FpQUFSQUlBSW9BZ1FnQUJCZkFBc1FXd0FMSUFKQkVHb2tBQXRaQVFGL0l3QkJJR3NpQWlRQUlBSWdBQ2dDQURZQ0JDQUNRUmhxSUFGQkVHb3BBZ0EzQXdBZ0FrRVFhaUFCUVFocUtRSUFOd01BSUFJZ0FTa0NBRGNEQ0NBQ1FRUnFRY0NJd0FBZ0FrRUlhaEFKSUFKQklHb2tBQXRHQUFKQVFRZ2dBa2tFUUFKL1FRZ2dBa2tFUUNBQ0lBTVFFQXdCQ3lBREVBQUxJZ0lOQVVFQUR3c2dBQ0FERUFvUEN5QUNJQUFnQXlBQklBRWdBMHNiRUVrZ0FCQUVDMWtCQVg4akFFRWdheUlDSkFBZ0FpQUFLQUlBTmdJRUlBSkJHR29nQVVFUWFpa0NBRGNEQUNBQ1FSQnFJQUZCQ0dvcEFnQTNBd0FnQWlBQktRSUFOd01JSUFKQkJHcEJ0STdBQUNBQ1FRaHFFQWtnQWtFZ2FpUUFDMWtBQWtBQ1FBSkFJQUZCZjBvRVFBSkFJQUlFUUNBQkRRRU1CQXNnQVVVTkF5QUJRUUVRVnlJQ0RRUU1BZ3NnQVJCR0lnSkZEUUVNQXdzUVd3QUxJQUZCQVJCZkFBdEJBU0VDQ3lBQUlBRTJBZ1FnQUNBQ05nSUFDMVlCQVg4akFFRWdheUlDSkFBZ0FpQUFOZ0lFSUFKQkdHb2dBVUVRYWlrQ0FEY0RBQ0FDUVJCcUlBRkJDR29wQWdBM0F3QWdBaUFCS1FJQU53TUlJQUpCQkdwQnRJN0FBQ0FDUVFocUVBa2dBa0VnYWlRQUMxa0JBMzhDUUNBQktBSU1JZ0lnQVNnQ0NDSURUd1JBSUFFb0FnUWlCQ0FDU1EwQklBRW9BZ0FoQVNBQUlBSWdBMnMyQWdRZ0FDQUJJQU5xTmdJQUR3c2dBeUFDUVpDSXdBQVFOd0FMSUFJZ0JFR1FpTUFBRURZQUMxVUJBWDhnQUVFUWFpQUFMUUJHRUEwZ0FFRUFPZ0JISUFCQkFEc0JPQ0FBUVRCcVFnQTNBd0FnQUVFQU9nQUxJQUJDQURjREFDQUFJQUF0QUVaQkFXb2lBVG9BQ2lBQVFYOGdBVUVQY1hSQmYzTTdBUWdMUXdFRGZ3SkFJQUpGRFFBRFFDQUFMUUFBSWdRZ0FTMEFBQ0lGUmdSQUlBQkJBV29oQUNBQlFRRnFJUUVnQWtGL2FpSUNEUUVNQWdzTElBUWdCV3NoQXdzZ0F3dEZBUUYvSXdCQkVHc2lBaVFBSUFJZ0FDQUJFQ3dDUUNBQ0tBSUFRUUZHQkVBZ0FrRUlhaWdDQUNJQVJRMEJJQUlvQWdRZ0FCQmZBQXNnQWtFUWFpUUFEd3NRV3dBTFNnQUNmeUFCUVlDQXhBQkhCRUJCQVNBQUtBSVlJQUVnQUVFY2FpZ0NBQ2dDRUJFQUFBMEJHZ3NnQWtVRVFFRUFEd3NnQUNnQ0dDQUNJQU1nQUVFY2FpZ0NBQ2dDREJFQkFBc0xKZ0VCZndKQUlBQVFBQ0lCUlEwQUlBRkJmR290QUFCQkEzRkZEUUFnQVNBQUVGRUxJQUVMUndFQmZ5TUFRU0JySWdNa0FDQURRUlJxUVFBMkFnQWdBMEcwaXNBQU5nSVFJQU5DQVRjQ0JDQURJQUUyQWh3Z0F5QUFOZ0lZSUFNZ0EwRVlhallDQUNBRElBSVFVQUFMV3dFRGZ5TUFRUkJySWdFa0FDQUFLQUlNSWdKRkJFQkI2SWpBQUVFclFiQ0p3QUFRUndBTElBQW9BZ2dpQTBVRVFFSG9pTUFBUVN0QndJbkFBQkJIQUFzZ0FTQUNOZ0lJSUFFZ0FEWUNCQ0FCSUFNMkFnQWdBUkJQQUFzekFRRi9JQUlFUUNBQUlRTURRQ0FESUFFdEFBQTZBQUFnQVVFQmFpRUJJQU5CQVdvaEF5QUNRWDlxSWdJTkFBc0xJQUFMS2dBQ1FDQUFRWHhMRFFBZ0FFVUVRRUVFRHdzZ0FDQUFRWDFKUVFKMEVGY2lBRVVOQUNBQUR3c0FDekVCQVg4Z0FTZ0NCQ0lDQkVBZ0FDQUNOZ0lFSUFCQkNHcEJBVFlDQUNBQUlBRW9BZ0EyQWdBUEN5QUFRUUEyQWdBTE1RRUJmeUFBSUFFb0FnUWdBU2dDQ0NJQ1N3Ui9JQUVnQWhCRUlBRW9BZ2dGSUFJTE5nSUVJQUFnQVNnQ0FEWUNBQXN3QVFGL0l3QkJFR3NpQVNRQUlBRkJBRFlDQkNBQklBQW9BZ0EyQWdBZ0FTQUFLQUlFS0FJSUlBQW9BZ2dRSWdBTEtBRUJmeUFBS0FJSUlnSWdBVThFUUNBQUtBSUFHaUFBSUFFMkFnZ1BDeUFBSUFFZ0Ftc1FLQXNzQVFGL0l3QkJFR3NpQVNRQUlBRkJDR29nQUVFSWFpZ0NBRFlDQUNBQklBQXBBZ0EzQXdBZ0FSQk5BQXMwQVFGL0l3QkJFR3NpQWlRQUlBSWdBVFlDRENBQ0lBQTJBZ2dnQWtHQWk4QUFOZ0lFSUFKQnRJckFBRFlDQUNBQ0VFZ0FDeUVBSUFFRVFBTkFJQUJCQURvQUFDQUFRUUZxSVFBZ0FVRi9haUlCRFFBTEN3c2dBUUYvQWtBZ0FDZ0NBQ0lCUlEwQUlBQkJCR29vQWdCRkRRQWdBUkFFQ3dzZ0FRRi9Ba0FnQUNnQ0JDSUJSUTBBSUFCQkNHb29BZ0JGRFFBZ0FSQUVDd3NNQUNBQUlBRWdBaUFERUQwTEN3QWdBUVJBSUFBUUJBc0xGQUFnQUNnQ0FDQUJJQUFvQWdRb0Fnd1JBQUFMR1FBQ2YwRUlJQUZKQkVBZ0FTQUFFQkFNQVFzZ0FCQUFDd3NRQUNBQUlBSTJBZ1FnQUNBQk5nSUFDdzhBSUFBb0FnQWdBU0FDRUNCQkFBc1FBQ0FCSUFBb0FnQWdBQ2dDQkJBRkN4RUFRWkNLd0FCQkVVR2tpc0FBRUVjQUN3NEFJQUFvQWdBYUEwQU1BQXNBQ3dzQUlBQTFBZ0FnQVJBVUN3MEFJQUFvQWdBZ0FTQUNFQXNMR1FBZ0FDQUJRY0Nsd0FBb0FnQWlBRUVOSUFBYkVRSUFBQXNOQUNBQlFZaVB3QUJCQWhBRkN3a0FJQUJCQURvQVJ3c0hBQ0FBTFFCSEN3MEFRcnFaejdiQWlxNzYxZ0FMREFCQ3dJcjY4K2l6bzYxQUN3TUFBUXNEQUFFTEM2TWxBUUJCZ0lEQUFBdVpKUzlWYzJWeWN5OTBjbVYyYjNKdFlXNTZMeTV5ZFhOMGRYQXZkRzl2YkdOb1lXbHVjeTlpWlhSaExYZzRObDgyTkMxaGNIQnNaUzFrWVhKM2FXNHZiR2xpTDNKMWMzUnNhV0l2YzNKakwzSjFjM1F2YkdsaWNtRnllUzlqYjNKbEwzTnlZeTloYkd4dll5OXNZWGx2ZFhRdWNuTUFBQUFRQUhNQUFBQUtBUUFBT1FBQUFHTmhiR3hsWkNCZ1VtVnpkV3gwT2pwMWJuZHlZWEFvS1dBZ2IyNGdZVzRnWUVWeWNtQWdkbUZzZFdVQUFRQUFBQUFBQUFBQkFBQUFBZ0FBQUhOeVl5OXNhV0l1Y25NQUFNQUFFQUFLQUFBQUhRQUFBQklBQUFBdlZYTmxjbk12ZEhKbGRtOXliV0Z1ZWk4dWNuVnpkSFZ3TDNSdmIyeGphR0ZwYm5NdlltVjBZUzE0T0RaZk5qUXRZWEJ3YkdVdFpHRnlkMmx1TDJ4cFlpOXlkWE4wYkdsaUwzTnlZeTl5ZFhOMEwyeHBZbkpoY25rdllXeHNiMk12YzNKakwzSmhkMTkyWldNdWNuTlVjbWxsWkNCMGJ5QnphSEpwYm1zZ2RHOGdZU0JzWVhKblpYSWdZMkZ3WVdOcGRIa0EzQUFRQUc4QUFBRE9BUUFBQ1FBQUFHRnpjMlZ5ZEdsdmJpQm1ZV2xzWldRNklHMXBaQ0E4UFNCc1pXNHZWWE5sY25NdmRISmxkbTl5YldGdWVpOHVjblZ6ZEhWd0wzUnZiMnhqYUdGcGJuTXZZbVYwWVMxNE9EWmZOalF0WVhCd2JHVXRaR0Z5ZDJsdUwyeHBZaTl5ZFhOMGJHbGlMM055WXk5eWRYTjBMMnhwWW5KaGNua3ZZMjl5WlM5emNtTXZjMnhwWTJVdmJXOWtMbkp6bkFFUUFIQUFBQUNqQkFBQURRQUFBQU1BQUFCUUFBQUFDQUFBQUFRQUFBQUZBQUFBQmdBQUFBY0FBQUFJQUFBQVVBQUFBQWdBQUFBSkFBQUFDZ0FBQUFzQUFBQU1BQUFBTDFWelpYSnpMM1J5WlhadmNtMWhibm92TG1OaGNtZHZMM0psWjJsemRISjVMM055WXk5bmFYUm9kV0l1WTI5dExURmxZMk0yTWprNVpHSTVaV000TWpNdmQyVmxlbXd0TUM0eExqQXZjM0pqTDJSbFkyOWtaUzV5Y3dCVUFoQUFXd0FBQVA4QkFBQWZBQUFBVkFJUUFGc0FBQUFTQWdBQUd3QUFBRlFDRUFCYkFBQUFKd0lBQUNZQUFBQlVBaEFBV3dBQUFGQUNBQUFSQUFBQVZBSVFBRnNBQUFCU0FnQUFFUUFBQUZRQ0VBQmJBQUFBWGdJQUFCa0FBQUJVQWhBQVd3QUFBSElDQUFBaUFBQUFWQUlRQUZzQUFBQjBBZ0FBR3dBQUFGUUNFQUJiQUFBQWRRSUFBQlVBQUFCVUFoQUFXd0FBQUhZQ0FBQVZBQUFBVkFJUUFGc0FBQUNnQWdBQURRQUFBRlFDRUFCYkFBQUE3QUlBQUJFQUFBQlVBaEFBV3dBQUFQSUNBQUFSQUFBQVZBSVFBRnNBQUFBeEF3QUFFUUFBQUZRQ0VBQmJBQUFBTndNQUFCRUFBQUJVQWhBQVd3QUFBRjhEQUFBbkFBQUFWQUlRQUZzQUFBQmZBd0FBQ1FBQUFGUUNFQUJiQUFBQVlnTUFBQWtBQUFCVUFoQUFXd0FBQUdnREFBQVZBQUFBVkFJUUFGc0FBQUJyQXdBQUdBQUFBRlFDRUFCYkFBQUFkUU1BQUJZQUFBQlVBaEFBV3dBQUFJQURBQUFKQUFBQVZBSVFBRnNBQUFDRUF3QUFDZ0FBQUZRQ0VBQmJBQUFBcWdNQUFBb0FBQUJVQWhBQVd3QUFBTGNEQUFBVkFBQUFEZ0FBQUFRQUFBQUVBQUFBRHdBQUFCQUFBQUFSQUFBQURnQUFBQUFBQUFBQkFBQUFFZ0FBQUdOaGJHeGxaQ0JnVDNCMGFXOXVPanAxYm5keVlYQW9LV0FnYjI0Z1lTQmdUbTl1WldBZ2RtRnNkV1ZzYVdKeVlYSjVMM04wWkM5emNtTXZjR0Z1YVdOcmFXNW5Mbkp6QUpNRUVBQWNBQUFBMlFFQUFCOEFBQUNUQkJBQUhBQUFBTm9CQUFBZUFBQUFFd0FBQUJBQUFBQUVBQUFBRkFBQUFCVUFBQUFXQUFBQURBQUFBQVFBQUFBWEFBQUFiR2xpY21GeWVTOWhiR3h2WXk5emNtTXZjbUYzWDNabFl5NXljMk5oY0dGamFYUjVJRzkyWlhKbWJHOTNBQUFBOUFRUUFCd0FBQUFaQWdBQUJRQUFBR0F1TGdBMUJSQUFBZ0FBQUdOaGJHeGxaQ0JnVDNCMGFXOXVPanAxYm5keVlYQW9LV0FnYjI0Z1lTQmdUbTl1WldBZ2RtRnNkV1U2SUFBQUFEUUZFQUFBQUFBQWF3VVFBQUlBQUFBZUFBQUFBQUFBQUFFQUFBQWZBQUFBYVc1a1pYZ2diM1YwSUc5bUlHSnZkVzVrY3pvZ2RHaGxJR3hsYmlCcGN5QWdZblYwSUhSb1pTQnBibVJsZUNCcGN5QUFBSkFGRUFBZ0FBQUFzQVVRQUJJQUFBQnNhV0p5WVhKNUwyTnZjbVV2YzNKakwyWnRkQzlpZFdsc1pHVnljeTV5Y3g0QUFBQU1BQUFBQkFBQUFDQUFBQUFoQUFBQUlnQUFBQ0FnSUNEVUJSQUFJQUFBQURBQUFBQWhBQUFBMUFVUUFDQUFBQUF4QUFBQUVnQUFBQ0I3Q2l3S0xDQWdleUI5SUgxc2FXSnlZWEo1TDJOdmNtVXZjM0pqTDJadGRDOXVkVzB1Y25NOUJoQUFHd0FBQUZRQUFBQVVBQUFBTUhnd01EQXhNREl3TXpBME1EVXdOakEzTURnd09URXdNVEV4TWpFek1UUXhOVEUyTVRjeE9ERTVNakF5TVRJeU1qTXlOREkxTWpZeU56STRNamt6TURNeE16SXpNek0wTXpVek5qTTNNemd6T1RRd05ERTBNalF6TkRRME5UUTJORGMwT0RRNU5UQTFNVFV5TlRNMU5EVTFOVFkxTnpVNE5UazJNRFl4TmpJMk16WTBOalUyTmpZM05qZzJPVGN3TnpFM01qY3pOelEzTlRjMk56YzNPRGM1T0RBNE1UZ3lPRE00TkRnMU9EWTROemc0T0RrNU1Ea3hPVEk1TXprME9UVTVOamszT1RnNU9RQUFIZ0FBQUFRQUFBQUVBQUFBSXdBQUFDUUFBQUFsQUFBQWJHbGljbUZ5ZVM5amIzSmxMM055WXk5bWJYUXZiVzlrTG5KekFFd0hFQUFiQUFBQVdRUUFBQkVBQUFCTUJ4QUFHd0FBQUdNRUFBQWtBQUFBS0Nsc2FXSnlZWEo1TDJOdmNtVXZjM0pqTDNOc2FXTmxMMjFsYldOb2NpNXljd0FBaWdjUUFDQUFBQUJTQUFBQUJRQUFBSEpoYm1kbElITjBZWEowSUdsdVpHVjRJQ0J2ZFhRZ2IyWWdjbUZ1WjJVZ1ptOXlJSE5zYVdObElHOW1JR3hsYm1kMGFDQzhCeEFBRWdBQUFNNEhFQUFpQUFBQWNtRnVaMlVnWlc1a0lHbHVaR1Y0SUFBSUVBQVFBQUFBemdjUUFDSUFBQUJ6YkdsalpTQnBibVJsZUNCemRHRnlkSE1nWVhRZ0lHSjFkQ0JsYm1SeklHRjBJQUFnQ0JBQUZnQUFBRFlJRUFBTkFBQUFiR2xpY21GeWVTOWpiM0psTDNOeVl5OXpkSEl2Y0dGMGRHVnliaTV5Y3dCVUNCQUFId0FBQUxBQkFBQW1BQUFBV3k0dUxsMWllWFJsSUdsdVpHVjRJQ0JwY3lCdmRYUWdiMllnWW05MWJtUnpJRzltSUdBQUFJa0lFQUFMQUFBQWxBZ1FBQllBQUFBMEJSQUFBUUFBQUdKbFoybHVJRHc5SUdWdVpDQW9JRHc5SUNrZ2QyaGxiaUJ6YkdsamFXNW5JR0FBQU1RSUVBQU9BQUFBMGdnUUFBUUFBQURXQ0JBQUVBQUFBRFFGRUFBQkFBQUFJR2x6SUc1dmRDQmhJR05vWVhJZ1ltOTFibVJoY25rN0lHbDBJR2x6SUdsdWMybGtaU0FnS0dKNWRHVnpJQ2tnYjJZZ1lJa0lFQUFMQUFBQUNBa1FBQ1lBQUFBdUNSQUFDQUFBQURZSkVBQUdBQUFBTkFVUUFBRUFBQUJzYVdKeVlYSjVMMk52Y21VdmMzSmpMM1Z1YVdOdlpHVXZjSEpwYm5SaFlteGxMbkp6QUFBQVpBa1FBQ1VBQUFBS0FBQUFIQUFBQUdRSkVBQWxBQUFBR2dBQUFEWUFBQUFBQVFNRkJRWUdBd2NHQ0FnSkVRb2NDeGtNRkEwUURnMFBCQkFERWhJVENSWUJGd1VZQWhrREdnY2NBaDBCSHhZZ0F5c0RMQUl0Q3k0Qk1BTXhBaklCcHdLcEFxb0Vxd2o2QXZzRi9RVCtBLzhKclhoNWk0MmlNRmRZaTR5UUhCM2REZzlMVFB2OExpOC9YRjFmdGVLRWpZNlJrcW14dXJ2RnhzbkszdVRsL3dBRUVSSXBNVFEzT2pzOVNVcGRoSTZTcWJHMHVydkd5czdQNU9VQUJBME9FUklwTVRRNk8wVkdTVXBlWkdXRWtadWR5YzdQRFJFcFJVbFhaR1dOa2FtMHVydkZ5ZC9rNWZBTkVVVkpaR1dBaExLOHZyL1YxL0R4ZzRXTHBLYSt2OFhIenMvYTIwaVl2YzNHenM5SlRrOVhXVjVmaVk2UHNiYTN2OEhHeDljUkZoZGJYUGIzL3YrQURXMXgzdDhPRHg5dWJ4d2RYMzErcnErN3ZQb1dGeDRmUmtkT1QxaGFYRjUrZjdYRjFOWGM4UEgxY25PUGRIV1dMMThtTGkrbnI3ZS94OC9YMzVwQWw1Z3dqeC9Bd2M3L1RrOWFXd2NJRHhBbkwrN3ZibTgzUFQ5Q1JaQ1IvdjlUWjNYSXlkRFIyTm5uL3Y4QUlGOGlndDhFZ2tRSUd3UUdFWUdzRG9Dck5TZ0xnT0FER1FnQkJDOEVOQVFIQXdFSEJnY1JDbEFQRWdkVkJ3TUVIQW9KQXdnREJ3TUNBd01EREFRRkF3c0dBUTRWQlRvREVRY0dCUkFIVndjQ0J4VU5VQVJEQXkwREFRUVJCZzhNT2dRZEpWOGdiUVJxSllESUJZS3dBeG9HZ3YwRFdRY1ZDeGNKRkF3VURHb0dDZ1lhQmxrSEt3VkdDaXdFREFRQkF6RUxMQVFhQmdzRGdLd0dDZ1loUDB3RUxRTjBDRHdERHdNOEJ6Z0lLd1dDL3hFWUNDOFJMUU1nRUNFUGdJd0VncGNaQ3hXSWxBVXZCVHNIQWc0WUNZQ3pMWFFNZ05ZYURBV0Evd1dBM3d6dURRT0VqUU0zQ1lGY0ZJQzRDSURMS2pnRENnWTRDRVlJREFaMEN4NERXZ1JaQ1lDREdCd0tGZ2xNQklDS0JxdWtEQmNFTWFFRWdkb21Cd3dGQllDbEVZRnRFSGdvS2daTUJJQ05CSUMrQXhzRER3MEFCZ0VCQXdFRUFnZ0lDUUlLQlFzQ0RnUVFBUkVDRWdVVEVSUUJGUUlYQWhrTkhBVWRDQ1FCYWdOckFyd0MwUUxVRE5VSjFnTFhBdG9CNEFYaEF1Z0M3aUR3QlBnQytRTDZBdnNCRENjN1BrNVBqNTZlbndZSENUWTlQbGJ6ME5FRUZCZzJOMVpYZjZxdXI3MDE0QktIaVk2ZUJBME9FUklwTVRRNlJVWkpTazVQWkdWY3RyY2JIQWNJQ2dzVUZ6WTVPcWlwMk5rSk41Q1JxQWNLT3o1bWFZK1NiMS91NzFwaW1wc25LRldkb0tHanBLZW9yYnE4eEFZTERCVWRPajlGVWFhbnpNMmdCeGthSWlVK1A4WEdCQ0FqSlNZb016ZzZTRXBNVUZOVlZsaGFYRjVnWTJWbWEzTjRmWCtLcEtxdnNNRFFycTk1ekc1dmsxNGlld1VEQkMwRFpnTUJMeTZBZ2gwRE1ROGNCQ1FKSGdVckJVUUVEaXFBcWdZa0JDUUVLQWcwQ3dHQWtJRTNDUllLQ0lDWU9RTmpDQWt3RmdVaEF4c0ZBVUE0QkVzRkx3UUtCd2tIUUNBbkJBd0pOZ002QlJvSEJBd0hVRWszTXcwekJ5NElDb0VtVWs0b0NDcFdIQlFYQ1U0RUhnOUREaGtIQ2daSUNDY0pkUXMvUVNvR093VUtCbEVHQVFVUUF3V0FpMkllU0FnS2dLWmVJa1VMQ2dZTkV6a0hDallzQkJDQXdEeGtVd3hJQ1FwR1JSdElDRk1kT1lFSFJnb2RBMGRKTndNT0NBb0dPUWNLZ1RZWmdMY0JEeklOZzV0bWRRdUF4SXE4aEMrUDBZSkhvYm1DT1FjcUJBSmdKZ3BHQ2lnRkU0S3dXMlZMQkRrSEVVQUZDd0lPbC9nSWhOWXFDYUwzZ1I4eEF4RUVDSUdNaVFSckJRMERDUWNRazJDQTlncHpDRzRYUm9DYUZBeFhDUm1BaDRGSEE0VkNEeFdGVUN1QTFTMERHZ1FDZ1hBNkJRR0ZBSURYS1V3RUNnUUNneEZFVEQyQXdqd0dBUVJWQlJzMEFvRU9MQVJrREZZS2dLNDRIUTBzQkFrSEFnNEdnSnFEMkFnTkF3MERkQXhaQnd3VURBUTRDQW9HS0FnaVRvRlVEQlVEQXdVSENSa0hCd2tERFFjcGdNc2xDb1FHYkdsaWNtRnllUzlqYjNKbEwzTnlZeTkxYm1samIyUmxMM1Z1YVdOdlpHVmZaR0YwWVM1eWN3RHpEaEFBS0FBQUFFc0FBQUFvQUFBQTh3NFFBQ2dBQUFCWEFBQUFGZ0FBQVBNT0VBQW9BQUFBVWdBQUFENEFBQUFlQUFBQUJBQUFBQVFBQUFBbUFBQUFBQU1BQUlNRUlBQ1JCV0FBWFJPZ0FCSVhvQjRNSU9BZTd5d2dLeW93b0N0dnBtQXNBcWpnTEI3NzRDMEEvcUExbnYvZ05mMEJZVFlCQ3FFMkpBMWhONnNPNFRndkdDRTVNQnhoUnZNZW9VcndhbUZPVDIraFRwMjhJVTlsMGVGUEFOb2hVQURnNFZFdzRXRlQ3T0toVk5EbzRWUWdBQzVWOEFHL1ZRQndBQWNBTFFFQkFRSUJBZ0VCU0Fzd0ZSQUJaUWNDQmdJQ0FRUWpBUjRiV3dzNkNRa0JHQVFCQ1FFREFRVXJBM2NQQVNBM0FRRUJCQWdFQVFNSENnSWRBVG9CQVFFQ0JBZ0JDUUVLQWhvQkFnSTVBUVFDQkFJQ0F3TUJIZ0lEQVFzQ09RRUVCUUVDQkFFVUFoWUdBUUU2QVFFQ0FRUUlBUWNEQ2dJZUFUc0JBUUVNQVFrQktBRURBVGtEQlFNQkJBY0NDd0lkQVRvQkFnRUNBUU1CQlFJSEFnc0NIQUk1QWdFQkFnUUlBUWtCQ2dJZEFVZ0JCQUVDQXdFQkNBRlJBUUlIREFoaUFRSUpDd1pLQWhzQkFRRUJBVGNPQVFVQkFnVUxBU1FKQVdZRUFRWUJBZ0lDR1FJRUF4QUVEUUVDQWdZQkR3RUFBd0FESFFNZEFoNENRQUlCQndnQkFnc0pBUzBEZHdJaUFYWURCQUlKQVFZRDJ3SUNBVG9CQVFjQkFRRUJBZ2dHQ2dJQk1CRS9CREFIQVFFRkFTZ0pEQUlnQkFJQ0FRTTRBUUVDQXdFQkF6b0lBZ0tZQXdFTkFRY0VBUVlCQXdMR09nRUZBQUhESVFBRGpRRmdJQUFHYVFJQUJBRUtJQUpRQWdBQkF3RUVBUmtDQlFHWEFob1NEUUVtQ0JrTExnTXdBUUlFQWdJbkFVTUdBZ0lDQWd3QkNBRXZBVE1CQVFNQ0FnVUNBUUVxQWdnQjdnRUNBUVFCQUFFQUVCQVFBQUlBQWVJQmxRVUFBd0VDQlFRb0F3UUJwUUlBQkFBQ21RdXdBVFlQT0FNeEJBSUNSUU1rQlFFSVBnRU1BalFKQ2dRQ0FWOERBZ0VCQWdZQm9BRURDQlVDT1FJQkFRRUJGZ0VPQndNRnd3Z0NBd0VCRndGUkFRSUdBUUVDQVFFQ0FRTHJBUUlFQmdJQkFoc0NWUWdDQVFFQ2FnRUJBUUlHQVFGbEF3SUVBUVVBQ1FFQzlRRUtBZ0VCQkFHUUJBSUNCQUVnQ2lnR0FnUUlBUWtHQWdNdURRRUNBQWNCQmdFQlVoWUNCd0VDQVFKNkJnTUJBUUlCQndFQlNBSURBUUVCQUFJQUJUc0hBQUUvQkZFQkFBSUFBUUVEQkFVSUNBSUhIZ1NVQXdBM0JESUlBUTRCRmdVQkR3QUhBUkVDQndFQ0FRVUFCd0FFQUFkdEJ3QmdnUEFBVEdGNWIzVjBSWEp5Y0hKcGRtRjBaUUNDQVFsd2NtOWtkV05sY25NQ0NHeGhibWQxWVdkbEFRUlNkWE4wQUF4d2NtOWpaWE56WldRdFlua0RCWEoxYzNSakpERXVORGN1TUMxaVpYUmhMaklnS0RnMFlqQTBOMkptTmlBeU1ESXdMVEE0TFRJNEtRWjNZV3h5ZFhNR01DNHhPQzR3REhkaGMyMHRZbWx1WkdkbGJoSXdMakl1TmpjZ0tEZGlZV1JqWkROaFpDaz1cIik7bGV0IEc7YXN5bmMgZnVuY3Rpb24gRihBLEkpe0d8fChHPWF3YWl0KGFzeW5jKCk9Pihhd2FpdCBFKG8pLEQpKSgpKTtjb25zdCBnPUcuZGVjb21wcmVzcyhBLEkpO2lmKDA9PT1nLmxlbmd0aCl0aHJvdyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgd2l0aCBMWlcgZGVjb2Rlci5cIik7cmV0dXJuIGd9ZXhwb3J0e0YgYXMgZGVjb21wcmVzc307XG4iLCJpbXBvcnQgeyBkZWNvbXByZXNzIH0gZnJvbSAnbHp3LXRpZmYtZGVjb2Rlcic7XG5cbmltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTFpXRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgY29uc3RydWN0b3IoZmlsZURpcmVjdG9yeSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgd2lkdGggPSBmaWxlRGlyZWN0b3J5LlRpbGVXaWR0aCB8fCBmaWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoIHx8IGZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGg7XG4gICAgY29uc3QgbmJ5dGVzID0gZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlWzBdIC8gODtcbiAgICB0aGlzLm1heFVuY29tcHJlc3NlZFNpemUgPSB3aWR0aCAqIGhlaWdodCAqIG5ieXRlcztcbiAgfVxuXG4gIGFzeW5jIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb21wcmVzcyhieXRlcywgdGhpcy5tYXhVbmNvbXByZXNzZWRTaXplKTtcbiAgICByZXR1cm4gZGVjb2RlZC5idWZmZXI7XG4gIH1cbn1cbiIsImltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyJztcblxuLyogLSotIHRhYi13aWR0aDogMjsgaW5kZW50LXRhYnMtbW9kZTogbmlsOyBjLWJhc2ljLW9mZnNldDogMiAtKi0gL1xuLyogdmltOiBzZXQgc2hpZnR3aWR0aD0yIHRhYnN0b3A9MiBhdXRvaW5kZW50IGNpbmRlbnQgZXhwYW5kdGFiOiAqL1xuLypcbiAgIENvcHlyaWdodCAyMDExIG5vdG1hc3RlcnlldFxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbi8vIC0gVGhlIEpQRUcgc3BlY2lmaWNhdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhlIElUVSBDQ0lUVCBSZWNvbW1lbmRhdGlvbiBULjgxXG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvaXR1LXQ4MS5wZGYpXG4vLyAtIFRoZSBKRklGIHNwZWNpZmljYXRpb24gY2FuIGJlIGZvdW5kIGluIHRoZSBKUEVHIEZpbGUgSW50ZXJjaGFuZ2UgRm9ybWF0XG4vLyAgICh3d3cudzMub3JnL0dyYXBoaWNzL0pQRUcvamZpZjMucGRmKVxuLy8gLSBUaGUgQWRvYmUgQXBwbGljYXRpb24tU3BlY2lmaWMgSlBFRyBtYXJrZXJzIGluIHRoZSBTdXBwb3J0aW5nIHRoZSBEQ1QgRmlsdGVyc1xuLy8gICBpbiBQb3N0U2NyaXB0IExldmVsIDIsIFRlY2huaWNhbCBOb3RlICM1MTE2XG4vLyAgIChwYXJ0bmVycy5hZG9iZS5jb20vcHVibGljL2RldmVsb3Blci9lbi9wcy9zZGsvNTExNi5EQ1RfRmlsdGVyLnBkZilcblxuXG5jb25zdCBkY3RaaWdaYWcgPSBuZXcgSW50MzJBcnJheShbXG4gIDAsXG4gIDEsIDgsXG4gIDE2LCA5LCAyLFxuICAzLCAxMCwgMTcsIDI0LFxuICAzMiwgMjUsIDE4LCAxMSwgNCxcbiAgNSwgMTIsIDE5LCAyNiwgMzMsIDQwLFxuICA0OCwgNDEsIDM0LCAyNywgMjAsIDEzLCA2LFxuICA3LCAxNCwgMjEsIDI4LCAzNSwgNDIsIDQ5LCA1NixcbiAgNTcsIDUwLCA0MywgMzYsIDI5LCAyMiwgMTUsXG4gIDIzLCAzMCwgMzcsIDQ0LCA1MSwgNTgsXG4gIDU5LCA1MiwgNDUsIDM4LCAzMSxcbiAgMzksIDQ2LCA1MywgNjAsXG4gIDYxLCA1NCwgNDcsXG4gIDU1LCA2MixcbiAgNjMsXG5dKTtcblxuY29uc3QgZGN0Q29zMSA9IDQwMTc7IC8vIGNvcyhwaS8xNilcbmNvbnN0IGRjdFNpbjEgPSA3OTk7IC8vIHNpbihwaS8xNilcbmNvbnN0IGRjdENvczMgPSAzNDA2OyAvLyBjb3MoMypwaS8xNilcbmNvbnN0IGRjdFNpbjMgPSAyMjc2OyAvLyBzaW4oMypwaS8xNilcbmNvbnN0IGRjdENvczYgPSAxNTY3OyAvLyBjb3MoNipwaS8xNilcbmNvbnN0IGRjdFNpbjYgPSAzNzg0OyAvLyBzaW4oNipwaS8xNilcbmNvbnN0IGRjdFNxcnQyID0gNTc5MzsgLy8gc3FydCgyKVxuY29uc3QgZGN0U3FydDFkMiA9IDI4OTY7Ly8gc3FydCgyKSAvIDJcblxuZnVuY3Rpb24gYnVpbGRIdWZmbWFuVGFibGUoY29kZUxlbmd0aHMsIHZhbHVlcykge1xuICBsZXQgayA9IDA7XG4gIGNvbnN0IGNvZGUgPSBbXTtcbiAgbGV0IGxlbmd0aCA9IDE2O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiAhY29kZUxlbmd0aHNbbGVuZ3RoIC0gMV0pIHtcbiAgICAtLWxlbmd0aDtcbiAgfVxuICBjb2RlLnB1c2goeyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuXG4gIGxldCBwID0gY29kZVswXTtcbiAgbGV0IHE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhzW2ldOyBqKyspIHtcbiAgICAgIHAgPSBjb2RlLnBvcCgpO1xuICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHZhbHVlc1trXTtcbiAgICAgIHdoaWxlIChwLmluZGV4ID4gMCkge1xuICAgICAgICBwID0gY29kZS5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHAuaW5kZXgrKztcbiAgICAgIGNvZGUucHVzaChwKTtcbiAgICAgIHdoaWxlIChjb2RlLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuICAgICAgICBwLmNoaWxkcmVuW3AuaW5kZXhdID0gcS5jaGlsZHJlbjtcbiAgICAgICAgcCA9IHE7XG4gICAgICB9XG4gICAgICBrKys7XG4gICAgfVxuICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xuICAgICAgLy8gcCBoZXJlIHBvaW50cyB0byBsYXN0IGNvZGVcbiAgICAgIGNvZGUucHVzaChxID0geyBjaGlsZHJlbjogW10sIGluZGV4OiAwIH0pO1xuICAgICAgcC5jaGlsZHJlbltwLmluZGV4XSA9IHEuY2hpbGRyZW47XG4gICAgICBwID0gcTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVbMF0uY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGRlY29kZVNjYW4oZGF0YSwgaW5pdGlhbE9mZnNldCxcbiAgZnJhbWUsIGNvbXBvbmVudHMsIHJlc2V0SW50ZXJ2YWwsXG4gIHNwZWN0cmFsU3RhcnQsIHNwZWN0cmFsRW5kLFxuICBzdWNjZXNzaXZlUHJldiwgc3VjY2Vzc2l2ZSkge1xuICBjb25zdCB7IG1jdXNQZXJMaW5lLCBwcm9ncmVzc2l2ZSB9ID0gZnJhbWU7XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpbml0aWFsT2Zmc2V0O1xuICBsZXQgb2Zmc2V0ID0gaW5pdGlhbE9mZnNldDtcbiAgbGV0IGJpdHNEYXRhID0gMDtcbiAgbGV0IGJpdHNDb3VudCA9IDA7XG4gIGZ1bmN0aW9uIHJlYWRCaXQoKSB7XG4gICAgaWYgKGJpdHNDb3VudCA+IDApIHtcbiAgICAgIGJpdHNDb3VudC0tO1xuICAgICAgcmV0dXJuIChiaXRzRGF0YSA+PiBiaXRzQ291bnQpICYgMTtcbiAgICB9XG4gICAgYml0c0RhdGEgPSBkYXRhW29mZnNldCsrXTtcbiAgICBpZiAoYml0c0RhdGEgPT09IDB4RkYpIHtcbiAgICAgIGNvbnN0IG5leHRCeXRlID0gZGF0YVtvZmZzZXQrK107XG4gICAgICBpZiAobmV4dEJ5dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcmtlcjogJHsoKGJpdHNEYXRhIDw8IDgpIHwgbmV4dEJ5dGUpLnRvU3RyaW5nKDE2KX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIHVuc3R1ZmYgMFxuICAgIH1cbiAgICBiaXRzQ291bnQgPSA3O1xuICAgIHJldHVybiBiaXRzRGF0YSA+Pj4gNztcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVIdWZmbWFuKHRyZWUpIHtcbiAgICBsZXQgbm9kZSA9IHRyZWU7XG4gICAgbGV0IGJpdDtcbiAgICB3aGlsZSAoKGJpdCA9IHJlYWRCaXQoKSkgIT09IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgbm9kZSA9IG5vZGVbYml0XTtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlY2VpdmUoaW5pdGlhbExlbmd0aCkge1xuICAgIGxldCBsZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgIGxldCBuID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYml0ID0gcmVhZEJpdCgpO1xuICAgICAgaWYgKGJpdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbiA9IChuIDw8IDEpIHwgYml0O1xuICAgICAgLS1sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQobGVuZ3RoKSB7XG4gICAgY29uc3QgbiA9IHJlY2VpdmUobGVuZ3RoKTtcbiAgICBpZiAobiA+PSAxIDw8IChsZW5ndGggLSAxKSkge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIHJldHVybiBuICsgKC0xIDw8IGxlbmd0aCkgKyAxO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUJhc2VsaW5lKGNvbXBvbmVudCwgenopIHtcbiAgICBjb25zdCB0ID0gZGVjb2RlSHVmZm1hbihjb21wb25lbnQuaHVmZm1hblRhYmxlREMpO1xuICAgIGNvbnN0IGRpZmYgPSB0ID09PSAwID8gMCA6IHJlY2VpdmVBbmRFeHRlbmQodCk7XG4gICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkO1xuICAgIGxldCBrID0gMTtcbiAgICB3aGlsZSAoayA8IDY0KSB7XG4gICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgY29uc3QgciA9IHJzID4+IDQ7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgayArPSAxNjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgKz0gcjtcbiAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1trXTtcbiAgICAgICAgenpbel0gPSByZWNlaXZlQW5kRXh0ZW5kKHMpO1xuICAgICAgICBrKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZURDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgIGNvbnN0IHQgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVEQyk7XG4gICAgY29uc3QgZGlmZiA9IHQgPT09IDAgPyAwIDogKHJlY2VpdmVBbmRFeHRlbmQodCkgPDwgc3VjY2Vzc2l2ZSk7XG4gICAgY29tcG9uZW50LnByZWQgKz0gZGlmZjtcbiAgICB6elswXSA9IGNvbXBvbmVudC5wcmVkO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZURDU3VjY2Vzc2l2ZShjb21wb25lbnQsIHp6KSB7XG4gICAgenpbMF0gfD0gcmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmU7XG4gIH1cbiAgbGV0IGVvYnJ1biA9IDA7XG4gIGZ1bmN0aW9uIGRlY29kZUFDRmlyc3QoY29tcG9uZW50LCB6eikge1xuICAgIGlmIChlb2JydW4gPiAwKSB7XG4gICAgICBlb2JydW4tLTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGsgPSBzcGVjdHJhbFN0YXJ0O1xuICAgIGNvbnN0IGUgPSBzcGVjdHJhbEVuZDtcbiAgICB3aGlsZSAoayA8PSBlKSB7XG4gICAgICBjb25zdCBycyA9IGRlY29kZUh1ZmZtYW4oY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDKTtcbiAgICAgIGNvbnN0IHMgPSBycyAmIDE1O1xuICAgICAgY29uc3QgciA9IHJzID4+IDQ7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICBpZiAociA8IDE1KSB7XG4gICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpIC0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBrICs9IDE2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayArPSByO1xuICAgICAgICBjb25zdCB6ID0gZGN0WmlnWmFnW2tdO1xuICAgICAgICB6elt6XSA9IHJlY2VpdmVBbmRFeHRlbmQocykgKiAoMSA8PCBzdWNjZXNzaXZlKTtcbiAgICAgICAgaysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICBsZXQgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlO1xuICBmdW5jdGlvbiBkZWNvZGVBQ1N1Y2Nlc3NpdmUoY29tcG9uZW50LCB6eikge1xuICAgIGxldCBrID0gc3BlY3RyYWxTdGFydDtcbiAgICBjb25zdCBlID0gc3BlY3RyYWxFbmQ7XG4gICAgbGV0IHIgPSAwO1xuICAgIHdoaWxlIChrIDw9IGUpIHtcbiAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdba107XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB6elt6XSA8IDAgPyAtMSA6IDE7XG4gICAgICBzd2l0Y2ggKHN1Y2Nlc3NpdmVBQ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgMDogeyAvLyBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgY29uc3QgcnMgPSBkZWNvZGVIdWZmbWFuKGNvbXBvbmVudC5odWZmbWFuVGFibGVBQyk7XG4gICAgICAgICAgY29uc3QgcyA9IHJzICYgMTU7XG4gICAgICAgICAgciA9IHJzID4+IDQ7XG4gICAgICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgMTUpIHtcbiAgICAgICAgICAgICAgZW9icnVuID0gcmVjZWl2ZShyKSArICgxIDw8IHIpO1xuICAgICAgICAgICAgICBzdWNjZXNzaXZlQUNTdGF0ZSA9IDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByID0gMTY7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHMgIT09IDEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEFDbiBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VjY2Vzc2l2ZUFDTmV4dFZhbHVlID0gcmVjZWl2ZUFuZEV4dGVuZChzKTtcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gciA/IDIgOiAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTogLy8gc2tpcHBpbmcgciB6ZXJvIGl0ZW1zXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoenpbel0pIHtcbiAgICAgICAgICAgIHp6W3pdICs9IChyZWFkQml0KCkgPDwgc3VjY2Vzc2l2ZSkgKiBkaXJlY3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHItLTtcbiAgICAgICAgICAgIGlmIChyID09PSAwKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gc3VjY2Vzc2l2ZUFDU3RhdGUgPT09IDIgPyAzIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogLy8gc2V0IHZhbHVlIGZvciBhIHplcm8gaXRlbVxuICAgICAgICAgIGlmICh6elt6XSkge1xuICAgICAgICAgICAgenpbel0gKz0gKHJlYWRCaXQoKSA8PCBzdWNjZXNzaXZlKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgenpbel0gPSBzdWNjZXNzaXZlQUNOZXh0VmFsdWUgPDwgc3VjY2Vzc2l2ZTtcbiAgICAgICAgICAgIHN1Y2Nlc3NpdmVBQ1N0YXRlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogLy8gZW9iXG4gICAgICAgICAgaWYgKHp6W3pdKSB7XG4gICAgICAgICAgICB6elt6XSArPSAocmVhZEJpdCgpIDw8IHN1Y2Nlc3NpdmUpICogZGlyZWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGsrKztcbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3NpdmVBQ1N0YXRlID09PSA0KSB7XG4gICAgICBlb2JydW4tLTtcbiAgICAgIGlmIChlb2JydW4gPT09IDApIHtcbiAgICAgICAgc3VjY2Vzc2l2ZUFDU3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGdW5jdGlvbiwgbWN1LCByb3csIGNvbCkge1xuICAgIGNvbnN0IG1jdVJvdyA9IChtY3UgLyBtY3VzUGVyTGluZSkgfCAwO1xuICAgIGNvbnN0IG1jdUNvbCA9IG1jdSAlIG1jdXNQZXJMaW5lO1xuICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdVJvdyAqIGNvbXBvbmVudC52KSArIHJvdztcbiAgICBjb25zdCBibG9ja0NvbCA9IChtY3VDb2wgKiBjb21wb25lbnQuaCkgKyBjb2w7XG4gICAgZGVjb2RlRnVuY3Rpb24oY29tcG9uZW50LCBjb21wb25lbnQuYmxvY2tzW2Jsb2NrUm93XVtibG9ja0NvbF0pO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUJsb2NrKGNvbXBvbmVudCwgZGVjb2RlRnVuY3Rpb24sIG1jdSkge1xuICAgIGNvbnN0IGJsb2NrUm93ID0gKG1jdSAvIGNvbXBvbmVudC5ibG9ja3NQZXJMaW5lKSB8IDA7XG4gICAgY29uc3QgYmxvY2tDb2wgPSBtY3UgJSBjb21wb25lbnQuYmxvY2tzUGVyTGluZTtcbiAgICBkZWNvZGVGdW5jdGlvbihjb21wb25lbnQsIGNvbXBvbmVudC5ibG9ja3NbYmxvY2tSb3ddW2Jsb2NrQ29sXSk7XG4gIH1cblxuICBjb25zdCBjb21wb25lbnRzTGVuZ3RoID0gY29tcG9uZW50cy5sZW5ndGg7XG4gIGxldCBjb21wb25lbnQ7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGs7XG4gIGxldCBuO1xuICBsZXQgZGVjb2RlRm47XG4gIGlmIChwcm9ncmVzc2l2ZSkge1xuICAgIGlmIChzcGVjdHJhbFN0YXJ0ID09PSAwKSB7XG4gICAgICBkZWNvZGVGbiA9IHN1Y2Nlc3NpdmVQcmV2ID09PSAwID8gZGVjb2RlRENGaXJzdCA6IGRlY29kZURDU3VjY2Vzc2l2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb2RlRm4gPSBzdWNjZXNzaXZlUHJldiA9PT0gMCA/IGRlY29kZUFDRmlyc3QgOiBkZWNvZGVBQ1N1Y2Nlc3NpdmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlY29kZUZuID0gZGVjb2RlQmFzZWxpbmU7XG4gIH1cblxuICBsZXQgbWN1ID0gMDtcbiAgbGV0IG1hcmtlcjtcbiAgbGV0IG1jdUV4cGVjdGVkO1xuICBpZiAoY29tcG9uZW50c0xlbmd0aCA9PT0gMSkge1xuICAgIG1jdUV4cGVjdGVkID0gY29tcG9uZW50c1swXS5ibG9ja3NQZXJMaW5lICogY29tcG9uZW50c1swXS5ibG9ja3NQZXJDb2x1bW47XG4gIH0gZWxzZSB7XG4gICAgbWN1RXhwZWN0ZWQgPSBtY3VzUGVyTGluZSAqIGZyYW1lLm1jdXNQZXJDb2x1bW47XG4gIH1cblxuICBjb25zdCB1c2VkUmVzZXRJbnRlcnZhbCA9IHJlc2V0SW50ZXJ2YWwgfHwgbWN1RXhwZWN0ZWQ7XG5cbiAgd2hpbGUgKG1jdSA8IG1jdUV4cGVjdGVkKSB7XG4gICAgLy8gcmVzZXQgaW50ZXJ2YWwgc3R1ZmZcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcG9uZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb21wb25lbnRzW2ldLnByZWQgPSAwO1xuICAgIH1cbiAgICBlb2JydW4gPSAwO1xuXG4gICAgaWYgKGNvbXBvbmVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbMF07XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgdXNlZFJlc2V0SW50ZXJ2YWw7IG4rKykge1xuICAgICAgICBkZWNvZGVCbG9jayhjb21wb25lbnQsIGRlY29kZUZuLCBtY3UpO1xuICAgICAgICBtY3UrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChuID0gMDsgbiA8IHVzZWRSZXNldEludGVydmFsOyBuKyspIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBvbmVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgY29uc3QgeyBoLCB2IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHY7IGorKykge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGg7IGsrKykge1xuICAgICAgICAgICAgICBkZWNvZGVNY3UoY29tcG9uZW50LCBkZWNvZGVGbiwgbWN1LCBqLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWN1Kys7XG5cbiAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBvdXIgZXhwZWN0ZWQgTUNVJ3MsIHN0b3AgZGVjb2RpbmdcbiAgICAgICAgaWYgKG1jdSA9PT0gbWN1RXhwZWN0ZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgbWFya2VyXG4gICAgYml0c0NvdW50ID0gMDtcbiAgICBtYXJrZXIgPSAoZGF0YVtvZmZzZXRdIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxXTtcbiAgICBpZiAobWFya2VyIDwgMHhGRjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlciB3YXMgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlciA+PSAweEZGRDAgJiYgbWFya2VyIDw9IDB4RkZENykgeyAvLyBSU1R4XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBidWlsZENvbXBvbmVudERhdGEoZnJhbWUsIGNvbXBvbmVudCkge1xuICBjb25zdCBsaW5lcyA9IFtdO1xuICBjb25zdCB7IGJsb2Nrc1BlckxpbmUsIGJsb2Nrc1BlckNvbHVtbiB9ID0gY29tcG9uZW50O1xuICBjb25zdCBzYW1wbGVzUGVyTGluZSA9IGJsb2Nrc1BlckxpbmUgPDwgMztcbiAgY29uc3QgUiA9IG5ldyBJbnQzMkFycmF5KDY0KTtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KDY0KTtcblxuICAvLyBBIHBvcnQgb2YgcG9wcGxlcidzIElEQ1QgbWV0aG9kIHdoaWNoIGluIHR1cm4gaXMgdGFrZW4gZnJvbTpcbiAgLy8gICBDaHJpc3RvcGggTG9lZmZsZXIsIEFkcmlhYW4gTGlndGVuYmVyZywgR2VvcmdlIFMuIE1vc2NoeXR6LFxuICAvLyAgIFwiUHJhY3RpY2FsIEZhc3QgMS1EIERDVCBBbGdvcml0aG1zIHdpdGggMTEgTXVsdGlwbGljYXRpb25zXCIsXG4gIC8vICAgSUVFRSBJbnRsLiBDb25mLiBvbiBBY291c3RpY3MsIFNwZWVjaCAmIFNpZ25hbCBQcm9jZXNzaW5nLCAxOTg5LFxuICAvLyAgIDk4OC05OTEuXG4gIGZ1bmN0aW9uIHF1YW50aXplQW5kSW52ZXJzZSh6eiwgZGF0YU91dCwgZGF0YUluKSB7XG4gICAgY29uc3QgcXQgPSBjb21wb25lbnQucXVhbnRpemF0aW9uVGFibGU7XG4gICAgbGV0IHYwO1xuICAgIGxldCB2MTtcbiAgICBsZXQgdjI7XG4gICAgbGV0IHYzO1xuICAgIGxldCB2NDtcbiAgICBsZXQgdjU7XG4gICAgbGV0IHY2O1xuICAgIGxldCB2NztcbiAgICBsZXQgdDtcbiAgICBjb25zdCBwID0gZGF0YUluO1xuICAgIGxldCBpO1xuXG4gICAgLy8gZGVxdWFudFxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBwW2ldID0genpbaV0gKiBxdFtpXTtcbiAgICB9XG5cbiAgICAvLyBpbnZlcnNlIERDVCBvbiByb3dzXG4gICAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgY29uc3Qgcm93ID0gOCAqIGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWzEgKyByb3ddID09PSAwICYmIHBbMiArIHJvd10gPT09IDAgJiYgcFszICsgcm93XSA9PT0gMFxuICAgICAgICAmJiBwWzQgKyByb3ddID09PSAwICYmIHBbNSArIHJvd10gPT09IDAgJiYgcFs2ICsgcm93XSA9PT0gMFxuICAgICAgICAmJiBwWzcgKyByb3ddID09PSAwKSB7XG4gICAgICAgIHQgPSAoKGRjdFNxcnQyICogcFswICsgcm93XSkgKyA1MTIpID4+IDEwO1xuICAgICAgICBwWzAgKyByb3ddID0gdDtcbiAgICAgICAgcFsxICsgcm93XSA9IHQ7XG4gICAgICAgIHBbMiArIHJvd10gPSB0O1xuICAgICAgICBwWzMgKyByb3ddID0gdDtcbiAgICAgICAgcFs0ICsgcm93XSA9IHQ7XG4gICAgICAgIHBbNSArIHJvd10gPSB0O1xuICAgICAgICBwWzYgKyByb3ddID0gdDtcbiAgICAgICAgcFs3ICsgcm93XSA9IHQ7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHN0YWdlIDRcbiAgICAgIHYwID0gKChkY3RTcXJ0MiAqIHBbMCArIHJvd10pICsgMTI4KSA+PiA4O1xuICAgICAgdjEgPSAoKGRjdFNxcnQyICogcFs0ICsgcm93XSkgKyAxMjgpID4+IDg7XG4gICAgICB2MiA9IHBbMiArIHJvd107XG4gICAgICB2MyA9IHBbNiArIHJvd107XG4gICAgICB2NCA9ICgoZGN0U3FydDFkMiAqIChwWzEgKyByb3ddIC0gcFs3ICsgcm93XSkpICsgMTI4KSA+PiA4O1xuICAgICAgdjcgPSAoKGRjdFNxcnQxZDIgKiAocFsxICsgcm93XSArIHBbNyArIHJvd10pKSArIDEyOCkgPj4gODtcbiAgICAgIHY1ID0gcFszICsgcm93XSA8PCA0O1xuICAgICAgdjYgPSBwWzUgKyByb3ddIDw8IDQ7XG5cbiAgICAgIC8vIHN0YWdlIDNcbiAgICAgIHQgPSAodjAgLSB2MSArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYxICsgMSkgPj4gMTtcbiAgICAgIHYxID0gdDtcbiAgICAgIHQgPSAoKHYyICogZGN0U2luNikgKyAodjMgKiBkY3RDb3M2KSArIDEyOCkgPj4gODtcbiAgICAgIHYyID0gKCh2MiAqIGRjdENvczYpIC0gKHYzICogZGN0U2luNikgKyAxMjgpID4+IDg7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHQ7XG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICB2NyA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdDtcbiAgICAgIHQgPSAoKHY0ICogZGN0U2luMykgKyAodjcgKiBkY3RDb3MzKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICgodjUgKiBkY3RTaW4xKSArICh2NiAqIGRjdENvczEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbMCArIHJvd10gPSB2MCArIHY3O1xuICAgICAgcFs3ICsgcm93XSA9IHYwIC0gdjc7XG4gICAgICBwWzEgKyByb3ddID0gdjEgKyB2NjtcbiAgICAgIHBbNiArIHJvd10gPSB2MSAtIHY2O1xuICAgICAgcFsyICsgcm93XSA9IHYyICsgdjU7XG4gICAgICBwWzUgKyByb3ddID0gdjIgLSB2NTtcbiAgICAgIHBbMyArIHJvd10gPSB2MyArIHY0O1xuICAgICAgcFs0ICsgcm93XSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gaW52ZXJzZSBEQ1Qgb24gY29sdW1uc1xuICAgIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIGNvbnN0IGNvbCA9IGk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBhbGwtemVybyBBQyBjb2VmZmljaWVudHNcbiAgICAgIGlmIChwWygxICogOCkgKyBjb2xdID09PSAwICYmIHBbKDIgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoMyAqIDgpICsgY29sXSA9PT0gMFxuICAgICAgICAmJiBwWyg0ICogOCkgKyBjb2xdID09PSAwICYmIHBbKDUgKiA4KSArIGNvbF0gPT09IDAgJiYgcFsoNiAqIDgpICsgY29sXSA9PT0gMFxuICAgICAgICAmJiBwWyg3ICogOCkgKyBjb2xdID09PSAwKSB7XG4gICAgICAgIHQgPSAoKGRjdFNxcnQyICogZGF0YUluW2kgKyAwXSkgKyA4MTkyKSA+PiAxNDtcbiAgICAgICAgcFsoMCAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDEgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWygyICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoMyAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDQgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBwWyg1ICogOCkgKyBjb2xdID0gdDtcbiAgICAgICAgcFsoNiAqIDgpICsgY29sXSA9IHQ7XG4gICAgICAgIHBbKDcgKiA4KSArIGNvbF0gPSB0O1xuICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBzdGFnZSA0XG4gICAgICB2MCA9ICgoZGN0U3FydDIgKiBwWygwICogOCkgKyBjb2xdKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjEgPSAoKGRjdFNxcnQyICogcFsoNCAqIDgpICsgY29sXSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHYyID0gcFsoMiAqIDgpICsgY29sXTtcbiAgICAgIHYzID0gcFsoNiAqIDgpICsgY29sXTtcbiAgICAgIHY0ID0gKChkY3RTcXJ0MWQyICogKHBbKDEgKiA4KSArIGNvbF0gLSBwWyg3ICogOCkgKyBjb2xdKSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY3ID0gKChkY3RTcXJ0MWQyICogKHBbKDEgKiA4KSArIGNvbF0gKyBwWyg3ICogOCkgKyBjb2xdKSkgKyAyMDQ4KSA+PiAxMjtcbiAgICAgIHY1ID0gcFsoMyAqIDgpICsgY29sXTtcbiAgICAgIHY2ID0gcFsoNSAqIDgpICsgY29sXTtcblxuICAgICAgLy8gc3RhZ2UgM1xuICAgICAgdCA9ICh2MCAtIHYxICsgMSkgPj4gMTtcbiAgICAgIHYwID0gKHYwICsgdjEgKyAxKSA+PiAxO1xuICAgICAgdjEgPSB0O1xuICAgICAgdCA9ICgodjIgKiBkY3RTaW42KSArICh2MyAqIGRjdENvczYpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MiA9ICgodjIgKiBkY3RDb3M2KSAtICh2MyAqIGRjdFNpbjYpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2MyA9IHQ7XG4gICAgICB0ID0gKHY0IC0gdjYgKyAxKSA+PiAxO1xuICAgICAgdjQgPSAodjQgKyB2NiArIDEpID4+IDE7XG4gICAgICB2NiA9IHQ7XG4gICAgICB0ID0gKHY3ICsgdjUgKyAxKSA+PiAxO1xuICAgICAgdjUgPSAodjcgLSB2NSArIDEpID4+IDE7XG4gICAgICB2NyA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDJcbiAgICAgIHQgPSAodjAgLSB2MyArIDEpID4+IDE7XG4gICAgICB2MCA9ICh2MCArIHYzICsgMSkgPj4gMTtcbiAgICAgIHYzID0gdDtcbiAgICAgIHQgPSAodjEgLSB2MiArIDEpID4+IDE7XG4gICAgICB2MSA9ICh2MSArIHYyICsgMSkgPj4gMTtcbiAgICAgIHYyID0gdDtcbiAgICAgIHQgPSAoKHY0ICogZGN0U2luMykgKyAodjcgKiBkY3RDb3MzKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjQgPSAoKHY0ICogZGN0Q29zMykgLSAodjcgKiBkY3RTaW4zKSArIDIwNDgpID4+IDEyO1xuICAgICAgdjcgPSB0O1xuICAgICAgdCA9ICgodjUgKiBkY3RTaW4xKSArICh2NiAqIGRjdENvczEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NSA9ICgodjUgKiBkY3RDb3MxKSAtICh2NiAqIGRjdFNpbjEpICsgMjA0OCkgPj4gMTI7XG4gICAgICB2NiA9IHQ7XG5cbiAgICAgIC8vIHN0YWdlIDFcbiAgICAgIHBbKDAgKiA4KSArIGNvbF0gPSB2MCArIHY3O1xuICAgICAgcFsoNyAqIDgpICsgY29sXSA9IHYwIC0gdjc7XG4gICAgICBwWygxICogOCkgKyBjb2xdID0gdjEgKyB2NjtcbiAgICAgIHBbKDYgKiA4KSArIGNvbF0gPSB2MSAtIHY2O1xuICAgICAgcFsoMiAqIDgpICsgY29sXSA9IHYyICsgdjU7XG4gICAgICBwWyg1ICogOCkgKyBjb2xdID0gdjIgLSB2NTtcbiAgICAgIHBbKDMgKiA4KSArIGNvbF0gPSB2MyArIHY0O1xuICAgICAgcFsoNCAqIDgpICsgY29sXSA9IHYzIC0gdjQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byA4LWJpdCBpbnRlZ2Vyc1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSAxMjggKyAoKHBbaV0gKyA4KSA+PiA0KTtcbiAgICAgIGlmIChzYW1wbGUgPCAwKSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzYW1wbGUgPiAwWEZGKSB7XG4gICAgICAgIGRhdGFPdXRbaV0gPSAweEZGO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YU91dFtpXSA9IHNhbXBsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBibG9ja1JvdyA9IDA7IGJsb2NrUm93IDwgYmxvY2tzUGVyQ29sdW1uOyBibG9ja1JvdysrKSB7XG4gICAgY29uc3Qgc2NhbkxpbmUgPSBibG9ja1JvdyA8PCAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBVaW50OEFycmF5KHNhbXBsZXNQZXJMaW5lKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGJsb2NrQ29sID0gMDsgYmxvY2tDb2wgPCBibG9ja3NQZXJMaW5lOyBibG9ja0NvbCsrKSB7XG4gICAgICBxdWFudGl6ZUFuZEludmVyc2UoY29tcG9uZW50LmJsb2Nrc1tibG9ja1Jvd11bYmxvY2tDb2xdLCByLCBSKTtcblxuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBjb25zdCBzYW1wbGUgPSBibG9ja0NvbCA8PCAzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3NjYW5MaW5lICsgal07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgbGluZVtzYW1wbGUgKyBpXSA9IHJbb2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lcztcbn1cblxuY2xhc3MgSnBlZ1N0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuamZpZiA9IG51bGw7XG4gICAgdGhpcy5hZG9iZSA9IG51bGw7XG5cbiAgICB0aGlzLnF1YW50aXphdGlvblRhYmxlcyA9IFtdO1xuICAgIHRoaXMuaHVmZm1hblRhYmxlc0FDID0gW107XG4gICAgdGhpcy5odWZmbWFuVGFibGVzREMgPSBbXTtcbiAgICB0aGlzLnJlc2V0RnJhbWVzKCk7XG4gIH1cblxuICByZXNldEZyYW1lcygpIHtcbiAgICB0aGlzLmZyYW1lcyA9IFtdO1xuICB9XG5cbiAgcGFyc2UoZGF0YSkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIGNvbnN0IHsgbGVuZ3RoIH0gPSBkYXRhO1xuICAgIGZ1bmN0aW9uIHJlYWRVaW50MTYoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IChkYXRhW29mZnNldF0gPDwgOCkgfCBkYXRhW29mZnNldCArIDFdO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWREYXRhQmxvY2soKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSByZWFkVWludDE2KCk7XG4gICAgICBjb25zdCBhcnJheSA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGggLSAyKTtcbiAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb21wb25lbnRzKGZyYW1lKSB7XG4gICAgICBsZXQgbWF4SCA9IDA7XG4gICAgICBsZXQgbWF4ViA9IDA7XG4gICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgbGV0IGNvbXBvbmVudElkO1xuICAgICAgZm9yIChjb21wb25lbnRJZCBpbiBmcmFtZS5jb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KGNvbXBvbmVudElkKSkge1xuICAgICAgICAgIGNvbXBvbmVudCA9IGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdO1xuICAgICAgICAgIGlmIChtYXhIIDwgY29tcG9uZW50LmgpIHtcbiAgICAgICAgICAgIG1heEggPSBjb21wb25lbnQuaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heFYgPCBjb21wb25lbnQudikge1xuICAgICAgICAgICAgbWF4ViA9IGNvbXBvbmVudC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbWN1c1BlckxpbmUgPSBNYXRoLmNlaWwoZnJhbWUuc2FtcGxlc1BlckxpbmUgLyA4IC8gbWF4SCk7XG4gICAgICBjb25zdCBtY3VzUGVyQ29sdW1uID0gTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDggLyBtYXhWKTtcbiAgICAgIGZvciAoY29tcG9uZW50SWQgaW4gZnJhbWUuY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZnJhbWUuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eShjb21wb25lbnRJZCkpIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2NvbXBvbmVudElkXTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lID0gTWF0aC5jZWlsKE1hdGguY2VpbChmcmFtZS5zYW1wbGVzUGVyTGluZSAvIDgpICogY29tcG9uZW50LmggLyBtYXhIKTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJDb2x1bW4gPSBNYXRoLmNlaWwoTWF0aC5jZWlsKGZyYW1lLnNjYW5MaW5lcyAvIDgpICogY29tcG9uZW50LnYgLyBtYXhWKTtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJMaW5lRm9yTWN1ID0gbWN1c1BlckxpbmUgKiBjb21wb25lbnQuaDtcbiAgICAgICAgICBjb25zdCBibG9ja3NQZXJDb2x1bW5Gb3JNY3UgPSBtY3VzUGVyQ29sdW1uICogY29tcG9uZW50LnY7XG4gICAgICAgICAgY29uc3QgYmxvY2tzID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NQZXJDb2x1bW5Gb3JNY3U7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2Nrc1BlckxpbmVGb3JNY3U7IGorKykge1xuICAgICAgICAgICAgICByb3cucHVzaChuZXcgSW50MzJBcnJheSg2NCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2tzLnB1c2gocm93KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcG9uZW50LmJsb2Nrc1BlckxpbmUgPSBibG9ja3NQZXJMaW5lO1xuICAgICAgICAgIGNvbXBvbmVudC5ibG9ja3NQZXJDb2x1bW4gPSBibG9ja3NQZXJDb2x1bW47XG4gICAgICAgICAgY29tcG9uZW50LmJsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnJhbWUubWF4SCA9IG1heEg7XG4gICAgICBmcmFtZS5tYXhWID0gbWF4VjtcbiAgICAgIGZyYW1lLm1jdXNQZXJMaW5lID0gbWN1c1BlckxpbmU7XG4gICAgICBmcmFtZS5tY3VzUGVyQ29sdW1uID0gbWN1c1BlckNvbHVtbjtcbiAgICB9XG5cbiAgICBsZXQgZmlsZU1hcmtlciA9IHJlYWRVaW50MTYoKTtcbiAgICBpZiAoZmlsZU1hcmtlciAhPT0gMHhGRkQ4KSB7IC8vIFNPSSAoU3RhcnQgb2YgSW1hZ2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NPSSBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIHdoaWxlIChmaWxlTWFya2VyICE9PSAweEZGRDkpIHsgLy8gRU9JIChFbmQgb2YgaW1hZ2UpXG4gICAgICBzd2l0Y2ggKGZpbGVNYXJrZXIpIHtcbiAgICAgICAgY2FzZSAweEZGMDA6IGJyZWFrO1xuICAgICAgICBjYXNlIDB4RkZFMDogLy8gQVBQMCAoQXBwbGljYXRpb24gU3BlY2lmaWMpXG4gICAgICAgIGNhc2UgMHhGRkUxOiAvLyBBUFAxXG4gICAgICAgIGNhc2UgMHhGRkUyOiAvLyBBUFAyXG4gICAgICAgIGNhc2UgMHhGRkUzOiAvLyBBUFAzXG4gICAgICAgIGNhc2UgMHhGRkU0OiAvLyBBUFA0XG4gICAgICAgIGNhc2UgMHhGRkU1OiAvLyBBUFA1XG4gICAgICAgIGNhc2UgMHhGRkU2OiAvLyBBUFA2XG4gICAgICAgIGNhc2UgMHhGRkU3OiAvLyBBUFA3XG4gICAgICAgIGNhc2UgMHhGRkU4OiAvLyBBUFA4XG4gICAgICAgIGNhc2UgMHhGRkU5OiAvLyBBUFA5XG4gICAgICAgIGNhc2UgMHhGRkVBOiAvLyBBUFAxMFxuICAgICAgICBjYXNlIDB4RkZFQjogLy8gQVBQMTFcbiAgICAgICAgY2FzZSAweEZGRUM6IC8vIEFQUDEyXG4gICAgICAgIGNhc2UgMHhGRkVEOiAvLyBBUFAxM1xuICAgICAgICBjYXNlIDB4RkZFRTogLy8gQVBQMTRcbiAgICAgICAgY2FzZSAweEZGRUY6IC8vIEFQUDE1XG4gICAgICAgIGNhc2UgMHhGRkZFOiB7IC8vIENPTSAoQ29tbWVudClcbiAgICAgICAgICBjb25zdCBhcHBEYXRhID0gcmVhZERhdGFCbG9jaygpO1xuXG4gICAgICAgICAgaWYgKGZpbGVNYXJrZXIgPT09IDB4RkZFMCkge1xuICAgICAgICAgICAgaWYgKGFwcERhdGFbMF0gPT09IDB4NEEgJiYgYXBwRGF0YVsxXSA9PT0gMHg0NiAmJiBhcHBEYXRhWzJdID09PSAweDQ5XG4gICAgICAgICAgICAgICYmIGFwcERhdGFbM10gPT09IDB4NDYgJiYgYXBwRGF0YVs0XSA9PT0gMCkgeyAvLyAnSkZJRlxceDAwJ1xuICAgICAgICAgICAgICB0aGlzLmpmaWYgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogeyBtYWpvcjogYXBwRGF0YVs1XSwgbWlub3I6IGFwcERhdGFbNl0gfSxcbiAgICAgICAgICAgICAgICBkZW5zaXR5VW5pdHM6IGFwcERhdGFbN10sXG4gICAgICAgICAgICAgICAgeERlbnNpdHk6IChhcHBEYXRhWzhdIDw8IDgpIHwgYXBwRGF0YVs5XSxcbiAgICAgICAgICAgICAgICB5RGVuc2l0eTogKGFwcERhdGFbMTBdIDw8IDgpIHwgYXBwRGF0YVsxMV0sXG4gICAgICAgICAgICAgICAgdGh1bWJXaWR0aDogYXBwRGF0YVsxMl0sXG4gICAgICAgICAgICAgICAgdGh1bWJIZWlnaHQ6IGFwcERhdGFbMTNdLFxuICAgICAgICAgICAgICAgIHRodW1iRGF0YTogYXBwRGF0YS5zdWJhcnJheSgxNCwgMTQgKyAoMyAqIGFwcERhdGFbMTJdICogYXBwRGF0YVsxM10pKSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyBBUFAxIC0gRXhpZlxuICAgICAgICAgIGlmIChmaWxlTWFya2VyID09PSAweEZGRUUpIHtcbiAgICAgICAgICAgIGlmIChhcHBEYXRhWzBdID09PSAweDQxICYmIGFwcERhdGFbMV0gPT09IDB4NjQgJiYgYXBwRGF0YVsyXSA9PT0gMHg2RlxuICAgICAgICAgICAgICAmJiBhcHBEYXRhWzNdID09PSAweDYyICYmIGFwcERhdGFbNF0gPT09IDB4NjUgJiYgYXBwRGF0YVs1XSA9PT0gMCkgeyAvLyAnQWRvYmVcXHgwMCdcbiAgICAgICAgICAgICAgdGhpcy5hZG9iZSA9IHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBhcHBEYXRhWzZdLFxuICAgICAgICAgICAgICAgIGZsYWdzMDogKGFwcERhdGFbN10gPDwgOCkgfCBhcHBEYXRhWzhdLFxuICAgICAgICAgICAgICAgIGZsYWdzMTogKGFwcERhdGFbOV0gPDwgOCkgfCBhcHBEYXRhWzEwXSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Db2RlOiBhcHBEYXRhWzExXSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZEQjogeyAvLyBEUVQgKERlZmluZSBRdWFudGl6YXRpb24gVGFibGVzKVxuICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlc0xlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBjb25zdCBxdWFudGl6YXRpb25UYWJsZXNFbmQgPSBxdWFudGl6YXRpb25UYWJsZXNMZW5ndGggKyBvZmZzZXQgLSAyO1xuICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBxdWFudGl6YXRpb25UYWJsZXNFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXphdGlvblRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29uc3QgdGFibGVEYXRhID0gbmV3IEludDMyQXJyYXkoNjQpO1xuICAgICAgICAgICAgaWYgKChxdWFudGl6YXRpb25UYWJsZVNwZWMgPj4gNCkgPT09IDApIHsgLy8gOCBiaXQgdmFsdWVzXG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBkY3RaaWdaYWdbal07XG4gICAgICAgICAgICAgICAgdGFibGVEYXRhW3pdID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHF1YW50aXphdGlvblRhYmxlU3BlYyA+PiA0KSA9PT0gMSkgeyAvLyAxNiBiaXRcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGRjdFppZ1phZ1tqXTtcbiAgICAgICAgICAgICAgICB0YWJsZURhdGFbel0gPSByZWFkVWludDE2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRFFUOiBpbnZhbGlkIHRhYmxlIHNwZWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uVGFibGVzW3F1YW50aXphdGlvblRhYmxlU3BlYyAmIDE1XSA9IHRhYmxlRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIDB4RkZDMDogLy8gU09GMCAoU3RhcnQgb2YgRnJhbWUsIEJhc2VsaW5lIERDVClcbiAgICAgICAgY2FzZSAweEZGQzE6IC8vIFNPRjEgKFN0YXJ0IG9mIEZyYW1lLCBFeHRlbmRlZCBEQ1QpXG4gICAgICAgIGNhc2UgMHhGRkMyOiB7IC8vIFNPRjIgKFN0YXJ0IG9mIEZyYW1lLCBQcm9ncmVzc2l2ZSBEQ1QpXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGRhdGEgbGVuZ3RoXG4gICAgICAgICAgY29uc3QgZnJhbWUgPSB7XG4gICAgICAgICAgICBleHRlbmRlZDogKGZpbGVNYXJrZXIgPT09IDB4RkZDMSksXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZTogKGZpbGVNYXJrZXIgPT09IDB4RkZDMiksXG4gICAgICAgICAgICBwcmVjaXNpb246IGRhdGFbb2Zmc2V0KytdLFxuICAgICAgICAgICAgc2NhbkxpbmVzOiByZWFkVWludDE2KCksXG4gICAgICAgICAgICBzYW1wbGVzUGVyTGluZTogcmVhZFVpbnQxNigpLFxuICAgICAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgICAgICBjb21wb25lbnRzT3JkZXI6IFtdLFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBjb21wb25lbnRzQ291bnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50SWQ7XG4gICAgICAgICAgLy8gbGV0IG1heEggPSAwO1xuICAgICAgICAgIC8vIGxldCBtYXhWID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnRJZCA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgIGNvbnN0IGggPSBkYXRhW29mZnNldCArIDFdID4+IDQ7XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YVtvZmZzZXQgKyAxXSAmIDE1O1xuICAgICAgICAgICAgY29uc3QgcUlkID0gZGF0YVtvZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNPcmRlci5wdXNoKGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgIGZyYW1lLmNvbXBvbmVudHNbY29tcG9uZW50SWRdID0ge1xuICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICBxdWFudGl6YXRpb25JZHg6IHFJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvZmZzZXQgKz0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJlcGFyZUNvbXBvbmVudHMoZnJhbWUpO1xuICAgICAgICAgIHRoaXMuZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGQzQ6IHsgLy8gREhUIChEZWZpbmUgSHVmZm1hbiBUYWJsZXMpXG4gICAgICAgICAgY29uc3QgaHVmZm1hbkxlbmd0aCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGh1ZmZtYW5MZW5ndGg7KSB7XG4gICAgICAgICAgICBjb25zdCBodWZmbWFuVGFibGVTcGVjID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgICBjb25zdCBjb2RlTGVuZ3RocyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgICAgIGxldCBjb2RlTGVuZ3RoU3VtID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgY29kZUxlbmd0aHNbal0gPSBkYXRhW29mZnNldF07XG4gICAgICAgICAgICAgIGNvZGVMZW5ndGhTdW0gKz0gY29kZUxlbmd0aHNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBodWZmbWFuVmFsdWVzID0gbmV3IFVpbnQ4QXJyYXkoY29kZUxlbmd0aFN1bSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvZGVMZW5ndGhTdW07IGorKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgaHVmZm1hblZhbHVlc1tqXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gMTcgKyBjb2RlTGVuZ3RoU3VtO1xuXG4gICAgICAgICAgICBpZiAoKGh1ZmZtYW5UYWJsZVNwZWMgPj4gNCkgPT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzRENbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKFxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5odWZmbWFuVGFibGVzQUNbaHVmZm1hblRhYmxlU3BlYyAmIDE1XSA9IGJ1aWxkSHVmZm1hblRhYmxlKFxuICAgICAgICAgICAgICAgIGNvZGVMZW5ndGhzLCBodWZmbWFuVmFsdWVzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgMHhGRkREOiAvLyBEUkkgKERlZmluZSBSZXN0YXJ0IEludGVydmFsKVxuICAgICAgICAgIHJlYWRVaW50MTYoKTsgLy8gc2tpcCBkYXRhIGxlbmd0aFxuICAgICAgICAgIHRoaXMucmVzZXRJbnRlcnZhbCA9IHJlYWRVaW50MTYoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDB4RkZEQTogeyAvLyBTT1MgKFN0YXJ0IG9mIFNjYW4pXG4gICAgICAgICAgcmVhZFVpbnQxNigpOyAvLyBza2lwIGxlbmd0aFxuICAgICAgICAgIGNvbnN0IHNlbGVjdG9yc0NvdW50ID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5mcmFtZXNbMF07XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RvcnNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBmcmFtZS5jb21wb25lbnRzW2RhdGFbb2Zmc2V0KytdXTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlU3BlYyA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZURDID0gdGhpcy5odWZmbWFuVGFibGVzRENbdGFibGVTcGVjID4+IDRdO1xuICAgICAgICAgICAgY29tcG9uZW50Lmh1ZmZtYW5UYWJsZUFDID0gdGhpcy5odWZmbWFuVGFibGVzQUNbdGFibGVTcGVjICYgMTVdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNwZWN0cmFsU3RhcnQgPSBkYXRhW29mZnNldCsrXTtcbiAgICAgICAgICBjb25zdCBzcGVjdHJhbEVuZCA9IGRhdGFbb2Zmc2V0KytdO1xuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NpdmVBcHByb3hpbWF0aW9uID0gZGF0YVtvZmZzZXQrK107XG4gICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZGVjb2RlU2NhbihkYXRhLCBvZmZzZXQsXG4gICAgICAgICAgICBmcmFtZSwgY29tcG9uZW50cywgdGhpcy5yZXNldEludGVydmFsLFxuICAgICAgICAgICAgc3BlY3RyYWxTdGFydCwgc3BlY3RyYWxFbmQsXG4gICAgICAgICAgICBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiA+PiA0LCBzdWNjZXNzaXZlQXBwcm94aW1hdGlvbiAmIDE1KTtcbiAgICAgICAgICBvZmZzZXQgKz0gcHJvY2Vzc2VkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAweEZGRkY6IC8vIEZpbGwgYnl0ZXNcbiAgICAgICAgICBpZiAoZGF0YVtvZmZzZXRdICE9PSAweEZGKSB7IC8vIEF2b2lkIHNraXBwaW5nIGEgdmFsaWQgbWFya2VyLlxuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGRhdGFbb2Zmc2V0IC0gM10gPT09IDB4RkZcbiAgICAgICAgICAgICYmIGRhdGFbb2Zmc2V0IC0gMl0gPj0gMHhDMCAmJiBkYXRhW29mZnNldCAtIDJdIDw9IDB4RkUpIHtcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIGluY29ycmVjdCBlbmNvZGluZyAtLSBsYXN0IDB4RkYgYnl0ZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIGJsb2NrIHdhcyBlYXRlbiBieSB0aGUgZW5jb2RlclxuICAgICAgICAgICAgb2Zmc2V0IC09IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIEpQRUcgbWFya2VyICR7ZmlsZU1hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICB9XG4gICAgICBmaWxlTWFya2VyID0gcmVhZFVpbnQxNigpO1xuICAgIH1cbiAgfVxuXG4gIGdldFJlc3VsdCgpIHtcbiAgICBjb25zdCB7IGZyYW1lcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5mcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGZyYW1lcyB3ZXJlIGRlY29kZWQnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignbW9yZSB0aGFuIG9uZSBmcmFtZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGVhY2ggZnJhbWUncyBjb21wb25lbnRzIHF1YW50aXphdGlvbiB0YWJsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNwID0gdGhpcy5mcmFtZXNbaV0uY29tcG9uZW50cztcbiAgICAgIGZvciAoY29uc3QgaiBvZiBPYmplY3Qua2V5cyhjcCkpIHtcbiAgICAgICAgY3Bbal0ucXVhbnRpemF0aW9uVGFibGUgPSB0aGlzLnF1YW50aXphdGlvblRhYmxlc1tjcFtqXS5xdWFudGl6YXRpb25JZHhdO1xuICAgICAgICBkZWxldGUgY3Bbal0ucXVhbnRpemF0aW9uSWR4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzWzBdO1xuICAgIGNvbnN0IHsgY29tcG9uZW50cywgY29tcG9uZW50c09yZGVyIH0gPSBmcmFtZTtcbiAgICBjb25zdCBvdXRDb21wb25lbnRzID0gW107XG4gICAgY29uc3Qgd2lkdGggPSBmcmFtZS5zYW1wbGVzUGVyTGluZTtcbiAgICBjb25zdCBoZWlnaHQgPSBmcmFtZS5zY2FuTGluZXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHNPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRzT3JkZXJbaV1dO1xuICAgICAgb3V0Q29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgbGluZXM6IGJ1aWxkQ29tcG9uZW50RGF0YShmcmFtZSwgY29tcG9uZW50KSxcbiAgICAgICAgc2NhbGVYOiBjb21wb25lbnQuaCAvIGZyYW1lLm1heEgsXG4gICAgICAgIHNjYWxlWTogY29tcG9uZW50LnYgLyBmcmFtZS5tYXhWLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiBvdXRDb21wb25lbnRzLmxlbmd0aCk7XG4gICAgbGV0IG9pID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRDb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gb3V0Q29tcG9uZW50c1tpXTtcbiAgICAgICAgICBvdXRbb2ldID0gY29tcG9uZW50LmxpbmVzWzAgfCB5ICogY29tcG9uZW50LnNjYWxlWV1bMCB8IHggKiBjb21wb25lbnQuc2NhbGVYXTtcbiAgICAgICAgICArK29pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSnBlZ0RlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVhZGVyID0gbmV3IEpwZWdTdHJlYW1SZWFkZXIoKTtcbiAgICBpZiAoZmlsZURpcmVjdG9yeS5KUEVHVGFibGVzKSB7XG4gICAgICB0aGlzLnJlYWRlci5wYXJzZShmaWxlRGlyZWN0b3J5LkpQRUdUYWJsZXMpO1xuICAgIH1cbiAgfVxuXG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHRoaXMucmVhZGVyLnJlc2V0RnJhbWVzKCk7XG4gICAgdGhpcy5yZWFkZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG4gICAgcmV0dXJuIHRoaXMucmVhZGVyLmdldFJlc3VsdCgpLmJ1ZmZlcjtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIi8vIFN0cmluZyBlbmNvZGUvZGVjb2RlIGhlbHBlcnNcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbi8vIFF1aWNrIGNoZWNrIGlmIHdlIGNhbiB1c2UgZmFzdCBhcnJheSB0byBiaW4gc3RyaW5nIGNvbnZlcnNpb25cbi8vXG4vLyAtIGFwcGx5KEFycmF5KSBjYW4gZmFpbCBvbiBBbmRyb2lkIDIuMlxuLy8gLSBhcHBseShVaW50OEFycmF5KSBjYW4gZmFpbCBvbiBpT1MgNS4xIFNhZmFyaVxuLy9cbnZhciBTVFJfQVBQTFlfT0sgPSB0cnVlO1xudmFyIFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFsgMCBdKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX09LID0gZmFsc2U7IH1cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfVUlBX09LID0gZmFsc2U7IH1cblxuXG4vLyBUYWJsZSB3aXRoIHV0ZjggbGVuZ3RocyAoY2FsY3VsYXRlZCBieSBmaXJzdCBieXRlIG9mIHNlcXVlbmNlKVxuLy8gTm90ZSwgdGhhdCA1ICYgNi1ieXRlIHZhbHVlcyBhbmQgc29tZSA0LWJ5dGUgdmFsdWVzIGNhbiBub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlMsXG4vLyBiZWNhdXNlIG1heCBwb3NzaWJsZSBjb2RlcG9pbnQgaXMgMHgxMGZmZmZcbnZhciBfdXRmOGxlbiA9IG5ldyB1dGlscy5CdWY4KDI1Nik7XG5mb3IgKHZhciBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZfbGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KGJ1Zl9sZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbV9wb3MgPSAwOyBpIDwgYnVmX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhFMCB8IChjID4+PiAxMik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8vIEhlbHBlciAodXNlZCBpbiAyIHBsYWNlcylcbmZ1bmN0aW9uIGJ1ZjJiaW5zdHJpbmcoYnVmLCBsZW4pIHtcbiAgLy8gT24gQ2hyb21lLCB0aGUgYXJndW1lbnRzIGluIGEgZnVuY3Rpb24gY2FsbCB0aGF0IGFyZSBhbGxvd2VkIGlzIGA2NTUzNGAuXG4gIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gdGhhdCwgd2UgY2FuIHVzZSB0aGlzIG9wdGltaXphdGlvbixcbiAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgdGFrZSBhIHNsb3dlciBwYXRoLlxuICBpZiAobGVuIDwgNjU1MzQpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIEdaaGVhZGVyKCkge1xuICAvKiB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0ICovXG4gIHRoaXMudGV4dCAgICAgICA9IDA7XG4gIC8qIG1vZGlmaWNhdGlvbiB0aW1lICovXG4gIHRoaXMudGltZSAgICAgICA9IDA7XG4gIC8qIGV4dHJhIGZsYWdzIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMueGZsYWdzICAgICA9IDA7XG4gIC8qIG9wZXJhdGluZyBzeXN0ZW0gKi9cbiAgdGhpcy5vcyAgICAgICAgID0gMDtcbiAgLyogcG9pbnRlciB0byBleHRyYSBmaWVsZCBvciBaX05VTEwgaWYgbm9uZSAqL1xuICB0aGlzLmV4dHJhICAgICAgPSBudWxsO1xuICAvKiBleHRyYSBmaWVsZCBsZW5ndGggKHZhbGlkIGlmIGV4dHJhICE9IFpfTlVMTCkgKi9cbiAgdGhpcy5leHRyYV9sZW4gID0gMDsgLy8gQWN0dWFsbHksIHdlIGRvbid0IG5lZWQgaXQgaW4gSlMsXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBmb3IgZmV3IGNvZGUgbW9kaWZpY2F0aW9uc1xuXG4gIC8vXG4gIC8vIFNldHVwIGxpbWl0cyBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnlcbiAgLy8gZm9yIGluZmxhdGUgdXNlIGNvbnN0YW50IGxpbWl0IGluIDY1NTM2IGJ5dGVzXG4gIC8vXG5cbiAgLyogc3BhY2UgYXQgZXh0cmEgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5leHRyYV9tYXggID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgZmlsZSBuYW1lIG9yIFpfTlVMTCAqL1xuICB0aGlzLm5hbWUgICAgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgbmFtZSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLm5hbWVfbWF4ICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBjb21tZW50IG9yIFpfTlVMTCAqL1xuICB0aGlzLmNvbW1lbnQgICAgPSAnJztcbiAgLyogc3BhY2UgYXQgY29tbWVudCAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmNvbW1fbWF4ICAgPSAwO1xuICAvKiB0cnVlIGlmIHRoZXJlIHdhcyBvciB3aWxsIGJlIGEgaGVhZGVyIGNyYyAqL1xuICB0aGlzLmhjcmMgICAgICAgPSAwO1xuICAvKiB0cnVlIHdoZW4gZG9uZSByZWFkaW5nIGd6aXAgaGVhZGVyIChub3QgdXNlZCB3aGVuIHdyaXRpbmcgYSBnemlwIGZpbGUpICovXG4gIHRoaXMuZG9uZSAgICAgICA9IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdaaGVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiIsImltcG9ydCB7IGluZmxhdGUgfSBmcm9tICdwYWtvL2xpYi9pbmZsYXRlJztcbmltcG9ydCBCYXNlRGVjb2RlciBmcm9tICcuL2Jhc2VkZWNvZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmbGF0ZURlY29kZXIgZXh0ZW5kcyBCYXNlRGVjb2RlciB7XG4gIGRlY29kZUJsb2NrKGJ1ZmZlcikge1xuICAgIHJldHVybiBpbmZsYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpLmJ1ZmZlcjtcbiAgfVxufVxuIiwiaW1wb3J0IEJhc2VEZWNvZGVyIGZyb20gJy4vYmFzZWRlY29kZXInO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhY2tiaXRzRGVjb2RlciBleHRlbmRzIEJhc2VEZWNvZGVyIHtcbiAgZGVjb2RlQmxvY2soYnVmZmVyKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBjb25zdCBvdXQgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmJ5dGVMZW5ndGg7ICsraSkge1xuICAgICAgbGV0IGhlYWRlciA9IGRhdGFWaWV3LmdldEludDgoaSk7XG4gICAgICBpZiAoaGVhZGVyIDwgMCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gZGF0YVZpZXcuZ2V0VWludDgoaSArIDEpO1xuICAgICAgICBoZWFkZXIgPSAtaGVhZGVyO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBoZWFkZXI7ICsraikge1xuICAgICAgICAgIG91dC5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGhlYWRlcjsgKytqKSB7XG4gICAgICAgICAgb3V0LnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSArIGogKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSBoZWFkZXIgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob3V0KS5idWZmZXI7XG4gIH1cbn1cbiIsImltcG9ydCBSYXdEZWNvZGVyIGZyb20gJy4vcmF3JztcbmltcG9ydCBMWldEZWNvZGVyIGZyb20gJy4vbHp3JztcbmltcG9ydCBKcGVnRGVjb2RlciBmcm9tICcuL2pwZWcnO1xuaW1wb3J0IERlZmxhdGVEZWNvZGVyIGZyb20gJy4vZGVmbGF0ZSc7XG5pbXBvcnQgUGFja2JpdHNEZWNvZGVyIGZyb20gJy4vcGFja2JpdHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KSB7XG4gIHN3aXRjaCAoZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbikge1xuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgIGNhc2UgMTogLy8gbm8gY29tcHJlc3Npb25cbiAgICAgIHJldHVybiBuZXcgUmF3RGVjb2RlcigpO1xuICAgIGNhc2UgNTogLy8gTFpXXG4gICAgICByZXR1cm4gbmV3IExaV0RlY29kZXIoZmlsZURpcmVjdG9yeSk7XG4gICAgY2FzZSA2OiAvLyBKUEVHXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29sZCBzdHlsZSBKUEVHIGNvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgY2FzZSA3OiAvLyBKUEVHXG4gICAgICByZXR1cm4gbmV3IEpwZWdEZWNvZGVyKGZpbGVEaXJlY3RvcnkpO1xuICAgIGNhc2UgODogLy8gRGVmbGF0ZSBhcyByZWNvZ25pemVkIGJ5IEFkb2JlXG4gICAgY2FzZSAzMjk0NjogLy8gRGVmbGF0ZSBHREFMIGRlZmF1bHRcbiAgICAgIHJldHVybiBuZXcgRGVmbGF0ZURlY29kZXIoKTtcbiAgICBjYXNlIDMyNzczOiAvLyBwYWNrYml0c1xuICAgICAgcmV0dXJuIG5ldyBQYWNrYml0c0RlY29kZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiAke2ZpbGVEaXJlY3RvcnkuQ29tcHJlc3Npb259YCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICdnZW90aWZmL3NyYy9jb21wcmVzc2lvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWZmRGVjb2RlcihmaWxlRGlyZWN0b3J5KSB7XG4gIHJldHVybiBnZXREZWNvZGVyKGZpbGVEaXJlY3RvcnkpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5cbmltcG9ydCB7IGdldFRpZmZEZWNvZGVyIH0gZnJvbSAnLi9kZWNvZGVyJztcblxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlKHNlbGYsIGZpbGVEaXJlY3RvcnksIGJ1ZmZlcikge1xuICBjb25zdCBkZWNvZGVyID0gZ2V0VGlmZkRlY29kZXIoZmlsZURpcmVjdG9yeSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY29kZXIuZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcik7XG4gIHNlbGYucG9zdE1lc3NhZ2UoW3Jlc3VsdF0sIFtyZXN1bHRdKTtcbn1cblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBldmVudCA9PiB7XG4gICAgY29uc3QgW25hbWUsIC4uLmFyZ3NdID0gZXZlbnQuZGF0YTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2RlY29kZSc6XG4gICAgICAgIGRlY29kZShzZWxmLCAuLi5hcmdzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBOztFQUVBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7OztFQ3JGQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOzs7RUNmQTtFQUNBO0VBQ0E7RUFDQTs7RUNQQTs7O0VDS0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7RUNoQkE7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBR0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBOztFQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaDRCQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBOzs7RUN0R0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7O0VDaERBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTs7RUN4REE7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VDdFZBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBOztBQUVBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7RUNwVkE7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7Ozs7OztBQU1BO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFJQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7Ozs7Ozs7Ozs7Ozs7O0VDNWdEQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7Ozs7Ozs7Ozs7RUN4TEE7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBOztFQ2pFQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0VDN0JBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTs7RUM1Q0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTs7RUM5Q0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7QUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0FBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0FBQ0E7RUFDQTtFQUNBO0VBNkJBOzs7RUNoYUE7RUFDQTtFQUNBO0VBQ0E7OztFQ0hBO0VBQ0E7RUFDQTtBQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7OztFQ25CQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTs7O0VDdEJBO0VBQ0E7O0VDSkE7QUFHQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBR0E7RUFDQTtFQUNBOzs7Ozs7In0=', false);
/* eslint-enable */

// https://developer.mozilla.org/en-US/docs/Web/API/NavigatorConcurrentHardware/hardwareConcurrency
// We need to give a different way of getting this for safari, so 4 is probably a safe bet
// for parallel processing in the meantime.  More can't really hurt since they'll just block
// each other and not the UI thread, which is the real benefit.
const defaultPoolSize =
  typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 4 : null;

/**
 * Pool for workers to decode chunks of the images.
 * This is a line-for-line copy of GeoTIFFs old implementation: https://github.com/geotiffjs/geotiff.js/blob/v1.0.0-beta.6/src/pool.js
 */
class Pool {
  /**
   * @constructor
   * @param {Number} size The size of the pool. Defaults to the number of CPUs
   *                      available. When this parameter is `null` or 0, then the
   *                      decoding will be done in the main thread.
   */
  constructor(size = defaultPoolSize) {
    this.workers = [];
    this.idleWorkers = [];
    this.waitQueue = [];
    this.decoder = null;

    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < size; ++i) {
      const w = new WorkerFactory();
      this.workers.push(w);
      this.idleWorkers.push(w);
    }
  }

  /**
   * Decode the given block of bytes with the set compression method.
   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
   * @returns {Promise.<ArrayBuffer>} the decoded result as a `Promise`
   */
  async decode(fileDirectory, buffer) {
    const currentWorker = await this.waitForWorker();
    return new Promise((resolve, reject) => {
      currentWorker.onmessage = event => {
        // this.workers.push(currentWorker);
        this.finishTask(currentWorker);
        resolve(event.data[0]);
      };
      currentWorker.onerror = error => {
        // this.workers.push(currentWorker);
        this.finishTask(currentWorker);
        reject(error);
      };
      currentWorker.postMessage(['decode', fileDirectory, buffer], [buffer]);
    });
  }

  async waitForWorker() {
    const idleWorker = this.idleWorkers.pop();
    if (idleWorker) {
      return idleWorker;
    }
    const waiter = {};
    const promise = new Promise(resolve => {
      waiter.resolve = resolve;
    });

    this.waitQueue.push(waiter);
    return promise;
  }

  async finishTask(currentWorker) {
    const waiter = this.waitQueue.pop();
    if (waiter) {
      waiter.resolve(currentWorker);
    } else {
      this.idleWorkers.push(currentWorker);
    }
  }

  destroy() {
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < this.workers.length; ++i) {
      this.workers[i].terminate();
    }
  }
}

function isInTileBounds({
  x,
  y,
  z,
  width,
  height,
  tileSize,
  numLevels
}) {
  const xInBounds = x < Math.ceil(width / (tileSize * 2 ** z)) && x >= 0;
  const yInBounds = y < Math.ceil(height / (tileSize * 2 ** z)) && y >= 0;
  const zInBounds = z >= 0 && z < numLevels;
  return xInBounds && yInBounds && zInBounds;
}

function guessRgb(shape) {
  const lastDimSize = shape[shape.length - 1];
  return shape.length > 2 && (lastDimSize === 3 || lastDimSize === 4);
}

/**
 * Flips the bytes of TypedArray in place. Used to flipendianess
 * Adapted from https://github.com/zbjornson/node-bswap/blob/master/bswap.js
 * @param {TypedArray} src
 * @returns {void}
 */
function byteSwapInplace(src) {
  const b = src.BYTES_PER_ELEMENT;
  const flipper = new Uint8Array(src.buffer, src.byteOffset, src.length * b);
  const numFlips = b / 2;
  const endByteIndex = b - 1;
  let t = 0;
  for (let i = 0; i < flipper.length; i += b) {
    for (let j = 0; j < numFlips; j += 1) {
      t = flipper[i + j];
      flipper[i + j] = flipper[i + endByteIndex - j];
      flipper[i + endByteIndex - j] = t;
    }
  }
}

/**
 * Returns actual image stats for static imagery and an estimate via a downsampled version of image pyramids.
 * This is helpful for generating histograms of your channel data, or scaling your sliders down to a reasonable range.
 * Also provided are "autoSliders" which are slider bounds that should give a good initial image.
 * @param {Object} args
 * @param {Object} args.loader A valid loader object.
 * @param {Array} args.loaderSelection Array of valid dimension selections
 * @returns {Array} List of { mean, domain, sd, data, q1, q3, autoSliders } objects.
 */
async function getChannelStats({ loader, loaderSelection }) {
  const z = loader.isPyramid ? loader.numLevels - 1 : 0;
  const rasters = await loader.getRaster({ z, loaderSelection });
  const { data } = rasters;
  const channelStats = data.map(arr => {
    let len = arr.length;
    let min = Infinity;
    let max = -Infinity;
    let total = 0;
    // Range (min/max).
    // eslint-disable-next-line no-plusplus
    while (len--) {
      if (arr[len] < min) {
        min = arr[len];
      }
      if (arr[len] > max) {
        max = arr[len];
      }
      total += arr[len];
    }

    // Mean.
    const mean = total / arr.length;

    // Standard Deviation.
    len = arr.length;
    let sumSquared = 0;
    // eslint-disable-next-line no-plusplus
    while (len--) {
      sumSquared += (arr[len] - mean) ** 2;
    }
    const sd = (sumSquared / arr.length) ** 0.5;

    // Median, and quartiles via quickselect: https://en.wikipedia.org/wiki/Quickselect.
    // Odd number lengths should round down the index.
    const mid = Math.floor(arr.length / 2);
    const firstQuartileLocation = Math.floor(arr.length / 4);
    const thirdQuartileLocation = 3 * Math.floor(arr.length / 4);

    quickselect(arr, mid);
    const median = arr[mid];
    quickselect(arr, firstQuartileLocation, 0, mid);
    const q1 = arr[firstQuartileLocation];
    quickselect(arr, thirdQuartileLocation, mid, arr.length - 1);
    const q3 = arr[thirdQuartileLocation];

    // Used for "auto" settings.  This is the best parameter I've found experimentally.
    // I don't think there is a right answer and this feature is common in Fiji.
    // Also it's best to use a non-zero array for this.
    const cutoffArr = arr.filter(i => i >= 1);
    const cutoffPercentile = 0.0005;
    const topCutoffLocation = Math.floor(
      cutoffArr.length * (1 - cutoffPercentile)
    );
    const bottomCutoffLocation = Math.floor(
      cutoffArr.length * cutoffPercentile
    );
    quickselect(cutoffArr, topCutoffLocation);
    quickselect(cutoffArr, bottomCutoffLocation, 0, topCutoffLocation);
    const autoSliders = [
      cutoffArr[bottomCutoffLocation],
      cutoffArr[topCutoffLocation]
    ];
    return {
      mean,
      sd,
      q1,
      q3,
      median,
      data: arr,
      domain: [min, max],
      autoSliders
    };
  });
  return channelStats;
}

/**
 * Retrieves blob from zarr store and parses as JSON.
 * @param {Object} store Valid zarr.Store
 * @param {String} key String path to to decode from store.
 * @returns {Object}
 */
async function getJson(store, key) {
  const bytes = new Uint8Array(await store.getItem(key));
  const decoder = new TextDecoder('utf-8');
  const json = JSON.parse(decoder.decode(bytes));
  return json;
}

/**
 * Builds a dimensions object from OMEXML
 * @param {Object} omexml OMEXML class
 * @returns {Array} Array of dimensions objects
 */
function dimensionsFromOMEXML(omexml) {
  const { SizeZ, SizeT, DimensionOrder } = omexml;
  const dims = DimensionOrder.toLowerCase()
    .split('')
    .slice()
    .reverse();
  const dimensions = dims.map(field => {
    if (field === 'x' || field === 'y') {
      return { field, type: 'quantitative', values: null };
    }
    if (field === 'c') {
      return {
        field: 'channel',
        type: 'nominal',
        values: omexml.getChannelNames()
      };
    }
    const type = 'ordinal';
    if (field === 't') {
      return { field: 'time', type, values: range(SizeT) };
    }
    return { field, type, values: range(SizeZ) };
  });
  return dimensions;
}

/**
 * Preserves (double) slashes earlier in the path, so this works better
 * for URLs. From https://stackoverflow.com/a/46427607/4178400
 * @param args parts of a path or URL to join.
 */
function joinUrlParts(...args) {
  return args
    .map((part, i) => {
      if (i === 0) return part.trim().replace(/[/]*$/g, '');
      return part.trim().replace(/(^[/]*|[/]*$)/g, '');
    })
    .filter(x => x.length)
    .join('/');
}

class HTTPStore {
  constructor(url, options = {}) {
    this.url = url;
    this.options = options;
  }

  async getItem(key, options = {}) {
    const url = joinUrlParts(this.url, key);
    const value = await fetch(url, { ...this.options, ...options });
    if (value.status === 404) {
      throw new KeyError(key);
    } else if (value.status !== 200) {
      throw new HTTPError(String(value.status));
    }
    return value.arrayBuffer();
  }

  async containsItem(key, options = {}) {
    const url = joinUrlParts(this.url, key);
    const value = await fetch(url, { ...this.options, ...options });
    return value.status === 200;
  }
}

function _optionalChain$5(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
/**
 * This class serves as a wrapper for fetching zarr data from a file server.
 * */
class ZarrLoader {
  constructor({
    data,
    dimensions,
    isRgb,
    scale = 1,
    translate = { x: 0, y: 0 }
  }) {
    let base;
    if (Array.isArray(data)) {
      [base] = data;
      this.numLevels = data.length;
    } else {
      base = data;
      this.numLevels = 1;
    }
    this.type = 'zarr';
    this.scale = scale;
    this.translate = translate;
    this.isRgb = isRgb || guessRgb(base.shape);
    this.dimensions = dimensions;

    this._data = data;
    this._dimIndices = new Map();
    dimensions.forEach(({ field }, i) => this._dimIndices.set(field, i));

    const { dtype, chunks } = base;
    /* TODO: Use better dtype convention in DTYPE_LOOKUP.
     * https://github.com/hms-dbmi/viv/issues/203
     *
     * This convension should probably _not_ describe endianness,
     * since endianness is resolved when decoding the source arrayBuffers
     * into TypedArrays. The dtype of the zarr array describes the dtype of the
     * source but this is different from how the bytes end up being represented in
     * memory client-side.
     */
    this.dtype = `<${dtype.slice(1)}`;
    this.tileSize = chunks[this._dimIndices.get('x')];
  }

  get isPyramid() {
    return Array.isArray(this._data);
  }

  get base() {
    return this.isPyramid ? this._data[0] : this._data;
  }

  /**
   * Returns image tiles at tile-position (x, y) at pyramidal level z.
   * @param {number} args
   * @param {number} args.x positive integer
   * @param {number} args.y positive integer
   * @param {number} args.z positive integer (0 === highest zoom level)
   * @param {Array} args.loaderSelection Array of valid dimension selections
   * @param {Array} args.signal AbortSignal object
   * @returns {Object} data: TypedArray[], width: number (tileSize), height: number (tileSize)
   */
  async getTile({ x, y, z, loaderSelection = [], signal }) {
    const { TypedArray } = DTYPE_VALUES[this.dtype];
    const source = this._getSource(z);
    const [xIndex, yIndex] = ['x', 'y'].map(k => this._dimIndices.get(k));

    const dataRequests = loaderSelection.map(async sel => {
      const chunkKey = this._serializeSelection(sel);
      chunkKey[yIndex] = y;
      chunkKey[xIndex] = x;

      const key = source.keyPrefix + chunkKey.join('.');
      let buffer;
      try {
        buffer = await source.store.getItem(key, { signal });
      } catch (err) {
        if (err.name !== 'AbortError') {
          throw err;
        }
        return null;
      }
      let bytes = new Uint8Array(buffer);
      if (source.compressor) {
        bytes = await source.compressor.decode(bytes);
      }
      const data = new TypedArray(bytes.buffer);
      if (source.dtype[0] === '>') {
        // big endian
        byteSwapInplace(data);
      }
      return data;
    });
    const data = await Promise.all(dataRequests);
    if (source.store instanceof HTTPStore && _optionalChain$5([signal, 'optionalAccess', _ => _.aborted])) return null;
    const width = source.chunks[xIndex];
    const height = source.chunks[yIndex];
    return { data, width, height };
  }

  /**
   * Returns full image panes (at level z if pyramid)
   * @param {number} args
   * @param {number} args.z positive integer (0 === highest zoom level)
   * @param {Array} args.loaderSelection, Array of valid dimension selections
   * @returns {Object} data: TypedArray[], width: number, height: number
   */
  async getRaster({ z, loaderSelection = [] }) {
    const source = this._getSource(z);
    const [xIndex, yIndex] = ['x', 'y'].map(k => this._dimIndices.get(k));

    const dataRequests = loaderSelection.map(async sel => {
      const chunkKey = this._serializeSelection(sel);
      chunkKey[yIndex] = null;
      chunkKey[xIndex] = null;
      if (this.isRgb) {
        chunkKey[chunkKey.length - 1] = null;
      }
      const { data } = await source.getRaw(chunkKey);
      return data;
    });

    const data = await Promise.all(dataRequests);
    const { shape } = source;
    const width = shape[xIndex];
    const height = shape[yIndex];
    return { data, width, height };
  }

  /**
   * Handles `onTileError` within deck.gl
   * @param {Error} err Error thrown in tile layer
   */
  // eslint-disable-next-line class-methods-use-this
  onTileError(err) {
    if (!(err instanceof BoundsCheckError)) {
      // Rethrow error if something other than tile being requested is out of bounds.
      throw err;
    }
  }

  /**
   * Returns image width and height (at pyramid level z) without fetching data
   * @param {Object} args
   * @param {number} args.z positive integer (0 === highest zoom level)
   * @returns {Object} width: number, height: number
   */
  getRasterSize({ z }) {
    const { shape } = this._getSource(z);
    const [height, width] = ['y', 'x'].map(k => shape[this._dimIndices.get(k)]);
    return { height, width };
  }

  /**
   * Get the metadata associated with a Zarr image layer, in a human-readable format.
   * @returns {Object} Metadata keys mapped to values.
   */
  // eslint-disable-next-line class-methods-use-this
  getMetadata() {
    return {};
  }

  _getSource(z) {
    return typeof z === 'number' && this.isPyramid ? this._data[z] : this._data;
  }

  /**
   * Returns valid zarr.js selection for ZarrArray.getRaw or ZarrArray.getRawChunk
   * @param {Object} selection valid dimension selection
   * @returns {Array} Array of indicies
   *
   * Valid dimension selections include:
   *   - Direct zarr.js selection: [1, 0, 0, 0]
   *   - Named selection object: { channel: 0, time: 2 } or { channel: "DAPI", time: 2 }
   */
  _serializeSelection(selection) {
    // Just return copy if array-like zarr.js selection
    if (Array.isArray(selection)) return [...selection];

    const serialized = Array(this.dimensions.length).fill(0);
    Object.entries(selection).forEach(([dimName, value]) => {
      if (!this._dimIndices.has(dimName)) {
        throw Error(
          `Dimension "${dimName}" does not exist on loader.
           Must be one of "${this.dimensions.map(d => d.field)}."`
        );
      }
      const dimIndex = this._dimIndices.get(dimName);
      switch (typeof value) {
        case 'number': {
          // ex. { channel: 0 }
          serialized[dimIndex] = value;
          break;
        }
        case 'string': {
          const { values, type } = this.dimensions[dimIndex];
          if (type === 'nominal' || type === 'ordinal') {
            // ex. { channel: 'DAPI' }
            serialized[dimIndex] = values.indexOf(value);
            break;
          } else {
            // { z: 'DAPI' }
            throw Error(
              `Cannot use selection "${value}" for dimension "${dimName}" with type "${type}".`
            );
          }
        }
        default: {
          throw Error(
            `Named selection must be a string or number. Got ${value} for ${dimName}.`
          );
        }
      }
    });
    return serialized;
  }
}

/* eslint-disable radix */

class OMEXML {
  constructor(omexmlString) {
    const options = {
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      trimValues: true,
      allowBooleanAttributes: true
    };
    this.metadataOMEXML = parser.parse(omexmlString, options).OME;
    const { Pixels } = this.metadataOMEXML.Image.length
      ? this.metadataOMEXML.Image[0]
      : this.metadataOMEXML.Image;
    this._Pixels = Pixels;
    this.SizeZ = Number.parseInt(Pixels['@_SizeZ']);
    this.SizeT = Number.parseInt(Pixels['@_SizeT']);
    this.SizeC = Number.parseInt(Pixels['@_SizeC']);
    this.SizeX = Number.parseInt(Pixels['@_SizeX']);
    this.SizeY = Number.parseInt(Pixels['@_SizeY']);
    this.Interleaved = Pixels['@_Interleaved'] === 'true';
    this.DimensionOrder = Pixels['@_DimensionOrder'];
    this.Type = Pixels['@_Type'];
    const PhysicalSizeYUnit = Pixels['@_PhysicalSizeYUnit'];
    // This µ character is not well handled - I got odd behavior but this solves it.
    // There was a prepended character so now I just look for µm to be included
    // and use only µm if it is found.
    this.PhysicalSizeYUnit =
      PhysicalSizeYUnit && PhysicalSizeYUnit.includes('µm')
        ? 'µm'
        : PhysicalSizeYUnit;
    const PhysicalSizeXUnit = Pixels['@_PhysicalSizeXUnit'];
    this.PhysicalSizeXUnit =
      PhysicalSizeXUnit && PhysicalSizeXUnit.includes('µm')
        ? 'µm'
        : PhysicalSizeXUnit;
    this.PhysicalSizeY = Pixels['@_PhysicalSizeY'];
    this.PhysicalSizeX = Pixels['@_PhysicalSizeX'];
  }

  getChannelNames() {
    const { Channel } = this._Pixels;
    return Array.isArray(Channel)
      ? Channel.map((channel, i) => channel['@_Name'] || `Channel ${i}`)
      : [Channel['@_Name'] || `Channel ${0}`];
  }

  getNumberOfImages() {
    return this.metadataOMEXML.Image.length || 0;
  }

  get SamplesPerPixel() {
    const { Channel } = this._Pixels;
    return Array.isArray(Channel)
      ? Channel.map(channel => channel['@_SamplesPerPixel'])[0]
      : [Channel['@_SamplesPerPixel']];
  }
}

function _optionalChain$6(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const DTYPE_LOOKUP = {
  uint8: '<u1',
  uint16: '<u2',
  uint32: '<u4',
  float: '<f4',
  // TODO: we currently need to cast these dtypes to their uint counterparts.
  int8: '<u1',
  int16: '<u2',
  int32: '<u4'
};

/**
 * This class serves as a wrapper for fetching tiff data from a file server.
 * @param {Object} args
 * @param {Object} args.tiff geotiffjs tiff object.
 * @param {Object} args.pool Pool that implements a `decode` function.
 * @param {Object} args.firstImage First image (geotiff Image object) in the tiff (containing base-resolution data).
 * @param {String} args.omexmlString Raw OMEXML as a string.
 * @param {Array} args.offsets The offsets of each IFD in the tiff.
 * */
class OMETiffLoader {
  constructor({ tiff, pool, firstImage, omexmlString, offsets }) {
    this.pool = pool;
    this.tiff = tiff;
    this.type = 'ome-tiff';
    // get first image's description, which contains OMEXML
    this.omexml = new OMEXML(omexmlString);
    this.physicalSizes = {
      x: {
        value: this.omexml.PhysicalSizeX,
        unit: this.omexml.PhysicalSizeXUnit
      },
      y: {
        value: this.omexml.PhysicalSizeY,
        unit: this.omexml.PhysicalSizeYUnit
      }
    };
    this.software = firstImage.fileDirectory.Software;
    this.photometricInterpretation =
      firstImage.fileDirectory.PhotometricInterpretation;
    this.offsets = offsets || [];
    this.channelNames = this.omexml.getChannelNames();
    this.width = this.omexml.SizeX;
    this.height = this.omexml.SizeY;
    this.tileSize = firstImage.getTileWidth();
    const { SubIFDs } = firstImage.fileDirectory;
    this.numLevels = _optionalChain$6([SubIFDs, 'optionalAccess', _ => _.length])
      ? SubIFDs.length + 1
      : this.omexml.getNumberOfImages();
    this.isBioFormats6Pyramid = SubIFDs;
    this.isPyramid = this.numLevels > 1;
    this.dimensions = dimensionsFromOMEXML(this.omexml);
    // We use zarr's internal format.  It encodes endianness, but we leave it little for now
    // since javascript is little endian.
    this.dtype = DTYPE_LOOKUP[this.omexml.Type];
    // This is experimental and will take some tuning to properly detect.  For now,
    // if the SamplesPerPixel is 3 (i.e interleaved) or if there are three uint8 channels,
    // we flag that as rgb.
    this.isRgb =
      this.omexml.SamplesPerPixel === 3 ||
      (this.channelNames.length === 3 && this.omexml.Type === 'uint8') ||
      (this.omexml.SizeC === 3 &&
        this.channelNames.length === 1 &&
        this.omexml.Interleaved);
    this.isInterleaved = this.omexml.Interleaved;
  }

  /**
   * Returns an IFD index for a given loader selection.
   * @param {Object} args
   * @param {number} args.z Z axis selection.
   * @param {number} args.time Time axis selection.
   * @param {String} args.channel Channel axis selection.
   * @returns {number} IFD index.
   */
  _getIFDIndex({ z = 0, channel, time = 0 }) {
    let channelIndex;
    // Without names, enforce a numeric channel indexing scheme
    if (this.channelNames.every(v => !v)) {
      console.warn(
        'No channel names found in OMEXML.  Please be sure to use numeric indexing.'
      );
      channelIndex = channel;
    } else if (typeof channel === 'string') {
      channelIndex = this.channelNames.indexOf(channel);
    } else if (typeof channel === 'number') {
      channelIndex = channel;
    } else {
      throw new Error('Channel selection must be numeric index or string');
    }
    const { SizeZ, SizeT, SizeC, DimensionOrder } = this.omexml;
    switch (DimensionOrder) {
      case 'XYZCT': {
        return time * SizeZ * SizeC + channelIndex * SizeZ + z;
      }
      case 'XYZTC': {
        return channelIndex * SizeZ * SizeT + time * SizeZ + z;
      }
      case 'XYCTZ': {
        return z * SizeC * SizeT + time * SizeC + channelIndex;
      }
      case 'XYCZT': {
        return time * SizeC * SizeZ + z * SizeC + channelIndex;
      }
      case 'XYTCZ': {
        return z * SizeT * SizeC + channelIndex * SizeT + time;
      }
      case 'XYTZC': {
        return channelIndex * SizeT * SizeZ + z * SizeT + time;
      }
      default: {
        throw new Error('Dimension order is required for OMETIFF');
      }
    }
  }

  /**
   * Handles `onTileError` within deck.gl
   * @param {Error} err Error thrown in tile layer
   */
  // eslint-disable-next-line class-methods-use-this
  onTileError(err) {
    console.error(err);
  }

  /**
   * Returns image tiles at tile-position (x, y) at pyramidal level z.
   * @param {Object} args
   * @param {number} args.x positive integer
   * @param {number} args.y positive integer
   * @param {number} args.z positive integer (0 === highest zoom level)
   * @param {Array} args.loaderSelection, Array of number Arrays specifying channel selections
   * @param {Array} args.signal AbortSignal object
   * @returns {Object} data: TypedArray[], width: number (tileSize), height: number (tileSize).
   * Default is `{data: [], width: tileSize, height: tileSize}`.
   */
  async getTile({ x, y, z, loaderSelection = [], signal }) {
    if (!this._tileInBounds({ x, y, z })) {
      return null;
    }
    const { tiff, isBioFormats6Pyramid, omexml } = this;
    const { SizeZ, SizeT, SizeC } = omexml;
    const pyramidOffset = z * SizeZ * SizeT * SizeC;
    let image;
    const tileRequests = loaderSelection.map(async sel => {
      const index = this._getIFDIndex(sel);
      const pyramidIndex = pyramidOffset + index;
      // We need to put the request for parsing the file directory into this array.
      // This allows us to get tiff pages directly based on offset without parsing everything.
      if (!isBioFormats6Pyramid) {
        this._parseIFD(pyramidIndex);
      } else {
        // Pyramids with large z-stacks + large numbers of channels could get slow
        // so we allow for offsets for the lowest-resolution images ("parentImage").
        this._parseIFD(index);
        const parentImage = await tiff.getImage(index);
        if (z !== 0) {
          tiff.ifdRequests[pyramidIndex] = tiff.parseFileDirectoryAt(
            parentImage.fileDirectory.SubIFDs[z - 1]
          );
        }
      }
      image = await tiff.getImage(pyramidIndex);
      return this._getChannel({ image, x, y, z, signal });
    });
    const data = await Promise.all(tileRequests);
    const { height, width } = this._getTileExtent({
      x,
      y,
      z
    });
    if (_optionalChain$6([signal, 'optionalAccess', _2 => _2.aborted])) return null;
    return {
      data,
      height,
      width
    };
  }

  /**
   * Returns full image panes (at level z if pyramid)
   * @param {Object} args
   * @param {number} args.z positive integer (0 === highest zoom level)
   * @param {Array} args.loaderSelection, Array of number Arrays specifying channel selections
   * @returns {Object} data: TypedArray[], width: number, height: number
   * Default is `{data: [], width, height}`.
   */
  async getRaster({ z, loaderSelection }) {
    const { tiff, omexml, isBioFormats6Pyramid, pool, isInterleaved } = this;
    const { SizeZ, SizeT, SizeC } = omexml;
    const rasters = await Promise.all(
      loaderSelection.map(async sel => {
        const index = this._getIFDIndex(sel);
        const pyramidIndex = z * SizeZ * SizeT * SizeC + index;
        // We need to put the request for parsing the file directory into this array.
        // This allows us to get tiff pages directly based on offset without parsing everything.
        if (!isBioFormats6Pyramid) {
          this._parseIFD(pyramidIndex);
        } else {
          // Pyramids with large z-stacks + large numbers of channels could get slow
          // so we allow for offsets for the initial images ("parentImage").
          this._parseIFD(index);
          const parentImage = await tiff.getImage(index);
          if (z !== 0) {
            tiff.ifdRequests[pyramidIndex] = tiff.parseFileDirectoryAt(
              parentImage.fileDirectory.SubIFDs[z - 1]
            );
          }
        }
        const image = await tiff.getImage(pyramidIndex);
        // Flips bits for us for endianness.
        const raster = await image.readRasters({
          pool,
          interleave: isInterleaved
        });
        return isInterleaved ? raster : raster[0];
      })
    );
    // Get first selection * SizeZ * SizeT * SizeC + loaderSelection[0] size as proxy for image size.
    if (!loaderSelection || loaderSelection.length === 0) {
      return { data: [], ...this.getRasterSize({ z }) };
    }
    const image = await tiff.getImage(
      z * SizeZ * SizeT * SizeC + this._getIFDIndex(loaderSelection[0])
    );
    const width = image.getWidth();
    const height = image.getHeight();

    let data;
    if (this.dtype === '<f4') {
      // GeoTiff.js returns 32 bit uint when the tiff has 32 significant bits.
      data = rasters.map(r => new Float32Array(r.buffer));
    } else if (this.omexml.Type.startsWith('int')) {
      // geotiff.js returns the correct typedarray but need to cast to Uint for viv.
      const b = rasters[0].BYTES_PER_ELEMENT;
      // eslint-disable-next-line no-nested-ternary
      const T = b === 1 ? Uint8Array : b === 2 ? Uint16Array : Uint32Array;
      data = rasters.map(r => new T(r));
    } else {
      data = rasters;
    }
    return {
      data,
      width,
      height
    };
  }

  /**
   * Returns image width and height (at pyramid level z) without fetching data.
   * This information is inferrable from the provided omexml.
   * It is NOT the actual pixel-size but rather the image size
   * without any padding.
   * @param {Object} args
   * @param {number} args.z positive integer (0 === highest zoom level)
   * @returns {Object} width: number, height: number
   */
  getRasterSize({ z }) {
    const { width, height } = this;
    /* eslint-disable no-bitwise */
    return {
      height: height >> z,
      width: width >> z
    };
    /* eslint-disable no-bitwise */
  }

  /**
   * Get the metadata associated with an OMETiff image layer, in a human-readable format.
   * @returns {Object} Metadata keys mapped to values.
   */
  getMetadata() {
    const { omexml } = this;
    const {
      metadataOMEXML: {
        Image: { AcquisitionDate },
        StructuredAnnotations
      },
      SizeX,
      SizeY,
      SizeZ,
      SizeT,
      SizeC,
      Type,
      PhysicalSizeX,
      PhysicalSizeXUnit,
      PhysicalSizeY,
      PhysicalSizeYUnit,
      PhysicalSizeZ,
      PhysicalSizeZUnit
    } = omexml;

    const physicalSizeAndUnitX =
      PhysicalSizeX && PhysicalSizeXUnit
        ? `${PhysicalSizeX} (${PhysicalSizeXUnit})`
        : '-';
    const physicalSizeAndUnitY =
      PhysicalSizeY && PhysicalSizeYUnit
        ? `${PhysicalSizeY} (${PhysicalSizeYUnit})`
        : '-';
    const physicalSizeAndUnitZ =
      PhysicalSizeZ && PhysicalSizeZUnit
        ? `${PhysicalSizeZ} (${PhysicalSizeZUnit})`
        : '-';
    let roiCount;
    if (StructuredAnnotations) {
      const { MapAnnotation } = StructuredAnnotations;
      roiCount =
        MapAnnotation && MapAnnotation.Value
          ? Object.entries(MapAnnotation.Value).length
          : 0;
    }
    return {
      'Acquisition Date': AcquisitionDate,
      'Dimensions (XY)': `${SizeX} x ${SizeY}`,
      'Pixels Type': Type,
      'Pixels Size (XYZ)': `${physicalSizeAndUnitX} x ${physicalSizeAndUnitY} x ${physicalSizeAndUnitZ}`,
      'Z-sections/Timepoints': `${SizeZ} x ${SizeT}`,
      Channels: SizeC,
      'ROI Count': roiCount
    };
  }

  async _getChannel({ image, x, y, z, signal }) {
    const { tileSize, pool, isInterleaved: interleave } = this;
    const { height, width } = this._getTileExtent({
      x,
      y,
      z
    });
    // Passing in the height and width explicitly prevents resampling that geotiff does without such parameters.
    const rasters = await image.readRasters({
      window: [
        x * tileSize,
        y * tileSize,
        x * tileSize + width,
        y * tileSize + height
      ],
      pool,
      signal,
      width,
      height,
      interleave
    });
    const data = interleave ? rasters : rasters[0];
    if (_optionalChain$6([signal, 'optionalAccess', _3 => _3.aborted])) return null;
    if (this.omexml.Type.startsWith('int')) {
      // Uint view isn't correct for underling buffer, need to take an
      // IntXArray view and cast to UintXArray.
      if (data.BYTES_PER_ELEMENT === 1) {
        return new Uint8Array(new Int8Array(data.buffer));
      }
      if (data.BYTES_PER_ELEMENT === 2) {
        return new Uint16Array(new Int16Array(data.buffer));
      }
      return new Uint32Array(new Int32Array(data.buffer));
    }
    return data;
  }

  _tileInBounds({ x, y, z }) {
    const { width, height, tileSize, numLevels } = this;
    return isInTileBounds({
      x,
      y,
      z,
      width,
      height,
      tileSize,
      numLevels
    });
  }

  _parseIFD(index) {
    const { tiff, offsets } = this;
    if (offsets.length > 0) {
      tiff.ifdRequests[index] = tiff.parseFileDirectoryAt(offsets[index]);
    }
  }

  /**
   * For a given resolution level, z, the expected tile size on the boundary
   * of the image should be exactly enough to fit the image bounds at the resolution level.
   * This function returns that size or the parametrized tileSize from TIFF file.
   * @param {tileData: TypedArray[]} data The array to be filled in.
   * @param {Object} tile { x, y, z }
   * @returns {TypedArray} TypedArray
   */
  _getTileExtent({ x, y, z }) {
    const { tileSize } = this;
    let height = tileSize;
    let width = tileSize;
    const {
      height: zoomLevelHeight,
      width: zoomLevelWidth
    } = this.getRasterSize({ z });
    const maxXTileCoord = Math.floor(zoomLevelWidth / tileSize);
    const maxYTileCoord = Math.floor(zoomLevelHeight / tileSize);
    if (x === maxXTileCoord) {
      width = zoomLevelWidth % tileSize;
    }
    if (y === maxYTileCoord) {
      height = zoomLevelHeight % tileSize;
    }
    return { height, width };
  }
}

/**
 * A valid zarr.Store that maps keys to local a zarr.DirectoryStore.
 * @param {Map} fileMapping, keys are zarr keys and values are File objects.
 * */
class FileStore {
  constructor(fileMapping) {
    this._store = fileMapping;
  }

  async getItem(key) {
    const file = this._store.get(key);
    if (!file) {
      throw new KeyError(key);
    }
    const buffer = await file.arrayBuffer();
    return buffer;
  }

  async containsItem(key) {
    return this._store.has(key);
  }
}

async function createZarrLoader({
  url,
  dimensions,
  isPyramid,
  isRgb,
  scale,
  translate
}) {
  // TODO: This is a legacy initialization function. There is an official
  // specification now for multiscale datasets (see below), that doesn't
  // consolidate metadata in this way.
  let data;
  if (isPyramid) {
    const metadataUrl = `${url}${url.slice(-1) === '/' ? '' : '/'}.zmetadata`;
    const response = await fetch(metadataUrl);
    const { metadata } = await response.json();
    const paths = Object.keys(metadata)
      .filter(metaKey => metaKey.includes('.zarray'))
      .map(arrMetaKeys => arrMetaKeys.slice(0, -7));
    data = Promise.all(paths.map(path => openArray({ store: url, path })));
  } else {
    data = openArray({ store: url });
  }
  return new ZarrLoader({
    data: await data,
    dimensions,
    scale,
    translate,
    isRgb
  });
}

/**
 * This function wraps parsing OME-XML metadata and creating a zarr loader.
 * @param {Object} args
 * @param {(string | File[])} args.source either a string URL or array of File Objects.
 * @param {Object} args.fetchOptions options to forward to fetch requests for url if provided.
 */
async function createBioformatsZarrLoader({
  source,
  fetchOptions = {}
}) {
  const METADATA = 'METADATA.ome.xml';
  const ZARR_DIR = 'data.zarr/';

  let store;
  let omexmlBuffer;
  if (typeof source === 'string') {
    // Remote Zarr
    const baseUrl = source.endsWith('/') ? source : `${source}/`;
    const metaUrl = `${baseUrl}${METADATA}`;
    store = new HTTPStore(`${baseUrl}${ZARR_DIR}`, fetchOptions); // first image
    omexmlBuffer = await fetch(metaUrl).then(res => res.arrayBuffer());
  } else {
    // Local Zarr
    /*
     * You can't randomly access files from a directory by path name
     * without the Native File System API, so we need to get objects for _all_
     * the files right away for Zarr. This is unfortunate because we need to iterate
     * over all File objects and create an in-memory index.
     */
    const fMap = new Map();
    let keyPrefixLength;
    for (let i = 0; i < source.length; i += 1) {
      const file = source[i];
      if (file.name === METADATA) {
        // Find the metadata file.
        // eslint-disable-next-line no-await-in-loop
        omexmlBuffer = await file.arrayBuffer();
      } else {
        if (!keyPrefixLength) {
          keyPrefixLength = file.path.indexOf(ZARR_DIR) + ZARR_DIR.length;
        }
        const path = file.path.slice(keyPrefixLength);
        fMap.set(path, file);
      }
    }
    store = new FileStore(fMap);
  }

  const rootAttrs = await getJson(store, '0/.zattrs');
  let resolutions = ['0'];
  if ('multiscales' in rootAttrs) {
    // Get path to subresolutions if they exist
    const { datasets } = rootAttrs.multiscales[0];
    resolutions = datasets.map(d => `0/${d.path}`);
  }

  const promises = resolutions.map(path => openArray({ store, path }));
  const pyramid = await Promise.all(promises);

  /*
   * TODO: There should be a much better way to do this.
   * If base image is small, we don't need to fetch data for the
   * top levels of the pyramid. For large images, the tile sizes (chunks)
   * will be the same size for x/y. We check the chunksize here for this edge case.
   */
  const { chunks, shape } = pyramid[0];
  const shouldUseBase = chunks[-1] !== chunks[-2];
  const data = pyramid.length > 1 || shouldUseBase ? pyramid : pyramid[0];

  // Get OMEXML string
  const omexmlString = new TextDecoder().decode(new Uint8Array(omexmlBuffer));
  const omexml = new OMEXML(omexmlString);
  const dimensions = dimensionsFromOMEXML(omexml);

  /*
   * Specifying different dimension orders form the METADATA.ome.xml is
   * possible and necessary for creating an OME-Zarr precursor.
   *
   * e.g. `bioformats2raw --file_type=zarr --dimension-order='XYZCT'`
   *
   * This is fragile code, and will only be executed if someone
   * tries to specify different dimension orders.
   */
  const nonXYShape = shape.slice(0, -2); // XY always last dims and don't need to be compared
  const nonXYDims = dimensions.filter(d => d.values); // XY are null
  const allSameSize = nonXYShape.every(
    (s, i) => s === nonXYDims[i].values.length
  );
  if (!allSameSize) {
    // Assume OME-Zarr, dims === XYZCT
    const omeZarrDims = [
      nonXYDims.filter(d => d.field === 'time')[0],
      nonXYDims.filter(d => d.field === 'channel')[0],
      nonXYDims.filter(d => d.field === 'z')[0]
    ];
    // compare sizes of sorted dims
    if (
      !omeZarrDims.every(({ values }, i) => values.length === nonXYShape[i])
    ) {
      throw Error(
        `Dimension order is different from METADATA.ome.xml and isn't OME-Zarr.`
      );
    }
    const newDimensions = [...omeZarrDims, ...dimensions.slice(-2)]; // append YX dims
    return new ZarrLoader({ data, dimensions: newDimensions });
  }

  return new ZarrLoader({ data, dimensions });
}

/**
 * This function wraps creating a ome-tiff loader.
 * @param {Object} args
 * @param {String} args.urlOrFile URL or File Object from which to fetch the tiff.
 * @param {Array} args.offsets List of IFD offsets.
 * @param {Object} args.headers Object containing headers to be passed to all fetch requests.
 */
async function createOMETiffLoader({
  urlOrFile,
  offsets = [],
  headers = {}
}) {
  let tiff;
  if (urlOrFile instanceof File) {
    tiff = await fromBlob(urlOrFile);
  } else {
    tiff = await fromUrl(urlOrFile, headers);
  }
  const firstImage = await tiff.getImage(0);
  const pool = new Pool();
  const omexmlString = firstImage.fileDirectory.ImageDescription;
  return new OMETiffLoader({
    tiff,
    pool,
    firstImage,
    omexmlString,
    offsets
  });
}

export { BitmapLayer, DETAIL_VIEW_ID, DTYPE_VALUES, DetailView, HTTPStore, ImageLayer, MAX_SLIDERS_AND_CHANNELS, MultiscaleImageLayer, OMETiffLoader, OVERVIEW_VIEW_ID, OverviewLayer, OverviewView, PictureInPictureViewer, ScaleBarLayer, SideBySideView, SideBySideViewer, VivView, VivViewer, XRLayer, ZarrLoader, createBioformatsZarrLoader, createOMETiffLoader, createZarrLoader, getChannelStats, getDefaultInitialViewState };
